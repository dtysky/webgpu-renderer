/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/buildin/shaders/basic/color.frag.wgsl":
/*!***************************************************!*\
  !*** ./src/buildin/shaders/basic/color.frag.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] Position: vec4<f32>;\n  [[location(0)]] texcoord_0: vec2<f32>;\n  [[location(1)]] normal: vec3<f32>;\n  [[location(2)]] tangent: vec4<f32>;\n  [[location(3)]] color_0: vec3<f32>;\n  [[location(4)]] texcoord_1: vec2<f32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  var color: vec4<f32> = material.u_color;\n\n  #if defined(USE_COLOR_0)\n    color = color * vec4<f32>(vo.color_0, 1.);\n  #endif\n\n  return color;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/basic/model.vert.wgsl":
/*!***************************************************!*\
  !*** ./src/buildin/shaders/basic/model.vert.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] Position: vec4<f32>;\n  [[location(0)]] texcoord_0: vec2<f32>;\n  [[location(1)]] normal: vec3<f32>;\n  [[location(2)]] tangent: vec4<f32>;\n  [[location(3)]] color_0: vec3<f32>;\n  [[location(4)]] texcoord_1: vec2<f32>;\n};\n\n[[stage(vertex)]]\nfn main(attrs: Attrs) -> VertexOutput {\n  var output: VertexOutput;\n\n  output.Position = global.u_vp * mesh.u_world * vec4<f32>(attrs.position, 1.);\n\n  #if defined(USE_TEXCOORD_0)\n    output.texcoord_0 = attrs.texcoord_0;\n  #endif\n\n  #if defined(USE_NORMAL)\n    output.normal = attrs.normal;\n  #endif\n\n  #if defined(USE_TANGENT)\n    output.tangent = attrs.tangent;\n  #endif\n\n  #if defined(USE_COLOR_0)\n    output.color_0 = attrs.color_0;\n  #endif\n\n  #if defined(USE_TEXCOORD_1)\n    output.texcoord_1 = attrs.texcoord_1;\n  #endif\n\n  return output;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/basic/skybox.frag.wgsl":
/*!****************************************************!*\
  !*** ./src/buildin/shaders/basic/skybox.frag.wgsl ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] cubeUV: vec3<f32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  let tex: vec4<f32> = textureSample(u_cubeTexture, u_sampler, vo.cubeUV);\n  return vec4<f32>(tex.rgb * material.u_color.rgb * material.u_exposure * material.u_factor, tex.a);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/basic/skybox.vert.wgsl":
/*!****************************************************!*\
  !*** ./src/buildin/shaders/basic/skybox.vert.wgsl ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] cubeUV: vec3<f32>;\n};\n\n[[stage(vertex)]]\nfn main(attrs: Attrs) -> VertexOutput {\n  var output: VertexOutput;\n\n  let pos: vec4<f32> = vec4<f32>(attrs.position, 1., 1.);\n  output.position = pos;\n  let t: vec4<f32> = global.u_skyVP * pos;\n  output.cubeUV = normalize(t.xyz / t.w);\n\n  return output;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/basic/unlit.frag.wgsl":
/*!***************************************************!*\
  !*** ./src/buildin/shaders/basic/unlit.frag.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] Position: vec4<f32>;\n  [[location(0)]] texcoord_0: vec2<f32>;\n  [[location(1)]] normal: vec3<f32>;\n  [[location(2)]] tangent: vec4<f32>;\n  [[location(3)]] color_0: vec3<f32>;\n  [[location(4)]] texcoord_1: vec2<f32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  return material.u_baseColorFactor * textureSample(u_baseColorTexture, u_sampler, vo.texcoord_0);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/compute/blur.comp.wgsl":
/*!****************************************************!*\
  !*** ./src/buildin/shaders/compute/blur.comp.wgsl ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "let c_radius: i32 = ${RADIUS};\nlet c_windowSize: i32 = ${WINDOW_SIZE};\n\nvar<workgroup> tileCache: array<array<vec3<f32>, ${TILE_SIZE}>, ${TILE_SIZE}>;\n\n[[stage(compute), workgroup_size(c_windowSize, c_windowSize, 1)]]\nfn main(\n  [[builtin(workgroup_id)]] workGroupID : vec3<u32>,\n  [[builtin(local_invocation_id)]] localInvocationID : vec3<u32>\n) {\n  let size: vec2<i32> = textureDimensions(u_input, 0);\n  let windowSize: vec2<i32> = vec2<i32>(c_windowSize, c_windowSize);\n  let groupOffset: vec2<i32> = vec2<i32>(workGroupID.xy) * windowSize;\n  let baseIndex: vec2<i32> = groupOffset + vec2<i32>(localInvocationID.xy);\n  let baseUV: vec2<f32> = vec2<f32>(baseIndex) / vec2<f32>(size);\n  // let center: vec2<i32> = vec2<i32>(localInvocationID.xy) + vec2<i32>(c_radius, c_radius);\n  // var color: vec4<f32> = vec4<f32>(0., 0., 0., 1.);\n\n  // if (baseIndex.x < size.x && baseIndex.y < size.y) {\n  //   color = textureSampleLevel(u_input, u_sampler, baseUV, 0.);\n  //   tileCache[center.x][center.y] = color.rgb;\n  // }\n\n  // workgroupBarrier();\n\n  var weightsSum: f32 = 0.;\n  var res: vec4<f32> = vec4<f32>(0., 0., 0., 1.);\n  for (var r: i32 = -c_radius; r <= c_radius; r = r + 1) {\n    for (var c: i32 = -c_radius; c <= c_radius; c = c + 1) {\n      let iuv: vec2<i32> = baseIndex + vec2<i32>(r, c);\n\n      if (any(iuv < vec2<i32>(0)) || any(iuv >= size)) {\n        continue;\n      }\n\n      let weightIndex: i32 = (r + c_radius) * c_windowSize + (c + c_radius);\n      let weight: f32 = material.u_kernel[weightIndex / 4][weightIndex % 4];\n      weightsSum = weightsSum + weight;\n      res = res + weight * textureLoad(u_input, iuv, 0);\n    }\n  }\n  res = res / f32(weightsSum);\n\n  textureStore(u_output, baseIndex, res);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/image/blit.frag.wgsl":
/*!**************************************************!*\
  !*** ./src/buildin/shaders/image/blit.frag.wgsl ***!
  \**************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] uv: vec2<f32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  return textureSample(u_texture, u_sampler, vo.uv);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/image/image.vert.wgsl":
/*!***************************************************!*\
  !*** ./src/buildin/shaders/image/image.vert.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] uv: vec2<f32>;\n};\n\nvar<private> pos: array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(-1.0, -1.0),\n  vec2<f32>(1.0, -1.0),\n  vec2<f32>(-1.0, 1.0),\n  vec2<f32>(-1.0, 1.0),\n  vec2<f32>(1.0, -1.0),\n  vec2<f32>(1.0, 1.0)\n);\nvar<private> uv: array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(0.0, 1.0),\n  vec2<f32>(1.0, 1.0),\n  vec2<f32>(0.0, 0.0),\n  vec2<f32>(0.0, 0.0),\n  vec2<f32>(1.0, 1.0),\n  vec2<f32>(1.0, 0.0)\n);\n\n[[stage(vertex)]]\nfn main([[builtin(vertex_index)]] VertexIndex : u32) -> VertexOutput {\n  var output: VertexOutput;\n\n  output.position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n  output.uv = uv[VertexIndex];\n\n  #if defined(FLIP)\n    output.uv.y = 1. - output.uv.y;\n  #endif\n\n  return output;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/image/tone.frag.wgsl":
/*!**************************************************!*\
  !*** ./src/buildin/shaders/image/tone.frag.wgsl ***!
  \**************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] uv: vec2<f32>;\n};\n\nlet A: f32 = 2.51;\nlet B: f32 = 0.03;\nlet C: f32 = 2.43;\nlet D: f32 = 0.59;\nlet E: f32 = 0.14;\t\n\nfn acesToneMapping(color: vec3<f32>) -> vec3<f32> {\n  return (color * (A * color + B)) / (color * (C * color + D) + E); \n}\n\nfn gammaCorrect(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3<f32>(0.45454545454545453));\n}\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  let gamma: f32 = 2.2;\n  let hdrColor: vec4<f32> = textureSample(u_texture, u_sampler, vo.uv);\n  var color = acesToneMapping(hdrColor.rgb);\n\n  return vec4<f32>(color, hdrColor.a);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/denoiseSpace.comp.wgsl":
/*!****************************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/denoiseSpace.comp.wgsl ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = "let WINDOW_SIZE: i32 = ${WINDOW_SIZE};\n\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/basic/tone.chunk.wgsl\nlet A: f32 = 2.51;\nlet B: f32 = 0.03;\nlet C: f32 = 2.43;\nlet D: f32 = 0.59;\nlet E: f32 = 0.14;\t\n\nfn acesToneMapping(color: vec3<f32>) -> vec3<f32> {\n  return (color * (A * color + B)) / (color * (C * color + D) + E); \n}\n\nfn gammaCorrect(color: vec3<f32>, gamma: f32) -> vec3<f32> {\n  return pow(color, vec3<f32>(1. / gamma));\n}\n\n//require end\n;\n\nfn calcWeightNumber(params: vec2<f32>, a: f32, b: f32) -> f32 {\n  return params.x * exp(params.y * (a - b) * (a - b));\n}\n\nfn calcWeightVec2(params: vec2<f32>, a: vec2<i32>, b: vec2<i32>) -> f32 {\n  let diff: vec2<f32> = vec2<f32>(a - b);\n  return params.x * exp(params.y * dot(diff, diff));\n}\n\nfn calcWeightVec3(params: vec2<f32>, a: vec3<f32>, b: vec3<f32>) -> f32 {\n  let diff: vec3<f32> = a - b;\n  return params.x * exp(params.y * dot(diff, diff));\n}\n\nfn calcLum(color: vec3<f32>) -> f32 {\n  return dot(color, vec3<f32>(0.2125, 0.7154, 0.0721));\n}\n\nfn blur(center: vec2<i32>, size: vec2<i32>) -> vec4<f32> {\n  let radius: i32 = WINDOW_SIZE / 2;\n  let zigmaD: vec2<f32> = material.u_filterFactors[0].xy;\n  let zigmaC: vec2<f32> = material.u_filterFactors[1].xy;\n  let zigmaZ: vec2<f32> = material.u_filterFactors[2].xy;\n  let zigmaN: vec2<f32> = material.u_filterFactors[3].xy;\n  let centerColor: vec4<f32> = textureLoad(u_mixed, center);\n  let centerPosition = textureLoad(u_gbPositionMetalOrSpec, center, 0).xyz;\n  let centerNormal = textureLoad(u_gbNormalGlass, center, 0).xyz;\n  var colors: array<array<vec3<f32>, ${WINDOW_SIZE}>, ${WINDOW_SIZE}>;\n  var lums: array<array<f32, ${WINDOW_SIZE}>, ${WINDOW_SIZE}>;\n\n  var minUV: vec2<i32> = max(center - vec2<i32>(radius, radius), vec2<i32>(0));\n  var maxUV: vec2<i32> = min(center + vec2<i32>(radius, radius), size);\n  var localUV: vec2<i32> = vec2<i32>(0, 0);\n  var sumLum: f32 = 0.;\n  var count: f32 = 0.;\n\n  for (var r: i32 = minUV.x; r <= maxUV.x; r = r + 1) {\n    localUV.y = 0;\n    for (var c: i32 = minUV.y; c <= maxUV.y; c = c + 1) {\n      let iuv: vec2<i32> = vec2<i32>(r, c);\n      let color: vec3<f32> = textureLoad(u_mixed, iuv).rgb;\n      let lum: f32 = calcLum(color);\n      colors[localUV.x][localUV.y] = color;\n      lums[localUV.x][localUV.y] = lum;\n\n      sumLum = sumLum + lum;\n      count = count + 1.;\n      localUV.y = localUV.y + 1;\n    }\n    localUV.x = localUV.x + 1;\n  }\n\n  let meanLum: f32 = sumLum / count;\n\n  var std: f32 = 0.;\n  for (var r: i32 = 0; r < localUV.x; r = r + 1) {\n    for (var c: i32 = 0; c < localUV.y; c = c + 1) {\n      let lum: f32 = lums[r][c];\n      std = std + (lum - meanLum) * (lum - meanLum);\n    }\n  }\n  std = sqrt(std / (count - 1.));\n\n  let largestLum: f32 = max(meanLum + std * 2., 1.);\n\n  localUV = vec2<i32>(0, 0);\n  var weightsSum: f32 = 0.;\n  var res: vec3<f32> = vec3<f32>(0., 0., 0.);\n\n  for (var r: i32 = minUV.x; r <= maxUV.x; r = r + 1) {\n    localUV.y = 0;\n    for (var c: i32 = minUV.y; c <= maxUV.y; c = c + 1) {\n      var color: vec3<f32> = colors[localUV.x][localUV.y];\n      let lum: f32 = lums[localUV.x][localUV.y];\n\n      if (lum > largestLum) {\n        color = color * meanLum / lum;\n      }\n\n      let iuv: vec2<i32> = vec2<i32>(r, c);\n      let position: vec4<f32> = textureLoad(u_gbPositionMetalOrSpec, iuv, 0);\n      let normal: vec4<f32> = textureLoad(u_gbNormalGlass, iuv, 0);\n      let weight: f32 = calcWeightVec2(zigmaD, iuv, center)\n        * calcWeightVec3(zigmaC, color.rgb, centerColor.rgb)\n        * calcWeightVec3(zigmaN, normal.xyz, centerNormal.xyz)\n        * calcWeightNumber(zigmaZ, position.z, centerPosition.z);\n      weightsSum = weightsSum + weight;\n      res = res + weight * color;\n\n      localUV.y = localUV.y + 1;\n    }\n    localUV.x = localUV.x + 1;\n  }\n\n  res = res / weightsSum;\n\n  return vec4<f32>(res, centerColor.a);\n}\n\n[[stage(compute), workgroup_size(16, 16, 1)]]\nfn main(\n  [[builtin(workgroup_id)]] workGroupID : vec3<u32>,\n  [[builtin(local_invocation_id)]] localInvocationID : vec3<u32>\n) {\n  let size: vec2<i32> = textureDimensions(u_mixed);\n  let groupOffset: vec2<i32> = vec2<i32>(workGroupID.xy) * 16;\n  let baseIndex: vec2<i32> = groupOffset + vec2<i32>(localInvocationID.xy);\n\n  var mixed: vec4<f32>;\n\n  mixed = blur(baseIndex, size);\n\n\n  textureStore(u_output, baseIndex, vec4<f32>(acesToneMapping(mixed.rgb), mixed.a));\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/denoiseTempor.comp.wgsl":
/*!*****************************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/denoiseTempor.comp.wgsl ***!
  \*****************************************************************/
/***/ ((module) => {

module.exports = "[[stage(compute), workgroup_size(16, 16, 1)]]\nfn main(\n  [[builtin(workgroup_id)]] workGroupID : vec3<u32>,\n  [[builtin(local_invocation_id)]] localInvocationID : vec3<u32>\n) {\n  let size: vec2<i32> = textureDimensions(u_current);\n  let groupOffset: vec2<i32> = vec2<i32>(workGroupID.xy) * 16;\n  let baseIndex: vec2<i32> = groupOffset + vec2<i32>(localInvocationID.xy);\n\n  let pre: vec4<f32> = textureLoad(u_pre, baseIndex);\n  let current: vec4<f32> = textureLoad(u_current, baseIndex);\n  let mixed: vec4<f32> = vec4<f32>(mix(current.rgb, pre.rgb, vec3<f32>(material.u_preWeight)), current.a);\n\n  textureStore(u_output, baseIndex, mixed);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/gbuffer.frag.wgsl":
/*!***********************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/gbuffer.frag.wgsl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] wPosition: vec4<f32>;\n  [[location(1)]] texcoord_0: vec2<f32>;\n  [[location(2)]] normal: vec3<f32>;\n  [[location(3)]] meshMatIndex: vec2<u32>;\n};\n\nstruct FragmentOutput {\n  [[location(0)]] positionMetalOrSpec: vec4<f32>;\n  [[location(1)]] baseColorRoughOrGloss: vec4<f32>;\n  [[location(2)]] normalGlass: vec4<f32>;\n  [[location(3)]] meshIndexMatIndexMatType: vec4<u32>;\n};\n\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/common.chunk.wgsl\nlet MAT_TYPE_METAL_ROUGH: u32 = 0u;\nlet MAT_TYPE_SPEC_GLOSS: u32 = 1u;\nlet MAT_TYPE_GLASS_METAL_ROUGH: u32 = 2u;\nlet MAT_TYPE_GLASS_SPEC_GLOSS: u32 = 3u;\nlet MAT_TYPE_LIGHT: u32 = 4u;\n\nfn isMatSpecGloss(matType: u32) -> bool {\n  return matType == MAT_TYPE_SPEC_GLOSS || matType == MAT_TYPE_GLASS_SPEC_GLOSS;\n}\n\nfn isMatGlass(matType: u32) -> bool {\n  return matType == MAT_TYPE_GLASS_METAL_ROUGH || matType == MAT_TYPE_GLASS_SPEC_GLOSS;\n}\n\nfn isMatLight(matType: u32) -> bool {\n  return matType == MAT_TYPE_LIGHT;\n}\n\nfn getRoughness(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).g;\n}\n\nfn getMetallic(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).b;\n}\n\nfn getSpecular(factor: vec3<f32>, textureId: i32, uv: vec2<f32>) -> vec3<f32> {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).rgb;\n}\n\nfn getGlossiness(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).a;\n}\n\nfn getBaseColor(factor: vec4<f32>, textureId: i32, uv: vec2<f32>) -> vec4<f32> {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_baseColorTextures, u_sampler, uv, textureId, 0.);\n}\n\n//require end\n;\n\nfn getFaceNormal(position: vec3<f32>) -> vec3<f32> {\n  return normalize(cross(dpdy(position), dpdx(position)));\n}\n\nfn getNormal(\n  vNormal: vec3<f32>, position: vec3<f32>, faceNormal: vec3<f32>,\n  textureId: i32, uv: vec2<f32>, normalScale: f32\n) -> vec3<f32> {\n  var normal: vec3<f32> = normalize(vNormal);\n  normal = normal * sign(dot(normal, faceNormal));\n\n  if (textureId == -1) {\n    return normal;\n  }\n\n  // http://www.thetenthplanet.de/archives/1180\n  let dp1: vec3<f32> = dpdx(position);\n  let dp2: vec3<f32> = dpdy(position);\n  let duv1: vec2<f32> = dpdx(uv);\n  let duv2: vec2<f32> = dpdy(uv);\n  let dp2perp: vec3<f32> = cross(dp2, normal);\n  let dp1perp: vec3<f32> = cross(normal, dp1);\n  var dpdu: vec3<f32> = dp2perp * duv1.x + dp1perp * duv2.x;\n  var dpdv: vec3<f32> = dp2perp * duv1.y + dp1perp * duv2.y;\n  let invmax: f32 = inverseSqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n  dpdu = dpdu * invmax;\n  dpdv = dpdv * invmax;\n  let tbn: mat3x3<f32> = mat3x3<f32>(dpdu, dpdv, normal);\n  var tNormal: vec3<f32> = 2. * textureSample(u_normalTextures, u_sampler, uv, textureId).xyz - 1.;\n  tNormal = tNormal * vec3<f32>(normalScale, normalScale, 1.);\n\n  return normalize(tbn * tNormal);\n}\n\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> FragmentOutput {\n  var fo: FragmentOutput;\n\n  let meshId: u32 = vo.meshMatIndex[0];\n  let matId: u32 = vo.meshMatIndex[1];\n  let metallicRoughnessFactorNormalScaleMaterialType: vec4<f32> = material.u_metallicRoughnessFactorNormalScaleMaterialTypes[matId];\n  let specularGlossinessFactor: vec4<f32> = material.u_specularGlossinessFactors[matId];\n  let textureIds: vec4<i32> = material.u_matId2TexturesId[matId];\n  let matType = u32(metallicRoughnessFactorNormalScaleMaterialType[3]);\n  let isSpecGloss: bool = isMatSpecGloss(matType);\n\n  fo.positionMetalOrSpec = vec4<f32>(vo.wPosition.xyz, 0.);\n\n  let baseColor: vec4<f32> = getBaseColor(material.u_baseColorFactors[matId], textureIds[0], vo.texcoord_0);\n  fo.baseColorRoughOrGloss = vec4<f32>(baseColor.rgb, 0.);\n\n  if (isSpecGloss) {\n    fo.positionMetalOrSpec.w = getSpecular(specularGlossinessFactor.xyz, textureIds[2], vo.texcoord_0).r;\n    fo.baseColorRoughOrGloss.w = getGlossiness(specularGlossinessFactor[3], textureIds[2], vo.texcoord_0);\n  } else {\n    fo.positionMetalOrSpec.w = getMetallic(metallicRoughnessFactorNormalScaleMaterialType[0], textureIds[2], vo.texcoord_0);\n    fo.baseColorRoughOrGloss.w = getRoughness(metallicRoughnessFactorNormalScaleMaterialType[1], textureIds[2], vo.texcoord_0);\n  }\n\n  let faceNormal: vec3<f32> = getFaceNormal(vo.wPosition.xyz);\n  fo.normalGlass = vec4<f32>(\n    getNormal(vo.normal, vo.wPosition.xyz, faceNormal, textureIds[1], vo.texcoord_0, metallicRoughnessFactorNormalScaleMaterialType[2]),\n    baseColor.a\n  );\n\n  // alpha is used for judge hited\n  fo.meshIndexMatIndexMatType = vec4<u32>(meshId, matId, matType, 2u);\n\n  return fo;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/gbuffer.vert.wgsl":
/*!***********************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/gbuffer.vert.wgsl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] wPosition: vec4<f32>;\n  [[location(1)]] texcoord_0: vec2<f32>;\n  [[location(2)]] normal: vec3<f32>;\n  [[location(3)]] meshMatIndex: vec2<u32>;\n};\n\n[[stage(vertex)]]\nfn main(attrs: Attrs) -> VertexOutput {\n  var output: VertexOutput;\n  \n  let wPosition: vec4<f32> = vec4<f32>(attrs.position, 1.);\n  \n  output.position = global.u_vp * wPosition;\n  output.wPosition = wPosition;\n  output.texcoord_0 = attrs.texcoord_0;\n  output.normal = attrs.normal;\n  output.meshMatIndex.x = attrs.meshMatIndex.x;\n  output.meshMatIndex.y = attrs.meshMatIndex.y;\n\n  return output;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/gbufferLight.frag.wgsl":
/*!****************************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/gbufferLight.frag.wgsl ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] Position: vec4<f32>;\n  [[location(0)]] texcoord_0: vec2<f32>;\n  [[location(1)]] normal: vec3<f32>;\n  [[location(2)]] tangent: vec4<f32>;\n  [[location(3)]] color_0: vec3<f32>;\n  [[location(4)]] texcoord_1: vec2<f32>;\n};\n\nstruct FragmentOutput {\n  [[location(0)]] positionMetalOrSpec: vec4<f32>;\n  [[location(1)]] baseColorRoughOrGloss: vec4<f32>;\n  [[location(2)]] normalGlass: vec4<f32>;\n  [[location(3)]] meshIndexMatIndexMatType: vec4<u32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> FragmentOutput {\n  var fo: FragmentOutput;\n\n  fo.baseColorRoughOrGloss = vec4<f32>(material.u_lightColor.rgb, 0.);\n  fo.meshIndexMatIndexMatType = vec4<u32>(0u, 0u, 4u, 2u);\n\n  return fo;\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/gshow.frag.wgsl":
/*!*********************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/gshow.frag.wgsl ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = "struct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] uv: vec2<f32>;\n};\n\n[[stage(fragment)]]\nfn main(vo: VertexOutput) -> [[location(0)]] vec4<f32> {\n  let uv: vec2<f32> = vo.uv;\n\n  if (uv.x < .33) {\n    return vec4<f32>(textureSample(u_gbPositionMetalOrSpec, u_sampler, uv).rgb, 1.);\n  }\n  \n  if (uv.x < .66) {\n    return vec4<f32>(textureSample(u_gbBaseColorRoughOrGloss, u_sampler, uv).rgb, 1.);\n  }\n  \n  return vec4<f32>(textureSample(u_gbNormalGlass, u_sampler, uv).rgb, 1.);\n}\n"

/***/ }),

/***/ "./src/buildin/shaders/ray-tracing/rtss.comp.wgsl":
/*!********************************************************!*\
  !*** ./src/buildin/shaders/ray-tracing/rtss.comp.wgsl ***!
  \********************************************************/
/***/ ((module) => {

module.exports = "let PI: f32 = 3.14159265358979;\nlet MAX_LIGHTS_COUNT: u32 = 4u;\nlet MAX_RAY_LENGTH: f32 = 9999.;\nlet BVH_DEPTH: i32 = ${BVH_DEPTH};\nlet EPS: f32 = 0.005;\nlet RAY_DIR_OFFSET: f32 = .01;\nlet RAY_NORMAL_OFFSET: f32 = .01;\n\nstruct VertexOutput {\n  [[builtin(position)]] position: vec4<f32>;\n  [[location(0)]] uv: vec2<f32>;\n};\n\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/basic/common.chunk.wgsl\nlet LIGHT_TYPE_INVALID: u32 = 0u;\nlet LIGHT_TYPE_AREA: u32 = 1u;\nlet LIGHT_TYPE_DIRECTIONAL: u32 = 2u;\nlet LIGHT_TYPE_POINT: u32 = 3u;\nlet LIGHT_TYPE_SPOT: u32 = 4u;\n\nlet LIGHT_AREA_RRCT: u32 = 0u;\nlet LIGHT_AREA_DISC: u32 = 1u;\n\n//require end\n;\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/common.chunk.wgsl\nlet MAT_TYPE_METAL_ROUGH: u32 = 0u;\nlet MAT_TYPE_SPEC_GLOSS: u32 = 1u;\nlet MAT_TYPE_GLASS_METAL_ROUGH: u32 = 2u;\nlet MAT_TYPE_GLASS_SPEC_GLOSS: u32 = 3u;\nlet MAT_TYPE_LIGHT: u32 = 4u;\n\nfn isMatSpecGloss(matType: u32) -> bool {\n  return matType == MAT_TYPE_SPEC_GLOSS || matType == MAT_TYPE_GLASS_SPEC_GLOSS;\n}\n\nfn isMatGlass(matType: u32) -> bool {\n  return matType == MAT_TYPE_GLASS_METAL_ROUGH || matType == MAT_TYPE_GLASS_SPEC_GLOSS;\n}\n\nfn isMatLight(matType: u32) -> bool {\n  return matType == MAT_TYPE_LIGHT;\n}\n\nfn getRoughness(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).g;\n}\n\nfn getMetallic(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).b;\n}\n\nfn getSpecular(factor: vec3<f32>, textureId: i32, uv: vec2<f32>) -> vec3<f32> {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).rgb;\n}\n\nfn getGlossiness(factor: f32, textureId: i32, uv: vec2<f32>) -> f32 {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_metalRoughOrSpecGlossTextures, u_sampler, uv, textureId, 0.).a;\n}\n\nfn getBaseColor(factor: vec4<f32>, textureId: i32, uv: vec2<f32>) -> vec4<f32> {\n  if (textureId == -1) {\n    return factor;\n  }\n\n  return factor * textureSampleLevel(u_baseColorTextures, u_sampler, uv, textureId, 0.);\n}\n\n//require end\n;\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/pbr/common.chunk.wgsl\nstruct PBRData {\n  reflectance0: vec3<f32>;\n  reflectance90: vec3<f32>;\n  alphaRoughness: f32;\n  diffuseColor: vec3<f32>;\n  specularColor: vec3<f32>;\n  baseColor: vec3<f32>;\n  ao: vec3<f32>;\n  roughness: f32;\n};\n\nfn pbrSpecularReflection(reflectance0: vec3<f32>, reflectance90: vec3<f32>, VdotH: f32)-> vec3<f32> {\n  return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfn pbrGeometricOcclusion(NdotL: f32, NdotV: f32, alphaRoughness: f32)-> f32 {\n  let r: f32 = alphaRoughness * alphaRoughness;\n\n  let attenuationL: f32 = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));\n  let attenuationV: f32 = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\nfn pbrMicrofacetDistribution(alphaRoughness: f32, NdotH: f32)-> f32 {\n  let roughnessSq: f32 = alphaRoughness * alphaRoughness;\n  let f: f32 = NdotH * NdotH * (roughnessSq - NdotH) + 1.0;\n  return roughnessSq * 0.3183098861837907 / (f * f);\n}\n\nfn pbrPrepareData(\n  isSpecGloss: bool,\n  baseColor: vec3<f32>,\n  metal: f32, rough: f32,\n  spec: vec3<f32>, gloss: f32\n) -> PBRData {\n  var pbr: PBRData;\n\n  var specularColor: vec3<f32>;\n  var roughness: f32;\n\n  // metallic roughness\n  if (!isSpecGloss) {\n    roughness = clamp(rough, 0.04, 1.0);\n    let metallic: f32 = clamp(metal, 0.0, 1.0);\n    let f0: vec3<f32> = vec3<f32>(0.04, 0.04, 0.04);\n\n    specularColor = mix(f0, baseColor, vec3<f32>(metallic));\n    pbr.diffuseColor = (1.0 - metallic) * (baseColor * (vec3<f32>(1.0, 1.0, 1.0) - f0));\n  }\n  else {\n  // specular glossiness\n    roughness = 1.0 - gloss;\n    specularColor = spec;\n    pbr.diffuseColor = baseColor * (1.0 - max(max(specularColor.r, specularColor.g), specularColor.b));\n  }\n  \n  pbr.baseColor = baseColor;\n  pbr.specularColor = specularColor;\n  pbr.roughness = roughness;\n  \n  let reflectance: f32 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  pbr.reflectance90 = vec3<f32>(clamp(reflectance * 25.0, 0.0, 1.0));\n  pbr.reflectance0 = specularColor.rgb;\n  pbr.alphaRoughness = roughness * roughness;\n\n  return pbr;\n}\n\nfn pbrCalculateLo(\n  pbr: PBRData, normal: vec3<f32>,\n  viewDir: vec3<f32>, lightDir: vec3<f32>\n)-> vec3<f32> {\n  let H: vec3<f32> = normalize(lightDir + viewDir);\n  let NdotV: f32 = clamp(abs(dot(normal, viewDir)), 0.001, 1.0);\n  let NdotL: f32 = clamp(dot(normal, lightDir), 0.001, 1.0);\n  let NdotH: f32 = clamp(dot(normal, H), 0.0, 1.0);\n  let LdotH: f32 = clamp(abs(dot(lightDir, H)), 0.0, 1.0);\n  let VdotH: f32 = clamp(dot(viewDir, H), 0.0, 1.0);\n  // Calculate the shading terms for the microfacet specular shading model\n  let F: vec3<f32> = pbrSpecularReflection(pbr.reflectance0, pbr.reflectance90, VdotH);\n  let G: f32 = pbrGeometricOcclusion(NdotL, NdotV, pbr.alphaRoughness);\n  let D: f32 = pbrMicrofacetDistribution(pbr.alphaRoughness, NdotH);\n\n  let specContrib: vec3<f32> = F * G * D / (4.0 * NdotL * NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return NdotL * specContrib;\n}\n\n//require end\n;\n\nstruct Ray {\n  origin: vec3<f32>;\n  dir: vec3<f32>;\n  invDir: vec3<f32>;\n};\n\nstruct HitPoint {\n  hit: bool;\n  hited: f32;\n  position: vec3<f32>;\n  baseColor: vec3<f32>;\n  metal: f32;\n  rough: f32;\n  spec: vec3<f32>;\n  gloss: f32;\n  glass: f32;\n  normal: vec3<f32>;\n  // sign: if render back, is -1, or 1\n  sign: f32;\n  meshIndex: u32;\n  matIndex: u32;\n  isSpecGloss: bool;\n  isGlass: bool;\n  isLight: bool;\n  matType: u32;\n  pbrData: PBRData;\n};\n\nstruct Light {\n  color: vec3<f32>;\n  throughEng: vec3<f32>;\n  next: Ray;\n};\n\nstruct BVHNode {\n  child0Index: u32;\n  child1Index: u32;\n  max: vec3<f32>;\n  min: vec3<f32>;\n};\n\nstruct BVHLeaf {\n  primitives: u32;\n  indexes: vec3<u32>;\n};\n\nstruct FragmentInfo {\n  hit: bool;\n  hitPoint: vec3<f32>;\n  t: f32;\n  // areal coordinates\n  weights: vec3<f32>;\n  p0: vec3<f32>;\n  p1: vec3<f32>;\n  p2: vec3<f32>;\n  uv0: vec2<f32>;\n  uv1: vec2<f32>;\n  uv2: vec2<f32>;\n  n0: vec3<f32>;\n  n1: vec3<f32>;\n  n2: vec3<f32>;\n  meshIndex: u32;\n  matIndex: u32;\n  matType: u32;\n};\n\nstruct Child {\n  isLeaf: bool;\n  offset: u32;\n};\n\nfn getRandom(uv: vec2<f32>, i: i32) -> vec4<f32> {\n  let noise: vec4<f32> = textureSampleLevel(u_noise, u_sampler, uv, 0.);\n\n  return fract(material.u_randoms[i] + noise);\n}\n\nfn genRay(origin: vec3<f32>, dir: vec3<f32>) -> Ray {\n  var ray: Ray;\n  ray.origin = origin;\n  ray.dir = dir;\n  ray.invDir = 1. / ray.dir;\n\n  return ray;\n}\n\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/gbInfo.chunk.wgsl\nfn genWorldRayByGBuffer(uv: vec2<f32>, gBInfo: HitPoint) -> Ray {\n  let pixelSSPos: vec4<f32> = vec4<f32>(uv.x * 2. - 1., 1. - uv.y * 2., 0., 1.);\n  var pixelWorldPos: vec4<f32> = global.u_viewInverse * global.u_projInverse * pixelSSPos;\n  pixelWorldPos = pixelWorldPos / pixelWorldPos.w;\n\n  return genRay(pixelWorldPos.xyz, normalize(gBInfo.position - pixelWorldPos.xyz));\n};\n\nfn getGBInfo(index: vec2<i32>) -> HitPoint {\n  var info: HitPoint;\n\n  let wPMtlSpec: vec4<f32> = textureLoad(u_gbPositionMetalOrSpec, index, 0);\n  let dfRghGls: vec4<f32> = textureLoad(u_gbBaseColorRoughOrGloss, index, 0);\n  let nomGlass: vec4<f32> = textureLoad(u_gbNormalGlass, index, 0);\n  let meshIdMatIdMatType: vec4<u32> = textureLoad(u_gbMeshIndexMatIndexMatType, index, 0);\n\n  info.position = wPMtlSpec.xyz;\n  info.metal = wPMtlSpec.w;\n  info.baseColor = dfRghGls.xyz;\n  info.rough = dfRghGls.w;\n  info.spec = vec3<f32>(wPMtlSpec.w);\n  info.gloss = dfRghGls.w;\n  info.normal = nomGlass.xyz;\n  info.sign = 1.;\n  info.glass = nomGlass.w;\n  info.meshIndex = meshIdMatIdMatType.x;\n  info.matIndex = meshIdMatIdMatType.y;\n  let matType: u32 = meshIdMatIdMatType.z;\n  info.hit = meshIdMatIdMatType.w == 2u;\n  info.hited = f32(meshIdMatIdMatType.w);\n  info.isSpecGloss = isMatSpecGloss(matType);\n  info.isGlass = isMatGlass(matType);\n  info.isLight = info.hit && isMatLight(matType);\n  info.matType = matType;\n  info.pbrData = pbrPrepareData(info.isSpecGloss, info.baseColor, info.metal, info.rough, info.spec, info.gloss);\n\n  return info;\n};\n\n//require end\n;\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/hitTest.chunk.wgsl\nfn decodeChild(index: u32) -> Child {\n  return Child((index >> 31u) != 0u, (index << 1u) >> 1u);\n}\n\nfn getBVHNodeInfo(offset: u32) -> BVHNode {\n  var node: BVHNode;\n  let data0: vec4<f32> = u_bvh.value[offset];\n  let data1: vec4<f32> = u_bvh.value[offset + 1u];\n  node.child0Index = bitcast<u32>(data0[0]);\n  node.child1Index = bitcast<u32>(data1[0]);\n  node.min = data0.yzw;\n  node.max = data1.yzw;\n\n  return node;\n}\n\nfn getBVHLeafInfo(offset: u32) -> BVHLeaf {\n  var leaf: BVHLeaf;\n  let data1: vec4<f32> = u_bvh.value[offset];\n  leaf.primitives = bitcast<u32>(data1.x);\n  leaf.indexes.x = bitcast<u32>(data1.y);\n  leaf.indexes.y = bitcast<u32>(data1.z);\n  leaf.indexes.z = bitcast<u32>(data1.w);\n\n  return leaf;\n}\n\nfn getFaceNormal(frag: FragmentInfo) -> vec3<f32> {\n  return normalize(cross(frag.p1 - frag.p0, frag.p2 - frag.p0));\n}\n\nfn getNormal(\n  frag: FragmentInfo, uv: vec2<f32>,\n  textureId: i32, normalScale: f32\n) -> vec3<f32> {\n  var normal: vec3<f32> = normalize(\n    frag.n0 * frag.weights[0] + frag.n0 * frag.weights[1] + frag.n0 * frag.weights[2]\n  );\n  normal = normal;\n\n  if (textureId == -1) {\n    return normal;\n  }\n\n  // // http://www.thetenthplanet.de/archives/1180\n  let dp1: vec3<f32> = frag.p1 - frag.p0;\n  let dp2: vec3<f32> = frag.p2 - frag.p0;\n  let duv1: vec2<f32> = frag.uv2 - frag.uv0;\n  let duv2: vec2<f32> = frag.uv1 - frag.uv0;\n  let dp2perp: vec3<f32> = cross(dp2, normal);\n  let dp1perp: vec3<f32> = cross(normal, dp1);\n  var dpdu: vec3<f32> = dp2perp * duv1.x + dp1perp * duv2.x;\n  var dpdv: vec3<f32> = dp2perp * duv1.y + dp1perp * duv2.y;\n  let invmax: f32 = inverseSqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n  dpdu = dpdu * invmax;\n  dpdv = dpdv * invmax;\n  let tbn: mat3x3<f32> = mat3x3<f32>(dpdu, dpdv, normal);\n  var tNormal: vec3<f32> = 2. * textureSampleLevel(u_normalTextures, u_sampler, uv, textureId, 0.).xyz - 1.;\n  tNormal = tNormal * vec3<f32>(normalScale, normalScale, 1.);\n\n  return normalize(tbn * tNormal);\n}\n\n// https://tavianator.com/2011/ray_box.html\nfn boxHitTest(ray: Ray, max: vec3<f32>, min: vec3<f32>) -> f32 {\n  let t1: vec3<f32> = (min - ray.origin) * ray.invDir;\n  let t2: vec3<f32> = (max - ray.origin) * ray.invDir;\n  let tvmin: vec3<f32> = min(t1, t2);\n  let tvmax: vec3<f32> = max(t1, t2);\n  let tmin: f32 = max(tvmin.x, max(tvmin.y, tvmin.z));\n  let tmax: f32 = min(tvmax.x, min(tvmax.y, tvmax.z));\n\n  if (tmax - tmin < 0.) {\n    return -1.;\n  }\n  \n  if (tmin > 0.) {\n    return tmin;\n  }\n\n  return tmax;\n}\n\nfn triangleHitTest(ray: Ray, leaf: BVHLeaf) -> FragmentInfo {\n  var info: FragmentInfo;\n  let indexes: vec3<u32> = leaf.indexes;\n  info.p0 = u_positions.value[indexes[0]];\n  info.p1 = u_positions.value[indexes[1]];\n  info.p2 = u_positions.value[indexes[2]];\n\n  // if ray is very near to its egde, test will be failed, especially when trangle is very small\n  let e0: vec3<f32> = info.p1 - info.p0;\n  let e1: vec3<f32> = info.p2 - info.p0;\n  let p: vec3<f32> = cross(ray.dir, e1);\n  var det: f32 = dot(e0, p);\n  var t: vec3<f32> = ray.origin - info.p0;\n\n  if (det < 0.) {\n    t = -t;\n    det = -det;\n  }\n\n  if (det < 0.0001) {\n    return info;\n  }\n\n  let u: f32 = dot(t, p);\n\n  if (u < 0. || u > det) {\n    return info;\n  }\n\n  let q: vec3<f32> = cross(t, e0);\n  let v: f32 = dot(ray.dir, q);\n\n  if (v < 0. || v + u - det > 0.) {\n    return info;\n  }\n\n  let lt: f32 = dot(e1, q);\n\n  if (lt < 0.) {\n    return info;\n  }\n\n  let invDet: f32 = 1. / det;\n  info.weights = vec3<f32>(0., u, v) * invDet;\n  info.weights.x = 1. - info.weights.y - info.weights.z;\n\n  info.hit = true;\n  info.t = lt * invDet;\n  info.hitPoint = ray.origin + ray.dir * info.t;\n  info.uv0 = u_uvs.value[indexes.x];\n  info.uv1 = u_uvs.value[indexes.y];\n  info.uv2 = u_uvs.value[indexes.z];\n  info.n0 = u_normals.value[indexes.x];\n  info.n1 = u_normals.value[indexes.y];\n  info.n2 = u_normals.value[indexes.z];\n  info.meshIndex = u_meshMatIndexes.value[indexes.x].x;\n  info.matIndex = u_meshMatIndexes.value[indexes.x].y;\n  let metallicRoughnessFactorNormalScaleMaterialType: vec4<f32> = material.u_metallicRoughnessFactorNormalScaleMaterialTypes[info.matIndex];\n  info.matType = u32(metallicRoughnessFactorNormalScaleMaterialType[3]);\n\n  return info;\n}\n\nfn leafHitTest(ray: Ray, offset: u32, ignoreGlass: bool) -> FragmentInfo {\n  var info: FragmentInfo;\n  info.t = MAX_RAY_LENGTH;\n  var leaf: BVHLeaf = getBVHLeafInfo(offset);\n  let primitives: u32 = leaf.primitives;\n  \n  for (var i: u32 = 0u; i < primitives; i = i + 1u) {\n    leaf = getBVHLeafInfo(offset + i);\n    let cInfo: FragmentInfo = triangleHitTest(ray, leaf);\n\n    if (ignoreGlass && isMatGlass(cInfo.matType)) {\n      continue;\n    }\n\n    if (cInfo.hit && cInfo.t < info.t) {\n      info = cInfo;\n    }\n  }\n\n  return info;\n}\n\nfn fillHitPoint(frag: FragmentInfo, ray: Ray) -> HitPoint {\n  var info: HitPoint;\n\n  info.hit = true;\n  info.hited = frag.t;\n  info.meshIndex = frag.meshIndex;\n  info.matIndex = frag.matIndex;\n  let metallicRoughnessFactorNormalScaleMaterialType: vec4<f32> = material.u_metallicRoughnessFactorNormalScaleMaterialTypes[frag.matIndex];\n  info.position = frag.p0 * frag.weights[0] + frag.p1 * frag.weights[1] + frag.p2 * frag.weights[2];\n  let uv: vec2<f32> = frag.uv0 * frag.weights[0] + frag.uv1 * frag.weights[1] + frag.uv2 * frag.weights[2];\n  let textureIds: vec4<i32> = material.u_matId2TexturesId[frag.matIndex];  \n  let faceNormal: vec3<f32> = getFaceNormal(frag);\n  info.sign = sign(dot(faceNormal, -ray.dir));\n  info.normal = info.sign * getNormal(frag, uv, textureIds[1], metallicRoughnessFactorNormalScaleMaterialType[2]);\n  let baseColor: vec4<f32> = getBaseColor(material.u_baseColorFactors[frag.matIndex], textureIds[0], uv);\n  info.baseColor = baseColor.rgb;\n  info.glass = baseColor.a;\n  info.matType = frag.matType;\n  info.isSpecGloss = isMatSpecGloss(frag.matType);\n  info.isGlass = isMatGlass(frag.matType);\n\n  if (info.isSpecGloss) {\n    let specularGlossinessFactors: vec4<f32> = material.u_specularGlossinessFactors[frag.matIndex];\n    info.spec = getSpecular(specularGlossinessFactors.xyz, textureIds[2], uv).rgb;\n    info.gloss = getGlossiness(specularGlossinessFactors[3], textureIds[2], uv);\n  } else {\n    info.metal = getMetallic(metallicRoughnessFactorNormalScaleMaterialType[0], textureIds[2], uv);\n    info.rough = getRoughness(metallicRoughnessFactorNormalScaleMaterialType[1], textureIds[2], uv);\n  }\n\n  info.pbrData = pbrPrepareData(info.isSpecGloss, info.baseColor, info.metal, info.rough, info.spec, info.gloss);\n\n  return info;\n}\n\nfn hitTest(ray: Ray) -> HitPoint {\n  var hit: HitPoint;\n  var fragInfo: FragmentInfo;\n  fragInfo.t = MAX_RAY_LENGTH;\n  var node: BVHNode;\n  var nodeStack: array<u32, ${BVH_DEPTH}>;\n  nodeStack[0] = 0u;\n  var stackDepth: i32 = 0;\n  \n  loop {\n     if (stackDepth < 0) {\n       break;\n     }\n\n    let child = decodeChild(nodeStack[stackDepth]);\n    stackDepth = stackDepth - 1;\n\n    if (child.isLeaf) {\n      let info: FragmentInfo = leafHitTest(ray, child.offset, false);\n\n      if (info.hit && info.t < fragInfo.t) {\n        fragInfo = info;\n      }\n\n      continue;\n    }\n\n    node = getBVHNodeInfo(child.offset);\n    let hited: f32 = boxHitTest(ray, node.max, node.min);\n\n    // if ray.origin is in bvh box, the minT may be less than zero, hited will be maxT\n    // if (hited < 0. || hited > fragInfo.t) {\n    if (hited < 0.) {\n      continue;\n    }\n\n    stackDepth = stackDepth + 1;\n    nodeStack[stackDepth] = node.child0Index;\n    stackDepth = stackDepth + 1;\n    nodeStack[stackDepth] = node.child1Index;\n  }\n\n  if (fragInfo.hit) {\n    hit = fillHitPoint(fragInfo, ray);\n  }\n\n  return hit;\n}\n\nfn hitTestShadow(ray: Ray, maxT: f32) -> FragmentInfo {\n  var fragInfo: FragmentInfo;\n  var node: BVHNode;\n  var nodeStack: array<u32, ${BVH_DEPTH}>;\n  nodeStack[0] = 0u;\n  var stackDepth: i32 = 0;\n  \n  loop {\n     if (stackDepth < 0) {\n       break;\n     }\n\n    let child = decodeChild(nodeStack[stackDepth]);\n    stackDepth = stackDepth - 1;\n\n    if (child.isLeaf) {\n      let info: FragmentInfo = leafHitTest(ray, child.offset, true);\n\n      if (info.hit && info.t < maxT && info.t > EPS) {\n        return info;\n      }\n\n      continue;\n    }\n\n    node = getBVHNodeInfo(child.offset);\n    let hited: f32 = boxHitTest(ray, node.max, node.min);\n\n    if (hited < 0.) {\n      continue;\n    }\n\n    stackDepth = stackDepth + 1;\n    nodeStack[stackDepth] = node.child0Index;\n    stackDepth = stackDepth + 1;\n    nodeStack[stackDepth] = node.child1Index;\n  }\n\n  return fragInfo;\n}\n\nfn hitTestXZPlane(ray: Ray, inverseMat: mat4x4<f32>) -> vec3<f32> {\n  let invDir: vec3<f32> = normalize((inverseMat * vec4<f32>(ray.dir, 0.)).xyz);\n  let normal: vec3<f32> = vec3<f32>(0., 0., 1.);\n  let dot: f32 = dot(invDir, normal);\n\n  if (abs(dot) < EPS) {\n    return vec3<f32>(MAX_RAY_LENGTH, MAX_RAY_LENGTH, MAX_RAY_LENGTH);\n  }\n  \n  let invOrigin: vec3<f32> = (inverseMat * vec4<f32>(ray.origin, 1.)).xyz;\n  let t: f32 = dot(-invOrigin, normal) / dot;\n\n  if (t < EPS) {\n    return vec3<f32>(MAX_RAY_LENGTH, MAX_RAY_LENGTH, MAX_RAY_LENGTH);\n  }\n\n  return vec3<f32>(invOrigin.xy + t * invDir.xy, t);\n}\n\nfn hitTestLights(ray: Ray) -> vec4<f32> {\n  let areaLight: LightInfo = global.u_lightInfos[0];\n  var res: vec4<f32> = vec4<f32>(areaLight.color.rgb, MAX_RAY_LENGTH);\n  // only support one area light now\n  if (areaLight.lightType != LIGHT_TYPE_AREA) {\n    return res;\n  }\n\n  let xyt: vec3<f32> = hitTestXZPlane(ray, areaLight.worldTransformInverse);\n\n  var hit: bool = false;\n  if (areaLight.areaMode == LIGHT_AREA_DISC) {\n    hit = length(xyt.xy) < areaLight.areaSize.x;\n  } else {\n    hit = all(abs(xyt.xy) < areaLight.areaSize / 2.);\n  }\n\n  if (hit) {\n    res.a = xyt.z;\n  }\n\n  return res;\n}\n\n//require end\n;\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/sample.chunk.wgsl\n\nfn getDiffuseProb(hit: HitPoint) -> f32 {\n  let lumDiffuse: f32 = max(.01, dot(hit.pbrData.diffuseColor, vec3<f32>(0.2125, 0.7154, 0.0721)));\n  let lumSpecular: f32 = max(.01, dot(hit.pbrData.specularColor, vec3<f32>(0.2125, 0.7154, 0.0721)));\n\n  return lumDiffuse / (lumDiffuse + lumSpecular);\n}\n\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nfn orthonormalBasis(normal: vec3<f32>) -> mat3x3<f32> {\n  // sign function return 0 if x is 0\n  // let zsign: f32 = sign(normal.z) * 1.;\n  var zsign: f32 = 1.;\n  if (normal.z < 0.) {\n    zsign = -1.;\n  }\n  let a: f32 = -1.0 / (zsign + normal.z);\n  let b: f32 = normal.x * normal.y * a;\n  let s: vec3<f32> = vec3<f32>(1.0 + zsign * normal.x * normal.x * a, zsign * b, -zsign * normal.x);\n  let t: vec3<f32> = vec3<f32>(b, zsign + normal.y * normal.y * a, -normal.y);\n\n  return mat3x3<f32>(s, t, normal);\n}\n\n// http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#SamplingaUnitDisk\nfn sampleCircle(pi: vec2<f32>) -> vec2<f32> {\n  let p: vec2<f32> = 2.0 * pi - 1.0;\n  let greater: bool = abs(p.x) > abs(p.y);\n  var r: f32;\n  var theta: f32;\n\n  if (greater) {\n    r = p.x;\n    theta = 0.25 * PI * p.y / p.x;\n  } else {\n    r = p.y;\n    theta = PI * (0.5 - 0.25 * p.x / p.y);\n  }\n\n  return r * vec2<f32>(cos(theta), sin(theta));\n}\n\nfn fresnelSchlickWeight(cosTheta: f32) -> f32 {\n  let w: f32 = 1.0 - cosTheta;\n\n  return (w * w) * (w * w) * w;\n}\n\nfn fresnelSchlickTIR(cosTheta: f32, r0: f32, ni: f32) -> f32 {\n  // moving from a more dense to a less dense medium\n  var cos: f32 = cosTheta;\n  if (cosTheta < 0.0) {\n    let inv_eta: f32 = ni;\n    let SinT2: f32 = inv_eta * inv_eta * (1.0 - cosTheta * cosTheta);\n    if (SinT2 > 1.0) {\n      return 1.0; // total internal reflection\n    }\n\n    cos = sqrt(1. - SinT2);\n  }\n\n  return mix(fresnelSchlickWeight(cos), 1.0, r0);\n}\n\n// http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling\nfn cosineSampleHemisphere(p: vec2<f32>) -> vec3<f32> {\n  let h: vec2<f32> = sampleCircle(p);\n  let z: f32 = sqrt(max(0.0, 1.0 - h.x * h.x - h.y * h.y));\n\n  return vec3<f32>(h, z);\n}\n\nfn calcDiffuseLightDir(basis: mat3x3<f32>, sign: f32, random: vec2<f32>) -> vec3<f32> {\n  return basis * sign * cosineSampleHemisphere(random);\n}\n\n// GGX distrubtion\nfn calcSpecularLightDir(basis: mat3x3<f32>, ray: Ray, hit: HitPoint, random: vec2<f32>) -> vec3<f32> {\n  let phi: f32 = PI * 2. * random.x;\n  let alpha: f32 = hit.pbrData.alphaRoughness;\n  let cosTheta: f32 = sqrt((1.0 - random.y) / (1.0 + (alpha * alpha - 1.0) * random.y));\n  let sinTheta: f32 = sqrt(1.0 - cosTheta * cosTheta);\n  let halfVector: vec3<f32> = basis * hit.sign * vec3<f32>(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\n  return reflect(ray.dir, halfVector);\n}\n\nfn calcBrdfDir(ray: Ray, hit: HitPoint, isDiffuse: bool, random: vec2<f32>) -> vec3<f32> {\n  let basis: mat3x3<f32> = orthonormalBasis(hit.normal);\n\n  if (isDiffuse) {\n    return calcDiffuseLightDir(basis, hit.sign, random);\n  }\n\n  return calcSpecularLightDir(basis, ray, hit, random);\n}\n\nstruct BSDFDirRes {\n  dir: vec3<f32>;\n  isBTDF: bool;\n};\n\n// dir and (0. is brdf, 1. is btdf)\n// we suppose all glass are thick glass\nfn calcBsdfDir(ray: Ray, hit: HitPoint, reflectProbability: f32) -> BSDFDirRes {\n  let nAir: f32 = 1.;\n  let nGlass: f32 = 1. / hit.glass;\n  var ior: f32 = nGlass; // backface, nGlass / nAir\n  var res: BSDFDirRes;\n\n  if (hit.sign > 0.) {\n    ior = hit.glass; // nAir / nGlass\n  }\n\n  let cosTheta: f32 = dot(hit.normal, -ray.dir);\n  var r0: f32 = (nAir - nGlass) / (nAir + nGlass);\n  r0 = r0 * r0;\n  let F: f32 = fresnelSchlickTIR(cosTheta, r0, ior);\n\n  //@todo: if backface and not full reflection, force refraction\n  if (F > reflectProbability) {\n    res.dir = reflect(ray.dir, hit.normal);\n    res.isBTDF = false;\n  } else {\n    res.dir = refract(ray.dir, hit.normal, ior);\n    res.isBTDF = true;\n  }\n\n  return res;\n}\n\n//require end\n;\n//from require /mnt/h/ComplexMind/ray-tracing-webgpu/src/buildin/shaders/ray-tracing/lighting.chunk.wgsl\nfn calcBrdfDirectOrSpecular(\n  pbr: PBRData, normal: vec3<f32>,\n  viewDir: vec3<f32>, lightDir: vec3<f32>,\n  isDirect: bool, probDiffuse: f32\n)-> vec3<f32> {\n  let H: vec3<f32> = normalize(lightDir + viewDir);\n  let NdotV: f32 = clamp(abs(dot(normal, viewDir)), 0.001, 1.0);\n  let NdotL: f32 = clamp(abs(dot(normal, lightDir)), 0.001, 1.0);\n  let NdotH: f32 = clamp(abs(dot(normal, H)), 0.0, 1.0);\n  let LdotH: f32 = clamp(abs(dot(lightDir, H)), 0.0, 1.0);\n  let VdotH: f32 = clamp(dot(viewDir, H), 0.0, 1.0);\n  // Calculate the shading terms for the microfacet specular shading model\n  let F: vec3<f32> = pbrSpecularReflection(pbr.reflectance0, pbr.reflectance90, VdotH);\n  let G: f32 = pbrGeometricOcclusion(NdotL, NdotV, pbr.alphaRoughness);\n  let D: f32 = pbrMicrofacetDistribution(pbr.alphaRoughness, NdotH);\n\n  let specular: vec3<f32> = F * G * D / (4.0 * NdotL * NdotV);\n\n  if (isDirect) {\n    let diffuse: vec3<f32> = NdotL * 0.3183098861837907 * pbr.diffuseColor;\n    return specular + diffuse;\n  }\n\n  let specularPdf: f32 = D * NdotH / (4.0 * LdotH);\n  return NdotL * specular / (mix(specularPdf, 0., probDiffuse));\n}\n\nfn calcDirectColor(ray: Ray, hit: HitPoint, random: vec2<f32>) -> vec3<f32> {\n  // sample area lights, get radiance or shadow\n  let areaLight: LightInfo = global.u_lightInfos[0];\n\n  // only support one area light now\n  if (areaLight.lightType != LIGHT_TYPE_AREA) {\n    return vec3<f32>(0.);\n  }\n\n  var samplePoint2D: vec2<f32>;\n  let normal: vec3<f32> = normalize((areaLight.worldTransform * vec4<f32>(0., 0., -1., 0.)).xyz);\n  var area: f32;\n  if (areaLight.areaMode == LIGHT_AREA_DISC) {\n    samplePoint2D = sampleCircle(random) * areaLight.areaSize.x;\n    area = 2. * PI * areaLight.areaSize.x;\n  } else {\n    samplePoint2D = (random) * areaLight.areaSize;\n    area = samplePoint2D.x * samplePoint2D.y;\n    samplePoint2D = samplePoint2D * 2. - areaLight.areaSize;\n  }\n\n  let samplePoint: vec4<f32> = areaLight.worldTransform * vec4<f32>(samplePoint2D.x, samplePoint2D.y, 0., 1.);\n  var sampleDir: vec3<f32> = samplePoint.xyz - hit.position;\n\n  let cosine: f32 = dot(normal, sampleDir);\n  if (cosine > 0.) {\n    // backface\n    return vec3<f32>(0.);\n  }\n\n  let maxT: f32 = length(sampleDir);\n  sampleDir = normalize(sampleDir);\n  let sampleLight: Ray = genRay(hit.position + RAY_DIR_OFFSET * sampleDir + RAY_NORMAL_OFFSET * hit.normal, sampleDir);\n  let shadowInfo: FragmentInfo = hitTestShadow(sampleLight, maxT);\n\n  if (shadowInfo.hit) {\n    return vec3<f32>(0.);\n  }\n\n  let pdf: f32 = maxT * maxT / (area * -cosine);\n  let directLight: vec3<f32> = areaLight.color.rgb / pdf;\n  let brdf = calcBrdfDirectOrSpecular(hit.pbrData, hit.normal, -ray.dir, sampleDir, true, 0.);\n\n  return directLight * brdf;\n}\n\nfn calcDiffuseFactor(ray: Ray, hit: HitPoint, nextDir: vec3<f32>, probDiffuse: f32) -> vec3<f32> {\n  // let diffusePdf: f32 = NdotL * 0.3183098861837907;\n  return hit.pbrData.diffuseColor / probDiffuse;\n}\n\nfn calcSpecularFactor(ray: Ray, hit: HitPoint, nextDir: vec3<f32>, probDiffuse: f32) -> vec3<f32> {\n  return calcBrdfDirectOrSpecular(hit.pbrData, hit.normal, -ray.dir, nextDir.xyz, false, probDiffuse);\n}\n\nfn calcTransmissionFactor(ray: Ray, hit: HitPoint, nextDir: vec3<f32>) -> vec3<f32> {\n  return hit.baseColor;\n}\n\nfn calcOutColor(ray: Ray, hit: HitPoint) -> vec3<f32> {\n  // rgbd\n  let bgColor: vec4<f32> = textureSampleLevel(u_envTexture, u_sampler, ray.dir, 0.);\n  return bgColor.rgb / bgColor.a * global.u_envColor.rgb;\n}\n\n//require end\n;\n\nfn calcLight(ray: Ray, hit: HitPoint, baseUV: vec2<f32>, bounce: i32, isLast: bool, isOut: bool, debugIndex: i32) -> Light {\n  var light: Light;\n  let random = getRandom(baseUV, bounce);\n\n  if (isOut) {\n    // rgbd\n    light.color = calcOutColor(ray, hit);\n    return light;\n  }\n\n  var nextDir: vec3<f32>;\n  var isBTDF: bool = false;\n  if (hit.isGlass) {\n    // bsdf\n    if (isLast) {\n      return light;\n    }\n    \n    let next: BSDFDirRes = calcBsdfDir(ray, hit, random.x);\n    nextDir = next.dir;\n    isBTDF = next.isBTDF;\n\n    if (isBTDF) {\n      light.throughEng = calcTransmissionFactor(ray, hit, nextDir.xyz);\n    } else {\n      light.throughEng = calcSpecularFactor(ray, hit, nextDir.xyz, 0.);\n    }\n  } else {\n    // brdf\n    light.color = calcDirectColor(ray, hit, random.zw);\n\n    if (isLast) {\n      return light;\n    }\n\n    let probDiffuse: f32 = getDiffuseProb(hit);\n    let isDiffuse: bool = random.z < probDiffuse;\n    nextDir = calcBrdfDir(ray, hit, isDiffuse, random.xy);\n\n    if (isDiffuse) {\n      light.throughEng = calcDiffuseFactor(ray, hit, nextDir.xyz, probDiffuse);\n    } else {\n      light.throughEng = calcSpecularFactor(ray, hit, nextDir.xyz, probDiffuse);\n    }\n  }\n\n  // avoid self intersection\n  if (isBTDF) {\n    // transmission\n    light.next = genRay(hit.position + light.next.dir * RAY_DIR_OFFSET - RAY_NORMAL_OFFSET * hit.normal, nextDir.xyz);\n  } else {\n    light.next = genRay(hit.position + light.next.dir * RAY_DIR_OFFSET + RAY_NORMAL_OFFSET * hit.normal, nextDir.xyz);\n  }\n\n  return light;\n}\n\nfn traceLight(startRay: Ray, gBInfo: HitPoint, baseUV: vec2<f32>, debugIndex: i32) -> vec3<f32> {\n  var light: Light = calcLight(startRay, gBInfo, baseUV, 0, false, false, debugIndex);\n  var lightColor: vec3<f32> = light.color;\n  var throughEng: vec3<f32> = light.throughEng;\n  var hit: HitPoint;\n  var ray: Ray = light.next;\n  var lightHited: vec4<f32>;\n  var bounce: i32 = 0;\n\n  loop {\n    let preIsGlass = hit.isGlass;\n    lightHited = hitTestLights(ray);\n    hit = hitTest(ray);\n    let isHitLight: bool = lightHited.a <= hit.hited;\n    let isOut: bool = !hit.hit || isHitLight;\n    // if hit none-glass material, finish tracing\n    let isLast: bool = !hit.isGlass;\n\n    if (preIsGlass && isHitLight) {\n      light.color = lightHited.rgb;\n    } else {\n      light = calcLight(ray, hit, baseUV, bounce, isLast, isOut, debugIndex);\n      ray = light.next;\n    }\n\n    lightColor = lightColor + light.color * throughEng;\n    throughEng = throughEng * light.throughEng;\n    bounce = bounce + 1;\n\n    if (max(throughEng.x, max(throughEng.y, throughEng.z)) < 0.01 || isOut) {\n      break;\n    }\n  }\n\n  // var hited: f32 = 0.;\n  // if (hit.hit) {\n  //   hited = 1.;\n  // }\n  // ray = startRay;\n  // hit = gBInfo;\n  // light = calcLight(ray, hit, baseUV, 0, false, false, debugIndex);\n  // u_debugInfo.rays[debugIndex].preOrigin = vec4<f32>(ray.origin, hit.sign);\n  // u_debugInfo.rays[debugIndex].preDir = vec4<f32>(ray.dir, f32(hit.matType));\n  // ray = light.next;\n  // hit = hitTest(ray);\n  // light = calcLight(ray, hit, baseUV, 1, false, false, debugIndex);\n  // u_debugInfo.rays[debugIndex].origin = vec4<f32>(ray.origin, hit.sign);\n  // u_debugInfo.rays[debugIndex].dir = vec4<f32>(ray.dir, f32(hit.matType));\n  // u_debugInfo.rays[debugIndex].normal = vec4<f32>(hit.normal, hit.glass);\n  // ray = light.next;\n  // hit = hitTest(ray);\n  // light = calcLight(ray, hit, baseUV, 2, false, false, debugIndex);\n  // u_debugInfo.rays[debugIndex].nextOrigin = vec4<f32>(ray.origin, hit.sign);\n  // u_debugInfo.rays[debugIndex].nextDir = vec4<f32>(ray.dir, f32(bounce));\n\n  return lightColor;\n}\n\n[[stage(compute), workgroup_size(16, 16, 1)]]\nfn main(\n  [[builtin(workgroup_id)]] workGroupID : vec3<u32>,\n  [[builtin(local_invocation_id)]] localInvocationID : vec3<u32>\n) {\n  let screenSize: vec2<i32> = textureDimensions(u_gbPositionMetalOrSpec, 0);\n  let groupOffset: vec2<i32> = vec2<i32>(workGroupID.xy) * 16;\n  let baseIndex: vec2<i32> = groupOffset + vec2<i32>(localInvocationID.xy);\n  let baseUV: vec2<f32> = vec2<f32>(baseIndex) / vec2<f32>(screenSize);\n  let gBInfo: HitPoint = getGBInfo(baseIndex);\n  let debugIndex: i32 = baseIndex.x + baseIndex.y * screenSize.x;\n\n  if (gBInfo.isLight) {\n    textureStore(u_output, baseIndex, vec4<f32>(gBInfo.baseColor, 1.));\n    return;\n  }\n\n  if (!gBInfo.hit) {\n    let t: vec4<f32> = global.u_skyVP * vec4<f32>(baseUV.x * 2. - 1., 1. - baseUV.y * 2., 1., 1.);\n    let cubeUV: vec3<f32> = normalize(t.xyz / t.w);\n    let bgColor: vec4<f32> = textureSampleLevel(u_envTexture, u_sampler, cubeUV, 0.);\n    // rgbd\n    textureStore(u_output, baseIndex, vec4<f32>(bgColor.rgb / bgColor.a * global.u_envColor.rgb, 1.));\n    return;\n  }\n\n  let worldRay: Ray = genWorldRayByGBuffer(baseUV, gBInfo);\n  let light: vec3<f32> = traceLight(worldRay, gBInfo, baseUV, debugIndex);\n  textureStore(u_output, baseIndex, vec4<f32>(light, 1.));\n}\n"

/***/ }),

/***/ "./node_modules/_ansi-html@0.0.7@ansi-html/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/_ansi-html@0.0.7@ansi-html/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/_ansi-regex@2.1.1@ansi-regex/index.js":
/*!************************************************************!*\
  !*** ./node_modules/_ansi-regex@2.1.1@ansi-regex/index.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./node_modules/_events@3.3.0@events/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/_events@3.3.0@events/events.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js":
/*!***************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "ARRAY_TYPE": () => (/* binding */ ARRAY_TYPE),
/* harmony export */   "RANDOM": () => (/* binding */ RANDOM),
/* harmony export */   "setMatrixArrayType": () => (/* binding */ setMatrixArrayType),
/* harmony export */   "toRadian": () => (/* binding */ toRadian),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "glMatrix": () => (/* reexport module object */ _common_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "mat2": () => (/* reexport module object */ _mat2_js__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   "mat2d": () => (/* reexport module object */ _mat2d_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   "mat3": () => (/* reexport module object */ _mat3_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   "mat4": () => (/* reexport module object */ _mat4_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "quat": () => (/* reexport module object */ _quat_js__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   "quat2": () => (/* reexport module object */ _quat2_js__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   "vec2": () => (/* reexport module object */ _vec2_js__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   "vec3": () => (/* reexport module object */ _vec3_js__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   "vec4": () => (/* reexport module object */ _vec4_js__WEBPACK_IMPORTED_MODULE_9__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2.js");
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2d.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat3.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat4.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat.js");
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat2.js");
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec2.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec4.js");












/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "LDU": () => (/* binding */ LDU),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2d.js":
/*!**************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat2d.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat3.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat3.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "fromMat4": () => (/* binding */ fromMat4),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromMat2d": () => (/* binding */ fromMat2d),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "normalFromMat4": () => (/* binding */ normalFromMat4),
/* harmony export */   "projection": () => (/* binding */ projection),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat4.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat4.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromXRotation": () => (/* binding */ fromXRotation),
/* harmony export */   "fromYRotation": () => (/* binding */ fromYRotation),
/* harmony export */   "fromZRotation": () => (/* binding */ fromZRotation),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromQuat2": () => (/* binding */ fromQuat2),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "getScaling": () => (/* binding */ getScaling),
/* harmony export */   "getRotation": () => (/* binding */ getRotation),
/* harmony export */   "fromRotationTranslationScale": () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   "fromRotationTranslationScaleOrigin": () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "frustum": () => (/* binding */ frustum),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "perspectiveFromFieldOfView": () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   "ortho": () => (/* binding */ ortho),
/* harmony export */   "lookAt": () => (/* binding */ lookAt),
/* harmony export */   "targetTo": () => (/* binding */ targetTo),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "setAxisAngle": () => (/* binding */ setAxisAngle),
/* harmony export */   "getAxisAngle": () => (/* binding */ getAxisAngle),
/* harmony export */   "getAngle": () => (/* binding */ getAngle),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "calculateW": () => (/* binding */ calculateW),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "ln": () => (/* binding */ ln),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "slerp": () => (/* binding */ slerp),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "conjugate": () => (/* binding */ conjugate),
/* harmony export */   "fromMat3": () => (/* binding */ fromMat3),
/* harmony export */   "fromEuler": () => (/* binding */ fromEuler),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "rotationTo": () => (/* binding */ rotationTo),
/* harmony export */   "sqlerp": () => (/* binding */ sqlerp),
/* harmony export */   "setAxes": () => (/* binding */ setAxes)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_3__.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat2.js":
/*!**************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "fromRotationTranslationValues": () => (/* binding */ fromRotationTranslationValues),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromMat4": () => (/* binding */ fromMat4),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "getReal": () => (/* binding */ getReal),
/* harmony export */   "getDual": () => (/* binding */ getDual),
/* harmony export */   "setReal": () => (/* binding */ setReal),
/* harmony export */   "setDual": () => (/* binding */ setDual),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "rotateByQuatAppend": () => (/* binding */ rotateByQuatAppend),
/* harmony export */   "rotateByQuatPrepend": () => (/* binding */ rotateByQuatPrepend),
/* harmony export */   "rotateAroundAxis": () => (/* binding */ rotateAroundAxis),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "conjugate": () => (/* binding */ conjugate),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__.create();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getRotation(outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec2.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec2.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat2": () => (/* binding */ transformMat2),
/* harmony export */   "transformMat2d": () => (/* binding */ transformMat2d),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec3.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec3.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "hermite": () => (/* binding */ hermite),
/* harmony export */   "bezier": () => (/* binding */ bezier),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec4.js":
/*!*************************************************************!*\
  !*** ./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/vec4.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js");
var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
var alphaIndex = {};
var numIndex = {};
(function () {
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
        var a = HTML_ALPHA[i];
        var c = HTML_CODES[i];
        alphaIndex[a] = String.fromCharCode(c);
        numIndex[c] = a;
        i++;
    }
})();
var Html4Entities = /** @class */ (function () {
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1).toLowerCase() === 'x' ?
                    parseInt(entity.substr(2), 16) :
                    parseInt(entity.substr(1));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        chr = String.fromCharCode(code);
                    }
                    else {
                        chr = surrogate_pairs_1.fromCodePoint(code);
                    }
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html4Entities.decode = function (str) {
        return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var alpha = numIndex[str.charCodeAt(i)];
            result += alpha ? "&" + alpha + ";" : str.charAt(i);
            i++;
        }
        return result;
    };
    Html4Entities.encode = function (str) {
        return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var cc = str.charCodeAt(i);
            var alpha = numIndex[cc];
            if (alpha) {
                result += "&" + alpha + ";";
            }
            else if (cc < 32 || cc > 126) {
                if (cc >= surrogate_pairs_1.highSurrogateFrom && cc <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + cc + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonUTF = function (str) {
        return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i++;
            }
            else {
                result += '&#' + c + ';';
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonASCII = function (str) {
        return new Html4Entities().encodeNonASCII(str);
    };
    return Html4Entities;
}());
exports.Html4Entities = Html4Entities;


/***/ }),

/***/ "./node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js");
var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
var DECODE_ONLY_ENTITIES = [['NewLine', [10]]];
var alphaIndex = {};
var charIndex = {};
createIndexes(alphaIndex, charIndex);
var Html5Entities = /** @class */ (function () {
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1) === 'x' ?
                    parseInt(entity.substr(2).toLowerCase(), 16) :
                    parseInt(entity.substr(1));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        chr = String.fromCharCode(code);
                    }
                    else {
                        chr = surrogate_pairs_1.fromCodePoint(code);
                    }
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html5Entities.decode = function (str) {
        return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var charInfo = charIndex[str.charCodeAt(i)];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            result += str.charAt(i);
            i++;
        }
        return result;
    };
    Html5Entities.encode = function (str) {
        return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var charInfo = charIndex[c];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            if (c < 32 || c > 126) {
                if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + c + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonUTF = function (str) {
        return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i += 2;
            }
            else {
                result += '&#' + c + ';';
                i++;
            }
        }
        return result;
    };
    Html5Entities.encodeNonASCII = function (str) {
        return new Html5Entities().encodeNonASCII(str);
    };
    return Html5Entities;
}());
exports.Html5Entities = Html5Entities;
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    while (i--) {
        var _a = ENTITIES[i], alpha = _a[0], _b = _a[1], chr = _b[0], chr2 = _b[1];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo = void 0;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chr2) {
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            addChar && (charInfo[chr2] = alpha);
        }
        else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            addChar && (charInfo[''] = alpha);
        }
    }
    i = DECODE_ONLY_ENTITIES.length;
    while (i--) {
        var _c = DECODE_ONLY_ENTITIES[i], alpha = _c[0], _d = _c[1], chr = _d[0], chr2 = _d[1];
        alphaIndex[alpha] = String.fromCharCode(chr) + (chr2 ? String.fromCharCode(chr2) : '');
    }
}


/***/ }),

/***/ "./node_modules/_html-entities@1.4.0@html-entities/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var xml_entities_1 = __webpack_require__(/*! ./xml-entities */ "./node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js");
exports.XmlEntities = xml_entities_1.XmlEntities;
var html4_entities_1 = __webpack_require__(/*! ./html4-entities */ "./node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js");
exports.Html4Entities = html4_entities_1.Html4Entities;
var html5_entities_1 = __webpack_require__(/*! ./html5-entities */ "./node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js");
exports.Html5Entities = html5_entities_1.Html5Entities;
exports.AllHtmlEntities = html5_entities_1.Html5Entities;


/***/ }),

/***/ "./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js":
/*!********************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xD800, (astralCodePoint - 0x10000) % 0x400 + 0xDC00);
};
exports.getCodePoint = String.prototype.codePointAt ?
    function (input, position) {
        return input.codePointAt(position);
    } :
    function (input, position) {
        return (input.charCodeAt(position) - 0xD800) * 0x400
            + input.charCodeAt(position + 1) - 0xDC00 + 0x10000;
    };
exports.highSurrogateFrom = 0xD800;
exports.highSurrogateTo = 0xDBFF;


/***/ }),

/***/ "./node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js");
var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};
var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};
var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};
var XmlEntities = /** @class */ (function () {
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/[<>"'&]/g, function (s) {
            return CHAR_S_INDEX[s];
        });
    };
    XmlEntities.encode = function (str) {
        return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
            if (s.charAt(1) === '#') {
                var code = s.charAt(2).toLowerCase() === 'x' ?
                    parseInt(s.substr(3), 16) :
                    parseInt(s.substr(2));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        return String.fromCharCode(code);
                    }
                    else {
                        return surrogate_pairs_1.fromCodePoint(code);
                    }
                }
                return '';
            }
            return ALPHA_INDEX[s] || s;
        });
    };
    XmlEntities.decode = function (str) {
        return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var alpha = CHAR_INDEX[c];
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
            if (c < 32 || c > 126) {
                if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + c + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonUTF = function (str) {
        return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i++;
            }
            else {
                result += '&#' + c + ';';
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonASCII = function (str) {
        return new XmlEntities().encodeNonASCII(str);
    };
    return XmlEntities;
}());
exports.XmlEntities = XmlEntities;


/***/ }),

/***/ "./node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js":
/*!***************************************************************!*\
  !*** ./node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/_punycode@1.3.2@punycode/punycode.js":
/*!***********************************************************!*\
  !*** ./node_modules/_punycode@1.3.2@punycode/punycode.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/_querystring@0.2.0@querystring/decode.js":
/*!***************************************************************!*\
  !*** ./node_modules/_querystring@0.2.0@querystring/decode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/_querystring@0.2.0@querystring/encode.js":
/*!***************************************************************!*\
  !*** ./node_modules/_querystring@0.2.0@querystring/encode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "./node_modules/_querystring@0.2.0@querystring/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/_querystring@0.2.0@querystring/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/_querystring@0.2.0@querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/_querystring@0.2.0@querystring/encode.js");


/***/ }),

/***/ "./node_modules/_select-pure@2.1.1-alpha.1@select-pure/dist/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_select-pure@2.1.1-alpha.1@select-pure/dist/index.js ***!
  \***************************************************************************/
/***/ (() => {

function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function e(e,i,s){var o=s.value;if("function"!=typeof o)throw new TypeError("@boundMethod decorator can only be applied to methods not: ".concat(t(o)));var n=!1;return{configurable:!0,get:function(){if(n||this===e.prototype||this.hasOwnProperty(i)||"function"!=typeof o)return o;var t=o.bind(this);return n=!0,Object.defineProperty(this,i,{configurable:!0,get:function(){return t},set:function(t){o=t,delete this[i]}}),n=!1,t},set:function(t){o=t}}}var i,s,o,n;const l=globalThis.trustedTypes,r=l?l.createPolicy("lit-html",{createHTML:t=>t}):void 0,a=`lit$${(Math.random()+"").slice(9)}$`,d="?"+a,h=`<${d}>`,c=document,p=(t="")=>c.createComment(t),u=t=>null===t||"object"!=typeof t&&"function"!=typeof t,v=Array.isArray,f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,b=/-->/g,y=/>/g,g=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,m=/'/g,S=/"/g,x=/^(?:script|style|textarea)$/i,w=(t=>(e,...i)=>({_$litType$:t,strings:e,values:i}))(1),O=Symbol.for("lit-noChange"),k=Symbol.for("lit-nothing"),C=new WeakMap,$=c.createTreeWalker(c,129,null,!1);class P{constructor({strings:t,_$litType$:e},i){let s;this.parts=[];let o=0,n=0;const c=t.length-1,u=this.parts,[v,w]=((t,e)=>{const i=t.length-1,s=[];let o,n=2===e?"<svg>":"",l=f;for(let e=0;e<i;e++){const i=t[e];let r,d,c=-1,p=0;for(;p<i.length&&(l.lastIndex=p,d=l.exec(i),null!==d);)p=l.lastIndex,l===f?"!--"===d[1]?l=b:void 0!==d[1]?l=y:void 0!==d[2]?(x.test(d[2])&&(o=RegExp("</"+d[2],"g")),l=g):void 0!==d[3]&&(l=g):l===g?">"===d[0]?(l=null!=o?o:f,c=-1):void 0===d[1]?c=-2:(c=l.lastIndex-d[2].length,r=d[1],l=void 0===d[3]?g:'"'===d[3]?S:m):l===S||l===m?l=g:l===b||l===y?l=f:(l=g,o=void 0);const u=l===g&&t[e+1].startsWith("/>")?" ":"";n+=l===f?i+h:c>=0?(s.push(r),i.slice(0,c)+"$lit$"+i.slice(c)+a+u):i+a+(-2===c?(s.push(void 0),e):u)}const d=n+(t[i]||"<?>")+(2===e?"</svg>":"");return[void 0!==r?r.createHTML(d):d,s]})(t,e);if(this.el=P.createElement(v,i),$.currentNode=this.el.content,2===e){const t=this.el.content,e=t.firstChild;e.remove(),t.append(...e.childNodes)}for(;null!==(s=$.nextNode())&&u.length<c;){if(1===s.nodeType){if(s.hasAttributes()){const t=[];for(const e of s.getAttributeNames())if(e.endsWith("$lit$")||e.startsWith(a)){const i=w[n++];if(t.push(e),void 0!==i){const t=s.getAttribute(i.toLowerCase()+"$lit$").split(a),e=/([.?@])?(.*)/.exec(i);u.push({type:1,index:o,name:e[2],strings:t,ctor:"."===e[1]?R:"?"===e[1]?N:"@"===e[1]?L:I})}else u.push({type:6,index:o})}for(const e of t)s.removeAttribute(e)}if(x.test(s.tagName)){const t=s.textContent.split(a),e=t.length-1;if(e>0){s.textContent=l?l.emptyScript:"";for(let i=0;i<e;i++)s.append(t[i],p()),$.nextNode(),u.push({type:2,index:++o});s.append(t[e],p())}}}else if(8===s.nodeType)if(s.data===d)u.push({type:2,index:o});else{let t=-1;for(;-1!==(t=s.data.indexOf(a,t+1));)u.push({type:7,index:o}),t+=a.length-1}o++}}static createElement(t,e){const i=c.createElement("template");return i.innerHTML=t,i}}function E(t,e,i=t,s){var o,n,l,r;if(e===O)return e;let a=void 0!==s?null===(o=i.i)||void 0===o?void 0:o[s]:i.o;const d=u(e)?void 0:e._$litDirective$;return(null==a?void 0:a.constructor)!==d&&(null===(n=null==a?void 0:a.O)||void 0===n||n.call(a,!1),void 0===d?a=void 0:(a=new d(t),a.T(t,i,s)),void 0!==s?(null!==(l=(r=i).i)&&void 0!==l?l:r.i=[])[s]=a:i.o=a),void 0!==a&&(e=E(t,a.S(t,e.values),a,s)),e}class H{constructor(t,e){this.l=[],this.N=void 0,this.D=t,this.M=e}u(t){var e;const{el:{content:i},parts:s}=this.D,o=(null!==(e=null==t?void 0:t.creationScope)&&void 0!==e?e:c).importNode(i,!0);$.currentNode=o;let n=$.nextNode(),l=0,r=0,a=s[0];for(;void 0!==a;){if(l===a.index){let e;2===a.type?e=new A(n,n.nextSibling,this,t):1===a.type?e=new a.ctor(n,a.name,a.strings,this,t):6===a.type&&(e=new U(n,this,t)),this.l.push(e),a=s[++r]}l!==(null==a?void 0:a.index)&&(n=$.nextNode(),l++)}return o}v(t){let e=0;for(const i of this.l)void 0!==i&&(void 0!==i.strings?(i.I(t,i,e),e+=i.strings.length-2):i.I(t[e])),e++}}class A{constructor(t,e,i,s){this.type=2,this.N=void 0,this.A=t,this.B=e,this.M=i,this.options=s}setConnected(t){var e;null===(e=this.P)||void 0===e||e.call(this,t)}get parentNode(){return this.A.parentNode}get startNode(){return this.A}get endNode(){return this.B}I(t,e=this){t=E(this,t,e),u(t)?t===k||null==t||""===t?(this.H!==k&&this.R(),this.H=k):t!==this.H&&t!==O&&this.m(t):void 0!==t._$litType$?this._(t):void 0!==t.nodeType?this.$(t):(t=>{var e;return v(t)||"function"==typeof(null===(e=t)||void 0===e?void 0:e[Symbol.iterator])})(t)?this.g(t):this.m(t)}k(t,e=this.B){return this.A.parentNode.insertBefore(t,e)}$(t){this.H!==t&&(this.R(),this.H=this.k(t))}m(t){const e=this.A.nextSibling;null!==e&&3===e.nodeType&&(null===this.B?null===e.nextSibling:e===this.B.previousSibling)?e.data=t:this.$(c.createTextNode(t)),this.H=t}_(t){var e;const{values:i,_$litType$:s}=t,o="number"==typeof s?this.C(t):(void 0===s.el&&(s.el=P.createElement(s.h,this.options)),s);if((null===(e=this.H)||void 0===e?void 0:e.D)===o)this.H.v(i);else{const t=new H(o,this),e=t.u(this.options);t.v(i),this.$(e),this.H=t}}C(t){let e=C.get(t.strings);return void 0===e&&C.set(t.strings,e=new P(t)),e}g(t){v(this.H)||(this.H=[],this.R());const e=this.H;let i,s=0;for(const o of t)s===e.length?e.push(i=new A(this.k(p()),this.k(p()),this,this.options)):i=e[s],i.I(o),s++;s<e.length&&(this.R(i&&i.B.nextSibling,s),e.length=s)}R(t=this.A.nextSibling,e){var i;for(null===(i=this.P)||void 0===i||i.call(this,!1,!0,e);t&&t!==this.B;){const e=t.nextSibling;t.remove(),t=e}}}class I{constructor(t,e,i,s,o){this.type=1,this.H=k,this.N=void 0,this.V=void 0,this.element=t,this.name=e,this.M=s,this.options=o,i.length>2||""!==i[0]||""!==i[1]?(this.H=Array(i.length-1).fill(k),this.strings=i):this.H=k}get tagName(){return this.element.tagName}I(t,e=this,i,s){const o=this.strings;let n=!1;if(void 0===o)t=E(this,t,e,0),n=!u(t)||t!==this.H&&t!==O,n&&(this.H=t);else{const s=t;let l,r;for(t=o[0],l=0;l<o.length-1;l++)r=E(this,s[i+l],e,l),r===O&&(r=this.H[l]),n||(n=!u(r)||r!==this.H[l]),r===k?t=k:t!==k&&(t+=(null!=r?r:"")+o[l+1]),this.H[l]=r}n&&!s&&this.W(t)}W(t){t===k?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"")}}class R extends I{constructor(){super(...arguments),this.type=3}W(t){this.element[this.name]=t===k?void 0:t}}class N extends I{constructor(){super(...arguments),this.type=4}W(t){t&&t!==k?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)}}class L extends I{constructor(){super(...arguments),this.type=5}I(t,e=this){var i;if((t=null!==(i=E(this,t,e,0))&&void 0!==i?i:k)===O)return;const s=this.H,o=t===k&&s!==k||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,n=t!==k&&(s===k||o);o&&this.element.removeEventListener(this.name,this,s),n&&this.element.addEventListener(this.name,this,t),this.H=t}handleEvent(t){var e,i;"function"==typeof this.H?this.H.call(null!==(i=null===(e=this.options)||void 0===e?void 0:e.host)&&void 0!==i?i:this.element,t):this.H.handleEvent(t)}}class U{constructor(t,e,i){this.element=t,this.type=6,this.N=void 0,this.V=void 0,this.M=e,this.options=i}I(t){E(this,t)}}null===(s=(i=globalThis).litHtmlPlatformSupport)||void 0===s||s.call(i,P,A),(null!==(o=(n=globalThis).litHtmlVersions)&&void 0!==o?o:n.litHtmlVersions=[]).push("2.0.0-rc.3");const z=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,M=Symbol();class T{constructor(t,e){if(e!==M)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t}get styleSheet(){return z&&void 0===this.t&&(this.t=new CSSStyleSheet,this.t.replaceSync(this.cssText)),this.t}toString(){return this.cssText}}const V=new Map,_=t=>{let e=V.get(t);return void 0===e&&V.set(t,e=new T(t,M)),e},D=(t,...e)=>{const i=1===t.length?t[0]:e.reduce(((e,i,s)=>e+(t=>{if(t instanceof T)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(i)+t[s+1]),t[0]);return _(i)},j=(t,e)=>{z?t.adoptedStyleSheets=e.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):e.forEach((e=>{const i=document.createElement("style");i.textContent=e.cssText,t.appendChild(i)}))},B=z?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const i of t.cssRules)e+=i.cssText;return(t=>_("string"==typeof t?t:t+""))(e)})(t):t;var q,W,K,F;const J={toAttribute(t,e){switch(e){case Boolean:t=t?"":null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,e){let i=t;switch(e){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t)}catch(t){i=null}}return i}},Z=(t,e)=>e!==t&&(e==e||t==t),G={attribute:!0,type:String,converter:J,reflect:!1,hasChanged:Z};class Q extends HTMLElement{constructor(){super(),this.i=new Map,this.o=void 0,this.l=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this.h=null,this.u()}static addInitializer(t){var e;null!==(e=this.v)&&void 0!==e||(this.v=[]),this.v.push(t)}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((e,i)=>{const s=this.p(i,e);void 0!==s&&(this.m.set(s,i),t.push(s))})),t}static createProperty(t,e=G){if(e.state&&(e.attribute=!1),this.finalize(),this.elementProperties.set(t,e),!e.noAccessor&&!this.prototype.hasOwnProperty(t)){const i="symbol"==typeof t?Symbol():"__"+t,s=this.getPropertyDescriptor(t,i,e);void 0!==s&&Object.defineProperty(this.prototype,t,s)}}static getPropertyDescriptor(t,e,i){return{get(){return this[e]},set(s){const o=this[t];this[e]=s,this.requestUpdate(t,o,i)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||G}static finalize(){if(this.hasOwnProperty("finalized"))return!1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this.m=new Map,this.hasOwnProperty("properties")){const t=this.properties,e=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const i of e)this.createProperty(i,t[i])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(t){const e=[];if(Array.isArray(t)){const i=new Set(t.flat(1/0).reverse());for(const t of i)e.unshift(B(t))}else void 0!==t&&e.push(B(t));return e}static"p"(t,e){const i=e.attribute;return!1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}u(){var t;this.g=new Promise((t=>this.enableUpdating=t)),this.L=new Map,this._(),this.requestUpdate(),null===(t=this.constructor.v)||void 0===t||t.forEach((t=>t(this)))}addController(t){var e,i;(null!==(e=this.U)&&void 0!==e?e:this.U=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(i=t.hostConnected)||void 0===i||i.call(t))}removeController(t){var e;null===(e=this.U)||void 0===e||e.splice(this.U.indexOf(t)>>>0,1)}"_"(){this.constructor.elementProperties.forEach(((t,e)=>{this.hasOwnProperty(e)&&(this.i.set(e,this[e]),delete this[e])}))}createRenderRoot(){var t;const e=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return j(e,this.constructor.elementStyles),e}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this.U)||void 0===t||t.forEach((t=>{var e;return null===(e=t.hostConnected)||void 0===e?void 0:e.call(t)})),this.l&&(this.l(),this.o=this.l=void 0)}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this.U)||void 0===t||t.forEach((t=>{var e;return null===(e=t.hostDisconnected)||void 0===e?void 0:e.call(t)})),this.o=new Promise((t=>this.l=t))}attributeChangedCallback(t,e,i){this.K(t,i)}"j"(t,e,i=G){var s,o;const n=this.constructor.p(t,i);if(void 0!==n&&!0===i.reflect){const l=(null!==(o=null===(s=i.converter)||void 0===s?void 0:s.toAttribute)&&void 0!==o?o:J.toAttribute)(e,i.type);this.h=t,null==l?this.removeAttribute(n):this.setAttribute(n,l),this.h=null}}K(t,e){var i,s,o;const n=this.constructor,l=n.m.get(t);if(void 0!==l&&this.h!==l){const t=n.getPropertyOptions(l),r=t.converter,a=null!==(o=null!==(s=null===(i=r)||void 0===i?void 0:i.fromAttribute)&&void 0!==s?s:"function"==typeof r?r:null)&&void 0!==o?o:J.fromAttribute;this.h=l,this[l]=a(e,t.type),this.h=null}}requestUpdate(t,e,i){let s=!0;void 0!==t&&(((i=i||this.constructor.getPropertyOptions(t)).hasChanged||Z)(this[t],e)?(this.L.has(t)||this.L.set(t,e),!0===i.reflect&&this.h!==t&&(void 0===this.k&&(this.k=new Map),this.k.set(t,i))):s=!1),!this.isUpdatePending&&s&&(this.g=this.q())}async"q"(){this.isUpdatePending=!0;try{for(await this.g;this.o;)await this.o}catch(t){Promise.reject(t)}const t=this.performUpdate();return null!=t&&await t,!this.isUpdatePending}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this.i&&(this.i.forEach(((t,e)=>this[e]=t)),this.i=void 0);let e=!1;const i=this.L;try{e=this.shouldUpdate(i),e?(this.willUpdate(i),null===(t=this.U)||void 0===t||t.forEach((t=>{var e;return null===(e=t.hostUpdate)||void 0===e?void 0:e.call(t)})),this.update(i)):this.$()}catch(t){throw e=!1,this.$(),t}e&&this.E(i)}willUpdate(t){}E(t){var e;null===(e=this.U)||void 0===e||e.forEach((t=>{var e;return null===(e=t.hostUpdated)||void 0===e?void 0:e.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}"$"(){this.L=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this.g}shouldUpdate(t){return!0}update(t){void 0!==this.k&&(this.k.forEach(((t,e)=>this.j(e,this[e],t))),this.k=void 0),this.$()}updated(t){}firstUpdated(t){}}var X,Y,tt,et,it,st;Q.finalized=!0,Q.elementProperties=new Map,Q.elementStyles=[],Q.shadowRootOptions={mode:"open"},null===(W=(q=globalThis).reactiveElementPlatformSupport)||void 0===W||W.call(q,{ReactiveElement:Q}),(null!==(K=(F=globalThis).reactiveElementVersions)&&void 0!==K?K:F.reactiveElementVersions=[]).push("1.0.0-rc.2"),(null!==(X=(st=globalThis).litElementVersions)&&void 0!==X?X:st.litElementVersions=[]).push("3.0.0-rc.2");class ot extends Q{constructor(){super(...arguments),this.renderOptions={host:this},this.t=void 0}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const e=this.render();super.update(t),this.t=((t,e,i)=>{var s,o;const n=null!==(s=null==i?void 0:i.renderBefore)&&void 0!==s?s:e;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==i?void 0:i.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new A(e.insertBefore(p(),t),t,void 0,i)}return l.I(t),l})(e,this.renderRoot,this.renderOptions)}connectedCallback(){var t;super.connectedCallback(),null===(t=this.t)||void 0===t||t.setConnected(!0)}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this.t)||void 0===t||t.setConnected(!1)}render(){return O}}ot.finalized=!0,ot._$litElement$=!0,null===(tt=(Y=globalThis).litElementHydrateSupport)||void 0===tt||tt.call(Y,{LitElement:ot}),null===(it=(et=globalThis).litElementPlatformSupport)||void 0===it||it.call(et,{LitElement:ot});const nt=t=>null!=t?t:k,lt=t=>e=>"function"==typeof e?((t,e)=>(window.customElements.define(t,e),e))(t,e):((t,e)=>{const{kind:i,elements:s}=e;return{kind:i,elements:s,finisher(e){window.customElements.define(t,e)}}})(t,e),rt=(t,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(i){i.createProperty(e.key,t)}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this))},finisher(i){i.createProperty(e.key,t)}};function at(t){return(e,i)=>void 0!==i?((t,e,i)=>{e.constructor.createProperty(i,t)})(t,e,i):rt(t,e)}const dt="Enter",ht="Tab",ct=()=>{},pt={label:"",value:"",select:ct,unselect:ct,disabled:!1,hidden:!1,selected:!1},ut=D`.select-wrapper{position:relative}.select{bottom:0;display:flex;flex-wrap:wrap;left:0;position:absolute;right:0;top:0;width:var(--select-width,100%)}.label:focus{outline:var(--select-outline,2px solid #e3e3e3)}.label:after{border-bottom:1px solid var(--color,#000);border-right:1px solid var(--color,#000);box-sizing:border-box;content:"";display:block;height:10px;margin-top:-2px;transform:rotate(45deg);transition:.2s ease-in-out;width:10px}.label.visible:after{margin-bottom:-4px;margin-top:0;transform:rotate(225deg)}select{-webkit-appearance:none;-moz-appearance:none;appearance:none;position:relative;opacity:0}select[multiple]{z-index:0}.label,select{align-items:center;background-color:var(--background-color,#fff);border-radius:var(--border-radius,4px);border:var(--border-width,1px) solid var(--border-color,#000);box-sizing:border-box;color:var(--color,#000);cursor:pointer;display:flex;font-family:var(--font-family,inherit);font-size:var(--font-size,14px);font-weight:var(--font-weight,400);min-height:var(--select-height,44px);justify-content:space-between;padding:var(--padding,0 10px);width:100%;z-index:1}@media only screen and (hover:none) and (pointer:coarse){select{z-index:2}}.dropdown{background-color:var(--border-color,#000);border-radius:var(--border-radius,4px);border:var(--border-width,1px) solid var(--border-color,#000);display:none;flex-direction:column;gap:var(--border-width,1px);justify-content:space-between;max-height:calc(var(--select-height,44px) * var(--dropdown-items,4) + var(--border-width,1px) * calc(var(--dropdown-items,4) - 1));overflow-y:scroll;position:absolute;top:calc(var(--select-height,44px) + var(--dropdown-gap,0px));width:calc(100% - var(--border-width,1px) * 2);z-index:var(--dropdown-z-index,2)}.dropdown.visible{display:flex;z-index:100}.disabled{background-color:var(--disabled-background-color,#bdc3c7);color:var(--disabled-color,#ecf0f1);cursor:default}.multi-selected{background-color:var(--selected-background-color,#e3e3e3);border-radius:var(--border-radius,4px);color:var(--selected-color,#000);display:flex;gap:8px;justify-content:space-between;padding:2px 4px}.multi-selected-wrapper{display:flex;flex-wrap:wrap;gap:4px;width:calc(100% - 30px)}.cross:after{content:'\\00d7';display:inline-block;height:100%;text-align:center;width:12px}`,vt=D`.option{align-items:center;background-color:var(--background-color,#fff);box-sizing:border-box;color:var(--color,#000);cursor:pointer;display:flex;font-family:var(--font-family,inherit);font-size:var(--font-size,14px);font-weight:var(--font-weight,400);height:var(--select-height,44px);height:var(--select-height,44px);justify-content:flex-start;padding:var(--padding,0 10px);width:100%}.option:not(.disabled):focus,.option:not(.disabled):not(.selected):hover{background-color:var(--hover-background-color,#e3e3e3);color:var(--hover-color,#000)}.selected{background-color:var(--selected-background-color,#e3e3e3);color:var(--selected-color,#000)}.disabled{background-color:var(--disabled-background-color,#e3e3e3);color:var(--disabled-color,#000);cursor:default}`;var ft=function(t,e,i,s){var o,n=arguments.length,l=n<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)l=Reflect.decorate(t,e,i,s);else for(var r=t.length-1;r>=0;r--)(o=t[r])&&(l=(n<3?o(l):n>3?o(e,i,l):o(e,i))||l);return n>3&&l&&Object.defineProperty(e,i,l),l};let bt=class extends ot{constructor(){super(...arguments),this.isSelected=!1,this.isDisabled=!1,this.isHidden=!1,this.optionValue="",this.displayedLabel="",this.optionIndex=-1}static get styles(){return vt}connectedCallback(){super.connectedCallback(),this.isSelected=null!==this.getAttribute("selected"),this.isDisabled=null!==this.getAttribute("disabled"),this.isHidden=null!==this.getAttribute("hidden"),this.optionValue=this.getAttribute("value")||"",this.assignDisplayedLabel(),this.fireOnReadyCallback()}getOption(){return{label:this.displayedLabel,value:this.optionValue,select:this.select,unselect:this.unselect,selected:this.isSelected,disabled:this.isDisabled,hidden:this.isHidden}}select(){this.isSelected=!0,this.setAttribute("selected","")}unselect(){this.isSelected=!1,this.removeAttribute("selected")}setOnReadyCallback(t,e){this.onReady=t,this.optionIndex=e}setOnSelectCallback(t){this.onSelect=t}render(){const t=["option"];return this.isSelected&&t.push("selected"),this.isDisabled&&t.push("disabled"),w`<div class="${t.join(" ")}" @click="${this.fireOnSelectCallback}" @keydown="${this.fireOnSelectIfEnterPressed}" tabindex="${nt(this.isDisabled?void 0:"0")}"><slot hidden @slotchange="${this.assignDisplayedLabel}"></slot>${this.displayedLabel}</div>`}assignDisplayedLabel(){this.textContent?this.displayedLabel=this.textContent:this.getAttribute("label")&&(this.displayedLabel=this.getAttribute("label")||"")}fireOnReadyCallback(){this.onReady&&this.onReady(this.getOption(),this.optionIndex)}fireOnSelectCallback(t){t.stopPropagation(),this.onSelect&&!this.isDisabled&&this.onSelect(this.optionValue)}fireOnSelectIfEnterPressed(t){t.key===dt&&this.fireOnSelectCallback(t)}};ft([at()],bt.prototype,"isSelected",void 0),ft([at()],bt.prototype,"isDisabled",void 0),ft([at()],bt.prototype,"isHidden",void 0),ft([at()],bt.prototype,"optionValue",void 0),ft([at()],bt.prototype,"displayedLabel",void 0),ft([at()],bt.prototype,"optionIndex",void 0),ft([e],bt.prototype,"getOption",null),ft([e],bt.prototype,"select",null),ft([e],bt.prototype,"unselect",null),ft([e],bt.prototype,"fireOnReadyCallback",null),bt=ft([lt("option-pure")],bt);var yt=function(t,e,i,s){var o,n=arguments.length,l=n<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)l=Reflect.decorate(t,e,i,s);else for(var r=t.length-1;r>=0;r--)(o=t[r])&&(l=(n<3?o(l):n>3?o(e,i,l):o(e,i))||l);return n>3&&l&&Object.defineProperty(e,i,l),l};let gt=class extends ot{constructor(){super(...arguments),this.options=[],this.visible=!1,this.selectedOption=pt,this._selectedOptions=[],this.disabled=!1,this.isMultipleSelect=!1,this.name="",this._id="",this.formName="",this.value="",this.values=[],this.defaultLabel="",this.totalRenderedChildOptions=-1,this.form=null,this.hiddenInput=null}static get styles(){return ut}connectedCallback(){super.connectedCallback(),this.disabled=null!==this.getAttribute("disabled"),this.isMultipleSelect=null!==this.getAttribute("multiple"),this.name=this.getAttribute("name")||"",this._id=this.getAttribute("id")||"",this.formName=this.name||this.id,this.defaultLabel=this.getAttribute("default-label")||""}open(){this.disabled||(this.visible=!0,this.removeEventListeners(),document.body.addEventListener("click",this.close,!0))}close(t){t&&this.contains(t.target)||(this.visible=!1,this.removeEventListeners())}enable(){this.disabled=!1}disable(){this.disabled=!0}get selectedIndex(){var t;return null===(t=this.nativeSelect)||void 0===t?void 0:t.selectedIndex}set selectedIndex(t){(t||0===t)&&this.selectOptionByValue(this.options[t].value)}get selectedOptions(){var t;return null===(t=this.nativeSelect)||void 0===t?void 0:t.selectedOptions}render(){const t=["label"];return this.disabled&&t.push("disabled"),this.visible&&t.push("visible"),w`<div class="select-wrapper"><select @change="${this.handleNativeSelectChange}" ?disabled="${this.disabled}" ?multiple="${this.isMultipleSelect}" name="${nt(this.name||void 0)}" id="${nt(this.id||void 0)}" size="1">${this.getNativeOptionsHtml()}</select><div class="select"><div class="${t.join(" ")}" @click="${this.visible?this.close:this.open}" @keydown="${this.openDropdownIfProperKeyIsPressed}" tabindex="0">${this.getDisplayedLabel()}</div><div class="dropdown${this.visible?" visible":""}"><slot @slotchange="${this.initializeSelect}"></slot></div></div></div>`}handleNativeSelectChange(){var t;this.selectedIndex=null===(t=this.nativeSelect)||void 0===t?void 0:t.selectedIndex}getNativeOptionsHtml(){return this.options.map(this.getSingleNativeOptionHtml)}getSingleNativeOptionHtml({value:t,label:e,hidden:i,disabled:s}){return w`<option value="${t}" ?selected="${this.isOptionSelected(t)}" ?hidden="${i}" ?disabled="${s}">${e}</option>`}isOptionSelected(t){let e=this.selectedOption.value===t;return this.isMultipleSelect&&(e=Boolean(this._selectedOptions.find((e=>e.value===t)))),e}openDropdownIfProperKeyIsPressed(t){t.key!==dt&&t.key!==ht||this.open()}getDisplayedLabel(){return this.isMultipleSelect&&this._selectedOptions.length?this.getMultiSelectLabelHtml():this.selectedOption.label||this.defaultLabel}getMultiSelectLabelHtml(){return w`<div class="multi-selected-wrapper">${this._selectedOptions.map(this.getMultiSelectSelectedOptionHtml)}</div>`}getMultiSelectSelectedOptionHtml({label:t,value:e}){return w`<span class="multi-selected">${t} <span class="cross" @click="${t=>this.fireOnSelectCallback(t,e)}"></span></span>`}fireOnSelectCallback(t,e){t.stopPropagation(),this.selectOptionByValue(e)}initializeSelect(){this.processChildOptions(),this.selectDefaultOptionIfNoneSelected(),this.appendHiddenInputToClosestForm()}processChildOptions(){const t=this.querySelectorAll("option-pure");this.totalRenderedChildOptions=t.length;for(let e=0;e<t.length;e++)this.initializeSingleOption(t[e],e)}selectDefaultOptionIfNoneSelected(){!this.selectedOption.value&&!this.isMultipleSelect&&this.options.length&&this.selectOptionByValue(this.options[0].value)}initializeSingleOption(t,e){t.setOnSelectCallback(this.selectOptionByValue),this.options[e]=t.getOption(),this.options[e].selected&&this.selectOptionByValue(this.options[e].value)}removeEventListeners(){document.body.removeEventListener("click",this.close)}appendHiddenInputToClosestForm(){this.form=this.closest("form"),this.form&&!this.hiddenInput&&(this.hiddenInput=document.createElement("input"),this.hiddenInput.setAttribute("type","hidden"),this.hiddenInput.setAttribute("name",this.formName),this.form.appendChild(this.hiddenInput))}unselectAllOptions(){for(let t=0;t<this.options.length;t++)this.options[t].unselect()}selectOptionByValue(t){const e=this.options.find((({value:e})=>e===t));e&&this.setSelectValue(e)}setSelectValue(t){this.isMultipleSelect?this.setMultiSelectValue(t):this.setSingleSelectValue(t),this.updateHiddenInputInForm(),this.dispatchChangeEvent()}dispatchChangeEvent(){this.dispatchEvent(new Event("change"))}setMultiSelectValue(t){const e=this._selectedOptions.indexOf(t);-1!==e?(this.values.splice(e,1),this._selectedOptions.splice(e,1),t.unselect()):(this.values.push(t.value),this._selectedOptions.push(t),t.select()),this.requestUpdate()}setSingleSelectValue(t){this.unselectAllOptions(),this.close(),this.selectedOption=t,this.value=t.value,t.select()}updateHiddenInputInForm(){if(!this.form||!this.hiddenInput)return;this.hiddenInput.value=this.isMultipleSelect?this.values.join(","):this.value;const t=new Event("change",{bubbles:!0});this.hiddenInput.dispatchEvent(t)}};yt([at()],gt.prototype,"options",void 0),yt([at()],gt.prototype,"visible",void 0),yt([at()],gt.prototype,"selectedOption",void 0),yt([at()],gt.prototype,"_selectedOptions",void 0),yt([at()],gt.prototype,"disabled",void 0),yt([at()],gt.prototype,"isMultipleSelect",void 0),yt([at()],gt.prototype,"name",void 0),yt([at()],gt.prototype,"_id",void 0),yt([at()],gt.prototype,"formName",void 0),yt([at()],gt.prototype,"value",void 0),yt([at()],gt.prototype,"values",void 0),yt([at()],gt.prototype,"defaultLabel",void 0),yt([at()],gt.prototype,"totalRenderedChildOptions",void 0),yt([function(t,e){return(({finisher:t,descriptor:e})=>(i,s)=>{var o;if(void 0===s){const s=null!==(o=i.originalKey)&&void 0!==o?o:i.key,n=null!=e?{kind:"method",placement:"prototype",key:s,descriptor:e(i.key)}:{...i,key:s};return null!=t&&(n.finisher=function(e){t(e,s)}),n}{const o=i.constructor;void 0!==e&&Object.defineProperty(i,s,e(s)),null==t||t(o,s)}})({descriptor:i=>{const s={get(){var e;return null===(e=this.renderRoot)||void 0===e?void 0:e.querySelector(t)},enumerable:!0,configurable:!0};if(e){const e="symbol"==typeof i?Symbol():"__"+i;s.get=function(){var i;return void 0===this[e]&&(this[e]=null===(i=this.renderRoot)||void 0===i?void 0:i.querySelector(t)),this[e]}}return s}})}("select")],gt.prototype,"nativeSelect",void 0),yt([e],gt.prototype,"close",null),yt([e],gt.prototype,"getSingleNativeOptionHtml",null),yt([e],gt.prototype,"getMultiSelectLabelHtml",null),yt([e],gt.prototype,"getMultiSelectSelectedOptionHtml",null),yt([e],gt.prototype,"initializeSelect",null),yt([e],gt.prototype,"initializeSingleOption",null),yt([e],gt.prototype,"removeEventListeners",null),yt([e],gt.prototype,"appendHiddenInputToClosestForm",null),yt([e],gt.prototype,"selectOptionByValue",null),gt=yt([lt("select-pure")],gt);


/***/ }),

/***/ "./node_modules/_sockjs-client@1.5.2@sockjs-client/dist/sockjs.js":
/*!************************************************************************!*\
  !*** ./node_modules/_sockjs-client@1.5.2@sockjs-client/dist/sockjs.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* sockjs-client v1.5.2 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    // exception is 127.0.0.0/8 and ::1 urls
    if (!urlUtils.isLoopbackAddr(parsedUrl.hostname)) {
      throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
    }
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex, no-misleading-character-class
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }

, isLoopbackAddr: function (addr) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^\[::1\]$/.test(addr);
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.5.2';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | https://bestiejs.github.io/json3 | Copyright 2012-2015, Kit Cambridge, Benjamin Tan | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root.Object());
    exports || (exports = root.Object());

    // Native constructor aliases.
    var Number = context.Number || root.Number,
        String = context.String || root.String,
        Object = context.Object || root.Object,
        Date = context.Date || root.Date,
        SyntaxError = context.SyntaxError || root.SyntaxError,
        TypeError = context.TypeError || root.TypeError,
        Math = context.Math || root.Math,
        nativeJSON = context.JSON || root.JSON;

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty = objectProto.hasOwnProperty,
        undefined;

    // Internal: Contains `try...catch` logic used by other functions.
    // This prevents other functions from being deoptimized.
    function attempt(func, errorFunc) {
      try {
        func();
      } catch (exception) {
        if (errorFunc) {
          errorFunc();
        }
      }
    }

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    attempt(function () {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    });

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] != null) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("date-serialization") && has("json-parse");
      } else if (name == "date-serialization") {
        // Indicates whether `Date`s can be serialized accurately by `JSON.stringify`.
        isSupported = has("json-stringify") && isExtended;
        if (isSupported) {
          var stringify = exports.stringify;
          attempt(function () {
            isSupported =
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          });
        }
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function";
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            attempt(function () {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undefined &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undefined) === undefined &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undefined &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undefined]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undefined, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]";
            }, function () {
              stringifySupported = false;
            });
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse, parseSupported;
          if (typeof parse == "function") {
            attempt(function () {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  attempt(function () {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  });
                  if (parseSupported) {
                    attempt(function () {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    });
                  }
                  if (parseSupported) {
                    attempt(function () {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    });
                  }
                }
              }
            }, function () {
              parseSupported = false;
            });
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }
    has["bug-string-char-index"] = has["date-serialization"] = has["json"] = has["json-stringify"] = has["json-parse"] = null;

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      var forOwn = function (object, callback) {
        var size = 0, Properties, dontEnums, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        dontEnums = new Properties();
        for (property in dontEnums) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(dontEnums, property)) {
            size++;
          }
        }
        Properties = dontEnums = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          dontEnums = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forOwn = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = dontEnums.length; property = dontEnums[--length];) {
              if (hasProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forOwn = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forOwn(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify") && !has("date-serialization")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Serializes a date object.
        var serializeDate = function (value) {
          var getData, year, month, date, time, hours, minutes, seconds, milliseconds;
          // Define additional utility methods if the `Date` methods are buggy.
          if (!isExtended) {
            var floor = Math.floor;
            // A mapping between the months of the year and the number of days between
            // January 1st and the first of the respective month.
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            // Internal: Calculates the number of days between the Unix epoch and the
            // first day of the given month.
            var getDay = function (year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
            };
            getData = function (value) {
              // Manually compute the year, month, date, hours, minutes,
              // seconds, and milliseconds if the `getUTC*` methods are
              // buggy. Adapted from @Yaffle's `date-shim` project.
              date = floor(value / 864e5);
              for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
              for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
              date = 1 + date - getDay(year, month);
              // The `time` value specifies the time within the day (see ES
              // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
              // to compute `A modulo B`, as the `%` operator does not
              // correspond to the `modulo` operation for negative numbers.
              time = (value % 864e5 + 864e5) % 864e5;
              // The hours, minutes, seconds, and milliseconds are obtained by
              // decomposing the time within the day. See section 15.9.1.10.
              hours = floor(time / 36e5) % 24;
              minutes = floor(time / 6e4) % 60;
              seconds = floor(time / 1e3) % 60;
              milliseconds = time % 1e3;
            };
          } else {
            getData = function (value) {
              year = value.getUTCFullYear();
              month = value.getUTCMonth();
              date = value.getUTCDate();
              hours = value.getUTCHours();
              minutes = value.getUTCMinutes();
              seconds = value.getUTCSeconds();
              milliseconds = value.getUTCMilliseconds();
            };
          }
          serializeDate = function (value) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              getData(value);
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
              "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
              // Months, dates, hours, minutes, and seconds should have two
              // digits; milliseconds should have three.
              "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
              // Milliseconds are optional in ES 5.0, but required in 5.1.
              "." + toPaddedString(3, milliseconds) + "Z";
              year = month = date = hours = minutes = seconds = milliseconds = null;
            } else {
              value = null;
            }
            return value;
          };
          return serializeDate(value);
        };

        // For environments with `JSON.stringify` but buggy date serialization,
        // we override the native `Date#toJSON` implementation with a
        // spec-compliant one.
        if (has("json-stringify") && !has("date-serialization")) {
          // Internal: the `Date#toJSON` implementation used to override the native one.
          function dateToJSON (key) {
            return serializeDate(this);
          }

          // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
          var nativeStringify = exports.stringify;
          exports.stringify = function (source, filter, width) {
            var nativeToJSON = Date.prototype.toJSON;
            Date.prototype.toJSON = dateToJSON;
            var result = nativeStringify(source, filter, width);
            Date.prototype.toJSON = nativeToJSON;
            return result;
          }
        } else {
          // Internal: Double-quotes a string `value`, replacing all ASCII control
          // characters (characters with code unit values between 0 and 31) with
          // their escaped equivalents. This is an implementation of the
          // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
          var unicodePrefix = "\\u00";
          var escapeChar = function (character) {
            var charCode = character.charCodeAt(0), escaped = Escapes[charCode];
            if (escaped) {
              return escaped;
            }
            return unicodePrefix + toPaddedString(2, charCode.toString(16));
          };
          var reEscape = /[\x00-\x1f\x22\x5c]/g;
          var quote = function (value) {
            reEscape.lastIndex = 0;
            return '"' +
              (
                reEscape.test(value)
                  ? value.replace(reEscape, escapeChar)
                  : value
              ) +
              '"';
          };

          // Internal: Recursively serializes an object. Implements the
          // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
          var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
            var value, type, className, results, element, index, length, prefix, result;
            attempt(function () {
              // Necessary for host object support.
              value = object[property];
            });
            if (typeof value == "object" && value) {
              if (value.getUTCFullYear && getClass.call(value) == dateClass && value.toJSON === Date.prototype.toJSON) {
                value = serializeDate(value);
              } else if (typeof value.toJSON == "function") {
                value = value.toJSON(property);
              }
            }
            if (callback) {
              // If a replacement function was provided, call it to obtain the value
              // for serialization.
              value = callback.call(object, property, value);
            }
            // Exit early if value is `undefined` or `null`.
            if (value == undefined) {
              return value === undefined ? value : "null";
            }
            type = typeof value;
            // Only call `getClass` if the value is an object.
            if (type == "object") {
              className = getClass.call(value);
            }
            switch (className || type) {
              case "boolean":
              case booleanClass:
                // Booleans are represented literally.
                return "" + value;
              case "number":
              case numberClass:
                // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                // `"null"`.
                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
              case "string":
              case stringClass:
                // Strings are double-quoted and escaped.
                return quote("" + value);
            }
            // Recursively serialize objects and arrays.
            if (typeof value == "object") {
              // Check for cyclic structures. This is a linear search; performance
              // is inversely proportional to the number of unique nested objects.
              for (length = stack.length; length--;) {
                if (stack[length] === value) {
                  // Cyclic structures cannot be serialized by `JSON.stringify`.
                  throw TypeError();
                }
              }
              // Add the object to the stack of traversed objects.
              stack.push(value);
              results = [];
              // Save the current indentation level and indent one additional level.
              prefix = indentation;
              indentation += whitespace;
              if (className == arrayClass) {
                // Recursively serialize array elements.
                for (index = 0, length = value.length; index < length; index++) {
                  element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                  results.push(element === undefined ? "null" : element);
                }
                result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
              } else {
                // Recursively serialize object members. Members are selected from
                // either a user-specified list of property names, or the object
                // itself.
                forOwn(properties || value, function (property) {
                  var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                  if (element !== undefined) {
                    // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                    // is not the empty string, let `member` {quote(property) + ":"}
                    // be the concatenation of `member` and the `space` character."
                    // The "`space` character" refers to the literal space
                    // character, not the `space` {width} argument provided to
                    // `JSON.stringify`.
                    results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                  }
                });
                result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
              }
              // Remove the object from the traversed object stack.
              stack.pop();
              return result;
            }
          };

          // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
          exports.stringify = function (source, filter, width) {
            var whitespace, callback, properties, className;
            if (objectTypes[typeof filter] && filter) {
              className = getClass.call(filter);
              if (className == functionClass) {
                callback = filter;
              } else if (className == arrayClass) {
                // Convert the property names array into a makeshift set.
                properties = {};
                for (var index = 0, length = filter.length, value; index < length;) {
                  value = filter[index++];
                  className = getClass.call(value);
                  if (className == "[object String]" || className == "[object Number]") {
                    properties[value] = 1;
                  }
                }
              }
            }
            if (width) {
              className = getClass.call(width);
              if (className == numberClass) {
                // Convert the `width` to an integer and create a string containing
                // `width` number of space characters.
                if ((width -= width % 1) > 0) {
                  if (width > 10) {
                    width = 10;
                  }
                  for (whitespace = ""; whitespace.length < width;) {
                    whitespace += " ";
                  }
                }
              } else if (className == stringClass) {
                whitespace = width.length <= 10 ? width : width.slice(0, 10);
              }
            }
            // Opera <= 7.54u2 discards the values associated with empty string keys
            // (`""`) only if they are used directly within an object member list
            // (e.g., `!("" in { "": 1})`).
            return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
          };
        }
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length; position++) {
                      charCode = source.charCodeAt(position);
                      if (charCode < 48 || charCode > 57) {
                        break;
                      }
                    }
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length; position++) {
                      charCode = source.charCodeAt(position);
                      if (charCode < 48 || charCode > 57) {
                        break;
                      }
                    }
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                var temp = source.slice(Index, Index + 4);
                if (temp == "true") {
                  Index += 4;
                  return true;
                } else if (temp == "fals" && source.charCodeAt(Index + 4 ) == 101) {
                  Index += 5;
                  return false;
                } else if (temp == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;;) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                } else {
                  hasMembers = true;
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;;) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                } else {
                  hasMembers = true;
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undefined) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forOwn` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(getClass, forOwn, value, length, callback);
              }
            } else {
              forOwn(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports.runInContext = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root.JSON3,
        isRestored = false;

    var JSON3 = runInContext(root, (root.JSON3 = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root.JSON3 = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),

/***/ "./node_modules/_strip-ansi@3.0.1@strip-ansi/index.js":
/*!************************************************************!*\
  !*** ./node_modules/_strip-ansi@3.0.1@strip-ansi/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/_ansi-regex@2.1.1@ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./demo/RayTracingApp.ts":
/*!*******************************!*\
  !*** ./demo/RayTracingApp.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! select-pure/dist/index.js */ "./node_modules/_select-pure@2.1.1-alpha.1@select-pure/dist/index.js");
var H = __webpack_require__(/*! ../src/index */ "./src/index.ts");
var debugCs_1 = __webpack_require__(/*! ./debugCs */ "./demo/debugCs.ts");
var MODEL_SRC = '/assets/models/walls/scene.gltf';
var MAX_SAMPLERS = 256;
function addSelect(onChange) {
    var domText = "\n<select-pure name=\"View Mode\" id=\"view-mode\" style=\"position:absolute;right:0;width:128px;\">\n  <option-pure value=\"result\">Result</option-pure>\n  <option-pure value=\"bvh\">Show BVH</option-pure>\n  <option-pure value=\"gbuffer\">Show GBuffer</option-pure>\n  <option-pure value=\"origin\">Origin</option-pure>\n</select-pure>\n  ";
    var dom = document.createElement('div');
    dom.innerHTML = domText;
    document.body.appendChild(dom);
    var selectPure = document.querySelector('select-pure');
    selectPure.addEventListener('change', function (event) {
        var value = event.target.value;
        onChange(value);
    });
    return dom;
}
var RayTracingApp = (function () {
    function RayTracingApp() {
        this._frameCount = 0;
        this._viewMode = 'result';
    }
    RayTracingApp.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var renderEnv, _scene, rootNode, _a, model, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        addSelect(function (value) {
                            console.log(value);
                            _this._viewMode = value;
                            _this._frameCount = 0;
                        });
                        renderEnv = H.renderEnv;
                        _scene = this._scene = new H.Scene();
                        rootNode = this._scene.rootNode = new H.Node();
                        this._camControl = new H.NodeControl('free');
                        rootNode.addChild(this._camera = new H.Camera({ clearColor: [0, 1, 0, 1] }, { near: 0.01, far: 100, fov: Math.PI / 3 }));
                        this._camera.pos.set([0, 0, 6]);
                        _a = this;
                        return [4, H.resource.load({ type: 'texture', name: 'noise.tex', src: '/assets/textures/noise-rgba.webp' })];
                    case 1:
                        _a._noiseTex = _c.sent();
                        _b = this;
                        return [4, H.resource.load({ type: 'gltf', name: 'scene.gltf', src: MODEL_SRC })];
                    case 2:
                        model = _b._model = _c.sent();
                        if (model.cameras.length) {
                            this._camera = model.cameras[0];
                        }
                        _scene.rootNode.addChild(model.rootNode);
                        this._gBufferRT = new H.RenderTexture({
                            width: renderEnv.width,
                            height: renderEnv.height,
                            colors: [
                                { name: 'positionMetalOrSpec', format: 'rgba16float' },
                                { name: 'baseColorRoughOrGloss', format: 'rgba16float' },
                                { name: 'normalGlass', format: 'rgba16float' },
                                { name: 'meshIndexMatIndexMatType', format: 'rgba8uint' }
                            ],
                            depthStencil: { needStencil: false }
                        });
                        this._gbufferLightMaterial = new H.Material(H.buildinEffects.rRTGBufferLight);
                        this._gBufferDebugMesh = new H.ImageMesh(new H.Material(H.buildinEffects.iRTGShow));
                        this._connectGBufferRenderTexture(this._gBufferDebugMesh.material);
                        this._rtOutput = new H.RenderTexture({
                            width: renderEnv.width,
                            height: renderEnv.height,
                            forCompute: true,
                            colors: [{ name: 'color', format: 'rgba16float' }]
                        });
                        this._denoiseRTs = {
                            current: new H.RenderTexture({
                                width: renderEnv.width,
                                height: renderEnv.height,
                                forCompute: true,
                                colors: [{ name: 'color', format: 'rgba16float' }]
                            }),
                            pre: new H.RenderTexture({
                                width: renderEnv.width,
                                height: renderEnv.height,
                                forCompute: true,
                                colors: [{ name: 'color', format: 'rgba16float' }]
                            }),
                            final: new H.RenderTexture({
                                width: renderEnv.width,
                                height: renderEnv.height,
                                forCompute: true,
                                colors: [{ name: 'color' }]
                            }),
                        };
                        this._denoiseTemporUnit = new H.ComputeUnit(H.buildinEffects.cRTDenoiseTempor, { x: Math.ceil(renderEnv.width / 16), y: Math.ceil(renderEnv.height / 16) });
                        this._denoiseSpaceUnit = new H.ComputeUnit(H.buildinEffects.cRTDenoiseSpace, { x: Math.ceil(renderEnv.width / 16), y: Math.ceil(renderEnv.height / 16) }, { u_output: this._denoiseRTs.final }, { WINDOW_SIZE: 7 });
                        this._connectGBufferRenderTexture(this._denoiseSpaceUnit);
                        this._rtBlit = new H.ImageMesh(new H.Material(H.buildinEffects.iBlit, { u_texture: this._denoiseRTs.final }));
                        this._rtDebugInfo = new debugCs_1.DebugInfo();
                        this._camControl.control(this._camera, new H.Node());
                        this._camControl.onChange = function () {
                            _this._frameCount = 0;
                        };
                        return [4, this._frame(16)];
                    case 3:
                        _c.sent();
                        return [2];
                }
            });
        });
    };
    RayTracingApp.prototype.update = function (dt) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this._frame(dt)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    RayTracingApp.prototype._frame = function (dt) {
        return __awaiter(this, void 0, void 0, function () {
            var _scene, preWeight, first;
            return __generator(this, function (_a) {
                _scene = this._scene;
                this._frameCount += 1;
                preWeight = (this._frameCount - 1) / this._frameCount;
                if (preWeight > .999) {
                    return [2];
                }
                _scene.startFrame(dt);
                first = !this._rtManager;
                if (first) {
                    this._rtManager = new H.RayTracingManager();
                    this._rtManager.process(this._scene.cullCamera(this._camera), this._rtOutput);
                    this._rtManager.rtUnit.setUniform('u_noise', this._noiseTex);
                    this._connectGBufferRenderTexture(this._rtManager.rtUnit);
                }
                this._rtManager.rtUnit.setUniform('u_randoms', new Float32Array(16).map(function (v) { return Math.random(); }));
                this._denoiseTemporUnit.setUniform('u_preWeight', new Float32Array([preWeight]));
                if (this._viewMode === 'bvh') {
                    this._showBVH();
                }
                else if (this._viewMode === 'gbuffer') {
                    this._renderGBuffer();
                    this._showGBufferResult();
                }
                else {
                    this._renderGBuffer();
                    this._scene.setRenderTarget(null);
                    this._computeRTSS();
                    if (this._viewMode === 'result') {
                        this._computeDenoise();
                        this._rtBlit.material.setUniform('u_texture', this._denoiseRTs.final);
                    }
                    else {
                        this._rtBlit.material.setUniform('u_texture', this._rtOutput);
                    }
                    this._scene.renderImages([this._rtBlit]);
                }
                if (this._rtDebugMesh) {
                    _scene.renderCamera(this._camera, [this._rtDebugMesh], false);
                }
                _scene.endFrame();
                return [2];
            });
        });
    };
    RayTracingApp.prototype._renderGBuffer = function () {
        var _this = this;
        this._scene.setRenderTarget(this._gBufferRT);
        var lightMeshes = this._scene.lights.map(function (light) { return light.requireLightMesh(_this._gbufferLightMaterial); }).filter(function (m) { return !!m; });
        this._scene.renderCamera(this._camera, __spreadArrays([
            this._rtManager.gBufferMesh
        ], lightMeshes));
    };
    RayTracingApp.prototype._computeRTSS = function () {
        this._scene.computeUnits([this._rtManager.rtUnit]);
    };
    RayTracingApp.prototype._computeDenoise = function () {
        var _a = this._denoiseRTs, current = _a.current, pre = _a.pre;
        this._denoiseTemporUnit.setUniform('u_output', current);
        this._denoiseTemporUnit.setUniform('u_pre', pre);
        this._denoiseTemporUnit.setUniform('u_current', this._rtOutput);
        this._denoiseSpaceUnit.setUniform('u_mixed', current);
        this._scene.computeUnits([this._denoiseTemporUnit, this._denoiseSpaceUnit]);
        this._denoiseRTs.current = pre;
        this._denoiseRTs.pre = current;
    };
    RayTracingApp.prototype._showGBufferResult = function () {
        this._scene.setRenderTarget(null);
        this._scene.renderImages([this._gBufferDebugMesh]);
    };
    RayTracingApp.prototype._showBVH = function () {
        this._scene.setRenderTarget(null);
        this._scene.renderCamera(this._camera, __spreadArrays(this._scene.cullCamera(this._camera), [
            this._rtManager.bvhDebugMesh
        ]));
    };
    RayTracingApp.prototype._connectGBufferRenderTexture = function (material) {
        material.setUniform('u_gbPositionMetalOrSpec', this._gBufferRT, 'positionMetalOrSpec');
        material.setUniform('u_gbBaseColorRoughOrGloss', this._gBufferRT, 'baseColorRoughOrGloss');
        material.setUniform('u_gbNormalGlass', this._gBufferRT, 'normalGlass');
        material.setUniform('u_gbMeshIndexMatIndexMatType', this._gBufferRT, 'meshIndexMatIndexMatType');
    };
    return RayTracingApp;
}());
exports["default"] = RayTracingApp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmF5VHJhY2luZ0FwcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlJheVRyYWNpbmdBcHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUEscUNBQW1DO0FBQ25DLGdDQUFrQztBQUNsQyxxQ0FBNkY7QUFFN0YsSUFBTSxTQUFTLEdBQUcsaUNBQWlDLENBQUM7QUFDcEQsSUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDO0FBRXpCLFNBQVMsU0FBUyxDQUFDLFFBQW1DO0lBQ3BELElBQU0sT0FBTyxHQUFHLHdWQU9mLENBQUM7SUFFRixJQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0lBQ3hCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRS9CLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFRLENBQUM7SUFDaEUsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDLEtBQVU7UUFDL0MsSUFBTSxLQUFLLEdBQVcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDekMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2xCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7SUFBQTtRQWlCVSxnQkFBVyxHQUFXLENBQUMsQ0FBQztRQUN4QixjQUFTLEdBQVcsUUFBUSxDQUFDO0lBMk52QyxDQUFDO0lBek5jLDRCQUFJLEdBQWpCOzs7Ozs7O3dCQUNFLFNBQVMsQ0FBQyxVQUFDLEtBQUs7NEJBQ2QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTs0QkFDbEIsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7NEJB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dkYsUUFBUSxDQUFDLFVBQVUsQ0FBQywyQkFBMkIsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFDM0YsUUFBUSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZFLFFBQVEsQ0FBQyxVQUFVLENBQUMsOEJBQThCLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0lBQ25HLENBQUM7SUFDSCxvQkFBQztBQUFELENBQUMsQUE3T0QsSUE2T0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJheVRyYWNpbmdBcHAudHNcbiAqIFxuICogQEF1dGhvciAgOiBoaWthcmlkYWkoaGlrYXJpZGFpQHRlbmNlbnQuY29tKVxuICogQERhdGUgICAgOiA2LzExLzIwMjEsIDU6NTY6MzAgUE1cbiovXG5pbXBvcnQgJ3NlbGVjdC1wdXJlL2Rpc3QvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgSCBmcm9tICcuLi9zcmMvaW5kZXgnO1xuaW1wb3J0IHtEZWJ1Z0luZm8sIGRlYnVnUmF5LCBkZWJ1Z1JheVNoYWRvdywgZGVidWdSYXlTaGFkb3dzLCBzYW1wbGVDaXJjbGV9IGZyb20gJy4vZGVidWdDcyc7XG5cbmNvbnN0IE1PREVMX1NSQyA9ICcvYXNzZXRzL21vZGVscy93YWxscy9zY2VuZS5nbHRmJztcbmNvbnN0IE1BWF9TQU1QTEVSUyA9IDI1NjtcblxuZnVuY3Rpb24gYWRkU2VsZWN0KG9uQ2hhbmdlOiAob3B0aW9uczogc3RyaW5nKSA9PiB2b2lkKSB7XG4gIGNvbnN0IGRvbVRleHQgPSBgXG48c2VsZWN0LXB1cmUgbmFtZT1cIlZpZXcgTW9kZVwiIGlkPVwidmlldy1tb2RlXCIgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjEyOHB4O1wiPlxuICA8b3B0aW9uLXB1cmUgdmFsdWU9XCJyZXN1bHRcIj5SZXN1bHQ8L29wdGlvbi1wdXJlPlxuICA8b3B0aW9uLXB1cmUgdmFsdWU9XCJidmhcIj5TaG93IEJWSDwvb3B0aW9uLXB1cmU+XG4gIDxvcHRpb24tcHVyZSB2YWx1ZT1cImdidWZmZXJcIj5TaG93IEdCdWZmZXI8L29wdGlvbi1wdXJlPlxuICA8b3B0aW9uLXB1cmUgdmFsdWU9XCJvcmlnaW5cIj5PcmlnaW48L29wdGlvbi1wdXJlPlxuPC9zZWxlY3QtcHVyZT5cbiAgYDtcblxuICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZG9tLmlubmVySFRNTCA9IGRvbVRleHQ7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICBjb25zdCBzZWxlY3RQdXJlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0LXB1cmUnKSBhcyBhbnk7XG4gIHNlbGVjdFB1cmUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50OiBhbnkpID0+IHtcbiAgICBjb25zdCB2YWx1ZTogc3RyaW5nID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRvbTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmF5VHJhY2luZ0FwcCB7XG4gIHByaXZhdGUgX3NjZW5lOiBILlNjZW5lO1xuICBwcml2YXRlIF9jYW1Db250cm9sOiBILk5vZGVDb250cm9sO1xuICBwcml2YXRlIF9jYW1lcmE6IEguQ2FtZXJhO1xuICBwcml2YXRlIF9tb2RlbDogSC5JR2xURlJlc291cmNlO1xuICBwcml2YXRlIF9ub2lzZVRleDogSC5UZXh0dXJlO1xuICBwcml2YXRlIF9nQnVmZmVyUlQ6IEguUmVuZGVyVGV4dHVyZTtcbiAgcHJpdmF0ZSBfZ2J1ZmZlckxpZ2h0TWF0ZXJpYWw6IEguTWF0ZXJpYWw7XG4gIHByaXZhdGUgX2dCdWZmZXJEZWJ1Z01lc2g6IEguSW1hZ2VNZXNoO1xuICBwcml2YXRlIF9ydE1hbmFnZXI6IEguUmF5VHJhY2luZ01hbmFnZXI7XG4gIHByaXZhdGUgX3J0T3V0cHV0OiBILlJlbmRlclRleHR1cmU7XG4gIHByaXZhdGUgX2Rlbm9pc2VSVHM6IHtjdXJyZW50OiBILlJlbmRlclRleHR1cmUsIHByZTogSC5SZW5kZXJUZXh0dXJlLCBmaW5hbDogSC5SZW5kZXJUZXh0dXJlfTtcbiAgcHJpdmF0ZSBfZGVub2lzZVRlbXBvclVuaXQ6IEguQ29tcHV0ZVVuaXQ7XG4gIHByaXZhdGUgX2Rlbm9pc2VTcGFjZVVuaXQ6IEguQ29tcHV0ZVVuaXQ7XG4gIHByaXZhdGUgX3J0QmxpdDogSC5JbWFnZU1lc2g7XG4gIHByaXZhdGUgX3J0RGVidWdJbmZvOiBEZWJ1Z0luZm87XG4gIHByaXZhdGUgX3J0RGVidWdNZXNoOiBILk1lc2g7XG4gIHByaXZhdGUgX2ZyYW1lQ291bnQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX3ZpZXdNb2RlOiBzdHJpbmcgPSAncmVzdWx0JztcblxuICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICBhZGRTZWxlY3QoKHZhbHVlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSlcbiAgICAgIHRoaXMuX3ZpZXdNb2RlID0gdmFsdWU7XG4gICAgICB0aGlzLl9mcmFtZUNvdW50ID0gMDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHtyZW5kZXJFbnZ9ID0gSDtcblxuICAgIGNvbnN0IF9zY2VuZSA9IHRoaXMuX3NjZW5lID0gbmV3IEguU2NlbmUoKTtcbiAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX3NjZW5lLnJvb3ROb2RlID0gbmV3IEguTm9kZSgpO1xuICAgIHRoaXMuX2NhbUNvbnRyb2wgPSBuZXcgSC5Ob2RlQ29udHJvbCgnZnJlZScpO1xuXG4gICAgcm9vdE5vZGUuYWRkQ2hpbGQodGhpcy5fY2FtZXJhID0gbmV3IEguQ2FtZXJhKFxuICAgICAge2NsZWFyQ29sb3I6IFswLCAxLCAwLCAxXX0sXG4gICAgICB7bmVhcjogMC4wMSwgZmFyOiAxMDAsIGZvdjogTWF0aC5QSSAvIDN9XG4gICAgKSk7XG4gICAgdGhpcy5fY2FtZXJhLnBvcy5zZXQoWzAsIDAsIDZdKTtcblxuICAgIHRoaXMuX25vaXNlVGV4ID0gYXdhaXQgSC5yZXNvdXJjZS5sb2FkKHt0eXBlOiAndGV4dHVyZScsIG5hbWU6ICdub2lzZS50ZXgnLCBzcmM6ICcvYXNzZXRzL3RleHR1cmVzL25vaXNlLXJnYmEud2VicCd9KTtcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMuX21vZGVsID0gYXdhaXQgSC5yZXNvdXJjZS5sb2FkKHt0eXBlOiAnZ2x0ZicsIG5hbWU6ICdzY2VuZS5nbHRmJywgc3JjOiBNT0RFTF9TUkN9KTtcbiAgICBpZiAobW9kZWwuY2FtZXJhcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NhbWVyYSA9IG1vZGVsLmNhbWVyYXNbMF07XG4gICAgfVxuICAgIF9zY2VuZS5yb290Tm9kZS5hZGRDaGlsZChtb2RlbC5yb290Tm9kZSk7XG5cbiAgICB0aGlzLl9nQnVmZmVyUlQgPSBuZXcgSC5SZW5kZXJUZXh0dXJlKHtcbiAgICAgIHdpZHRoOiByZW5kZXJFbnYud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlbmRlckVudi5oZWlnaHQsXG4gICAgICBjb2xvcnM6IFtcbiAgICAgICAge25hbWU6ICdwb3NpdGlvbk1ldGFsT3JTcGVjJywgZm9ybWF0OiAncmdiYTE2ZmxvYXQnfSxcbiAgICAgICAge25hbWU6ICdiYXNlQ29sb3JSb3VnaE9yR2xvc3MnLCBmb3JtYXQ6ICdyZ2JhMTZmbG9hdCd9LFxuICAgICAgICB7bmFtZTogJ25vcm1hbEdsYXNzJywgZm9ybWF0OiAncmdiYTE2ZmxvYXQnfSxcbiAgICAgICAge25hbWU6ICdtZXNoSW5kZXhNYXRJbmRleE1hdFR5cGUnLCBmb3JtYXQ6ICdyZ2JhOHVpbnQnfVxuICAgICAgXSxcbiAgICAgIGRlcHRoU3RlbmNpbDoge25lZWRTdGVuY2lsOiBmYWxzZX1cbiAgICB9KTtcblxuICAgIHRoaXMuX2didWZmZXJMaWdodE1hdGVyaWFsID0gbmV3IEguTWF0ZXJpYWwoSC5idWlsZGluRWZmZWN0cy5yUlRHQnVmZmVyTGlnaHQpO1xuICAgIHRoaXMuX2dCdWZmZXJEZWJ1Z01lc2ggPSBuZXcgSC5JbWFnZU1lc2gobmV3IEguTWF0ZXJpYWwoSC5idWlsZGluRWZmZWN0cy5pUlRHU2hvdykpO1xuICAgIHRoaXMuX2Nvbm5lY3RHQnVmZmVyUmVuZGVyVGV4dHVyZSh0aGlzLl9nQnVmZmVyRGVidWdNZXNoLm1hdGVyaWFsKTtcblxuICAgIHRoaXMuX3J0T3V0cHV0ID0gbmV3IEguUmVuZGVyVGV4dHVyZSh7XG4gICAgICB3aWR0aDogcmVuZGVyRW52LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZW5kZXJFbnYuaGVpZ2h0LFxuICAgICAgZm9yQ29tcHV0ZTogdHJ1ZSxcbiAgICAgIGNvbG9yczogW3tuYW1lOiAnY29sb3InLCBmb3JtYXQ6ICdyZ2JhMTZmbG9hdCd9XVxuICAgIH0pO1xuXG4gICAgdGhpcy5fZGVub2lzZVJUcyA9IHtcbiAgICAgIGN1cnJlbnQ6IG5ldyBILlJlbmRlclRleHR1cmUoe1xuICAgICAgICB3aWR0aDogcmVuZGVyRW52LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlbmRlckVudi5oZWlnaHQsXG4gICAgICAgIGZvckNvbXB1dGU6IHRydWUsXG4gICAgICAgIGNvbG9yczogW3tuYW1lOiAnY29sb3InLCBmb3JtYXQ6ICdyZ2JhMTZmbG9hdCd9XVxuICAgICAgfSksXG4gICAgICBwcmU6IG5ldyBILlJlbmRlclRleHR1cmUoe1xuICAgICAgICB3aWR0aDogcmVuZGVyRW52LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlbmRlckVudi5oZWlnaHQsXG4gICAgICAgIGZvckNvbXB1dGU6IHRydWUsXG4gICAgICAgIGNvbG9yczogW3tuYW1lOiAnY29sb3InLCBmb3JtYXQ6ICdyZ2JhMTZmbG9hdCd9XVxuICAgICAgfSksXG4gICAgICBmaW5hbDogbmV3IEguUmVuZGVyVGV4dHVyZSh7XG4gICAgICAgIHdpZHRoOiByZW5kZXJFbnYud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVuZGVyRW52LmhlaWdodCxcbiAgICAgICAgZm9yQ29tcHV0ZTogdHJ1ZSxcbiAgICAgICAgY29sb3JzOiBbe25hbWU6ICdjb2xvcid9XVxuICAgICAgfSksXG4gICAgfTtcbiAgICB0aGlzLl9kZW5vaXNlVGVtcG9yVW5pdCA9IG5ldyBILkNvbXB1dGVVbml0KFxuICAgICAgSC5idWlsZGluRWZmZWN0cy5jUlREZW5vaXNlVGVtcG9yLFxuICAgICAge3g6IE1hdGguY2VpbChyZW5kZXJFbnYud2lkdGggLyAxNiksIHk6IE1hdGguY2VpbChyZW5kZXJFbnYuaGVpZ2h0IC8gMTYpfVxuICAgICk7XG4gICAgdGhpcy5fZGVub2lzZVNwYWNlVW5pdCA9IG5ldyBILkNvbXB1dGVVbml0KFxuICAgICAgSC5idWlsZGluRWZmZWN0cy5jUlREZW5vaXNlU3BhY2UsXG4gICAgICB7eDogTWF0aC5jZWlsKHJlbmRlckVudi53aWR0aCAvIDE2KSwgeTogTWF0aC5jZWlsKHJlbmRlckVudi5oZWlnaHQgLyAxNil9LFxuICAgICAge3Vfb3V0cHV0OiB0aGlzLl9kZW5vaXNlUlRzLmZpbmFsfSxcbiAgICAgIHtXSU5ET1dfU0laRTogN31cbiAgICApO1xuICAgIHRoaXMuX2Nvbm5lY3RHQnVmZmVyUmVuZGVyVGV4dHVyZSh0aGlzLl9kZW5vaXNlU3BhY2VVbml0KTtcblxuICAgIHRoaXMuX3J0QmxpdCA9IG5ldyBILkltYWdlTWVzaChuZXcgSC5NYXRlcmlhbChILmJ1aWxkaW5FZmZlY3RzLmlCbGl0LCB7dV90ZXh0dXJlOiB0aGlzLl9kZW5vaXNlUlRzLmZpbmFsfSkpO1xuXG4gICAgdGhpcy5fcnREZWJ1Z0luZm8gPSBuZXcgRGVidWdJbmZvKCk7XG4gICAgXG4gICAgdGhpcy5fY2FtQ29udHJvbC5jb250cm9sKHRoaXMuX2NhbWVyYSwgbmV3IEguTm9kZSgpKTtcbiAgICB0aGlzLl9jYW1Db250cm9sLm9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZnJhbWVDb3VudCA9IDA7XG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMuX2ZyYW1lKDE2KTtcblxuICAgIC8vIEgucmVuZGVyRW52LmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgYXN5bmMgKGUpID0+IHtcbiAgICAgIC8vIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IGU7XG4gICAgICAvLyBjb25zdCB7cmF5cywgbWVzaH0gPSBhd2FpdCB0aGlzLl9ydERlYnVnSW5mby5zaG93RGVidWdJbmZvKFtjbGllbnRYLCBjbGllbnRZXSwgWzEwLCAxMF0sIFs0LCAyXSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyYXlzKTtcbiAgICAgIC8vIHRoaXMuX3J0RGVidWdNZXNoID0gbWVzaDtcbiAgICAgIC8vIGF3YWl0IHRoaXMuX2ZyYW1lKDE2KTtcbiAgICAgIC8vIHJheXMuc2xpY2UoMCwgMSkuZm9yRWFjaChyYXkgPT4gZGVidWdSYXkocmF5LCB0aGlzLl9ydE1hbmFnZXIuYnZoLCB0aGlzLl9ydE1hbmFnZXIuZ0J1ZmZlck1lc2guZ2VvbWV0cnkuZ2V0VmFsdWVzKCdwb3NpdGlvbicpLmNwdSBhcyBGbG9hdDMyQXJyYXkpKTtcbiAgICAvLyB9KVxuXG4gICAgLy8gZGVidWdSYXlTaGFkb3dzKHJheXMuZmlsdGVyKHJheSA9PiByYXkub3JpZ2luWzNdKS5zbGljZSgwLCAxKSwgdGhpcy5fcnRNYW5hZ2VyLmJ2aCwgdGhpcy5fcnRNYW5hZ2VyLmdCdWZmZXJNZXNoLmdlb21ldHJ5LmdldFZhbHVlcygncG9zaXRpb24nKS5jcHUgYXMgRmxvYXQzMkFycmF5KTtcbiAgICAvLyBjb25zdCB7cmF5cywgbWVzaH0gPSBhd2FpdCB0aGlzLl9ydERlYnVnSW5mby5zaG93RGVidWdJbmZvKFsxNjAsIDM2MF0sIFsyMDAsIDQwMF0pO1xuICAgIC8vIGNvbnNvbGUubG9nKHJheXMpXG4gICAgLy8gZGVidWdSYXlTaGFkb3dzKHJheXMuZmlsdGVyKHJheSA9PiByYXkub3JpZ2luWzNdKS5zbGljZSgwLCAxKSwgdGhpcy5fcnRNYW5hZ2VyLmJ2aCwgdGhpcy5fcnRNYW5hZ2VyLmdCdWZmZXJNZXNoLmdlb21ldHJ5LmdldFZhbHVlcygncG9zaXRpb24nKS5jcHUgYXMgRmxvYXQzMkFycmF5KTtcbiAgICAvLyB0aGlzLl9ydERlYnVnTWVzaCA9IG1lc2g7XG4gICAgLy8gcmF5cy5mb3JFYWNoKHJheSA9PiBkZWJ1Z1JheShyYXksIHRoaXMuX3J0TWFuYWdlci5idmgsIHRoaXMuX3J0TWFuYWdlci5nQnVmZmVyTWVzaC5nZW9tZXRyeS5nZXRWYWx1ZXMoJ3Bvc2l0aW9uJykuY3B1IGFzIEZsb2F0MzJBcnJheSkpO1xuICAgIC8vIGF3YWl0IHRoaXMuX2ZyYW1lKCk7XG5cbiAgICAvLyBhd2FpdCB0aGlzLl9mcmFtZSgxNik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXBkYXRlKGR0OiBudW1iZXIpIHtcbiAgICBhd2FpdCB0aGlzLl9mcmFtZShkdCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9mcmFtZShkdDogbnVtYmVyKSB7XG4gICAgY29uc3Qge19zY2VuZX0gPSB0aGlzO1xuICAgIHRoaXMuX2ZyYW1lQ291bnQgKz0gMTtcbiAgICBjb25zdCBwcmVXZWlnaHQgPSAodGhpcy5fZnJhbWVDb3VudCAtIDEpIC8gdGhpcy5fZnJhbWVDb3VudDtcblxuICAgIGlmIChwcmVXZWlnaHQgPiAuOTk5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3NjZW5lLnN0YXJ0RnJhbWUoZHQpO1xuICAgIFxuICAgIGNvbnN0IGZpcnN0ID0gIXRoaXMuX3J0TWFuYWdlcjtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHRoaXMuX3J0TWFuYWdlciA9IG5ldyBILlJheVRyYWNpbmdNYW5hZ2VyKCk7XG4gICAgICB0aGlzLl9ydE1hbmFnZXIucHJvY2Vzcyh0aGlzLl9zY2VuZS5jdWxsQ2FtZXJhKHRoaXMuX2NhbWVyYSksIHRoaXMuX3J0T3V0cHV0KTtcbiAgICAgIHRoaXMuX3J0TWFuYWdlci5ydFVuaXQuc2V0VW5pZm9ybSgndV9ub2lzZScsIHRoaXMuX25vaXNlVGV4KTtcbiAgICAgIHRoaXMuX2Nvbm5lY3RHQnVmZmVyUmVuZGVyVGV4dHVyZSh0aGlzLl9ydE1hbmFnZXIucnRVbml0KTtcbiAgICAgIC8vIHRoaXMuX3J0RGVidWdJbmZvLnNldHVwKHRoaXMuX3J0TWFuYWdlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcnRNYW5hZ2VyLnJ0VW5pdC5zZXRVbmlmb3JtKCd1X3JhbmRvbXMnLCBuZXcgRmxvYXQzMkFycmF5KDE2KS5tYXAodiA9PiBNYXRoLnJhbmRvbSgpKSk7XG4gICAgdGhpcy5fZGVub2lzZVRlbXBvclVuaXQuc2V0VW5pZm9ybSgndV9wcmVXZWlnaHQnLCBuZXcgRmxvYXQzMkFycmF5KFtwcmVXZWlnaHRdKSk7XG5cbiAgICBpZiAodGhpcy5fdmlld01vZGUgPT09ICdidmgnKSB7XG4gICAgICB0aGlzLl9zaG93QlZIKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl92aWV3TW9kZSA9PT0gJ2didWZmZXInKSB7XG4gICAgICB0aGlzLl9yZW5kZXJHQnVmZmVyKCk7XG4gICAgICB0aGlzLl9zaG93R0J1ZmZlclJlc3VsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJHQnVmZmVyKCk7XG4gICAgICB0aGlzLl9zY2VuZS5zZXRSZW5kZXJUYXJnZXQobnVsbCk7ICBcbiAgICAgIHRoaXMuX2NvbXB1dGVSVFNTKCk7XG5cbiAgICAgIGlmICh0aGlzLl92aWV3TW9kZSA9PT0gJ3Jlc3VsdCcpIHtcbiAgICAgICAgdGhpcy5fY29tcHV0ZURlbm9pc2UoKTtcbiAgICAgICAgdGhpcy5fcnRCbGl0Lm1hdGVyaWFsLnNldFVuaWZvcm0oJ3VfdGV4dHVyZScsIHRoaXMuX2Rlbm9pc2VSVHMuZmluYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcnRCbGl0Lm1hdGVyaWFsLnNldFVuaWZvcm0oJ3VfdGV4dHVyZScsIHRoaXMuX3J0T3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2NlbmUucmVuZGVySW1hZ2VzKFt0aGlzLl9ydEJsaXRdKTtcbiAgICB9XG4gICAgXG5cbiAgICAvLyBpZiAoZmlyc3QpIHtcbiAgICAvLyAgIHRoaXMuX3J0RGVidWdJbmZvLnJ1bihfc2NlbmUpO1xuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLl9ydERlYnVnTWVzaCkge1xuICAgICAgX3NjZW5lLnJlbmRlckNhbWVyYSh0aGlzLl9jYW1lcmEsIFt0aGlzLl9ydERlYnVnTWVzaF0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfc2NlbmUuZW5kRnJhbWUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlbmRlckdCdWZmZXIoKSB7XG4gICAgdGhpcy5fc2NlbmUuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuX2dCdWZmZXJSVCk7XG4gICAgY29uc3QgbGlnaHRNZXNoZXMgPSB0aGlzLl9zY2VuZS5saWdodHMubWFwKGxpZ2h0ID0+IGxpZ2h0LnJlcXVpcmVMaWdodE1lc2godGhpcy5fZ2J1ZmZlckxpZ2h0TWF0ZXJpYWwpKS5maWx0ZXIobSA9PiAhIW0pO1xuICAgIHRoaXMuX3NjZW5lLnJlbmRlckNhbWVyYSh0aGlzLl9jYW1lcmEsIFtcbiAgICAgIHRoaXMuX3J0TWFuYWdlci5nQnVmZmVyTWVzaCxcbiAgICAgIC4uLmxpZ2h0TWVzaGVzXG4gICAgXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXB1dGVSVFNTKCkge1xuICAgIHRoaXMuX3NjZW5lLmNvbXB1dGVVbml0cyhbdGhpcy5fcnRNYW5hZ2VyLnJ0VW5pdF0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wdXRlRGVub2lzZSgpIHtcbiAgICBjb25zdCB7Y3VycmVudCwgcHJlfSA9IHRoaXMuX2Rlbm9pc2VSVHM7XG4gICAgdGhpcy5fZGVub2lzZVRlbXBvclVuaXQuc2V0VW5pZm9ybSgndV9vdXRwdXQnLCBjdXJyZW50KTtcbiAgICB0aGlzLl9kZW5vaXNlVGVtcG9yVW5pdC5zZXRVbmlmb3JtKCd1X3ByZScsIHByZSk7XG4gICAgdGhpcy5fZGVub2lzZVRlbXBvclVuaXQuc2V0VW5pZm9ybSgndV9jdXJyZW50JywgdGhpcy5fcnRPdXRwdXQpO1xuXG4gICAgdGhpcy5fZGVub2lzZVNwYWNlVW5pdC5zZXRVbmlmb3JtKCd1X21peGVkJywgY3VycmVudCk7XG5cbiAgICB0aGlzLl9zY2VuZS5jb21wdXRlVW5pdHMoW3RoaXMuX2Rlbm9pc2VUZW1wb3JVbml0LCB0aGlzLl9kZW5vaXNlU3BhY2VVbml0XSk7XG5cbiAgICB0aGlzLl9kZW5vaXNlUlRzLmN1cnJlbnQgPSBwcmU7XG4gICAgdGhpcy5fZGVub2lzZVJUcy5wcmUgPSBjdXJyZW50O1xuICB9XG5cbiAgcHJpdmF0ZSBfc2hvd0dCdWZmZXJSZXN1bHQoKSB7XG4gICAgdGhpcy5fc2NlbmUuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgIHRoaXMuX3NjZW5lLnJlbmRlckltYWdlcyhbdGhpcy5fZ0J1ZmZlckRlYnVnTWVzaF0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2hvd0JWSCgpIHtcbiAgICB0aGlzLl9zY2VuZS5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgdGhpcy5fc2NlbmUucmVuZGVyQ2FtZXJhKHRoaXMuX2NhbWVyYSwgW1xuICAgICAgLi4udGhpcy5fc2NlbmUuY3VsbENhbWVyYSh0aGlzLl9jYW1lcmEpLFxuICAgICAgdGhpcy5fcnRNYW5hZ2VyLmJ2aERlYnVnTWVzaFxuICAgIF0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29ubmVjdEdCdWZmZXJSZW5kZXJUZXh0dXJlKG1hdGVyaWFsOiBILk1hdGVyaWFsIHwgSC5Db21wdXRlVW5pdCkge1xuICAgIG1hdGVyaWFsLnNldFVuaWZvcm0oJ3VfZ2JQb3NpdGlvbk1ldGFsT3JTcGVjJywgdGhpcy5fZ0J1ZmZlclJULCAncG9zaXRpb25NZXRhbE9yU3BlYycpO1xuICAgIG1hdGVyaWFsLnNldFVuaWZvcm0oJ3VfZ2JCYXNlQ29sb3JSb3VnaE9yR2xvc3MnLCB0aGlzLl9nQnVmZmVyUlQsICdiYXNlQ29sb3JSb3VnaE9yR2xvc3MnKTtcbiAgICBtYXRlcmlhbC5zZXRVbmlmb3JtKCd1X2diTm9ybWFsR2xhc3MnLCB0aGlzLl9nQnVmZmVyUlQsICdub3JtYWxHbGFzcycpO1xuICAgIG1hdGVyaWFsLnNldFVuaWZvcm0oJ3VfZ2JNZXNoSW5kZXhNYXRJbmRleE1hdFR5cGUnLCB0aGlzLl9nQnVmZmVyUlQsICdtZXNoSW5kZXhNYXRJbmRleE1hdFR5cGUnKTtcbiAgfVxufVxuIl19

/***/ }),

/***/ "./demo/debugCs.ts":
/*!*************************!*\
  !*** ./demo/debugCs.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sampleCircle = exports.debugRayShadow = exports.debugRayShadows = exports.debugRay = exports.DebugInfo = void 0;
var H = __webpack_require__(/*! ../src */ "./src/index.ts");
var DebugInfo = (function () {
    function DebugInfo() {
    }
    DebugInfo.prototype.setup = function (rtManager) {
        var renderEnv = H.renderEnv;
        var size = this._size = 4 * 7;
        this._cpu = new Float32Array(size * renderEnv.width * renderEnv.height);
        this._gpu = H.createGPUBuffer(this._cpu, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        this._view = H.createGPUBufferBySize(size * renderEnv.width * renderEnv.height * 4, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
        this._rtManager = rtManager;
        this._rtManager.rtUnit.setUniform('u_debugInfo', this._cpu, this._gpu);
    };
    DebugInfo.prototype.run = function (scene) {
        scene.copyBuffer(this._gpu, this._view, this._cpu.byteLength);
    };
    DebugInfo.prototype.showDebugInfo = function (point1, len, step) {
        return __awaiter(this, void 0, void 0, function () {
            var data, rays, positions, colors, indexes, geometry, material, mesh;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this._view.mapAsync(GPUMapMode.READ)];
                    case 1:
                        _a.sent();
                        data = new Float32Array(this._view.getMappedRange());
                        rays = this._decodeDebugInfo(data, point1, len, step);
                        positions = new Float32Array(rays.length * 6 * 3);
                        colors = new Float32Array(rays.length * 6 * 3);
                        indexes = new Uint32Array(rays.length * 6);
                        rays.forEach(function (_a, index) {
                            var preOrigin = _a.preOrigin, preDir = _a.preDir, origin = _a.origin, dir = _a.dir, nextOrigin = _a.nextOrigin, nextDir = _a.nextDir;
                            var po = index * 3 * 6;
                            var io = index * 6;
                            positions.set(preOrigin.slice(0, 3), po);
                            positions.set(preDir.slice(0, 3), po + 3);
                            colors.set([1, 0, 0], po);
                            colors.set([1, 0, 0], po + 3);
                            positions.set(origin.slice(0, 3), po + 6);
                            positions.set(dir.slice(0, 3), po + 9);
                            colors.set([0, 1, 0], po + 6);
                            colors.set([0, 1, 0], po + 9);
                            positions.set(nextOrigin.slice(0, 3), po + 12);
                            positions.set(nextDir.slice(0, 3), po + 15);
                            colors.set([0, 0, 1], po + 12);
                            colors.set([0, 0, 1], po + 15);
                            indexes.set([index * 3, index * 3 + 1, index * 3 + 2, index * 3 + 3, index * 3 + 4, index * 3 + 5], io);
                        });
                        geometry = new H.Geometry([
                            {
                                layout: {
                                    arrayStride: 3 * 4,
                                    attributes: [{
                                            name: 'position',
                                            shaderLocation: 0,
                                            offset: 0,
                                            format: 'float32x3'
                                        }],
                                },
                                data: positions
                            },
                            {
                                layout: {
                                    arrayStride: 3 * 4,
                                    attributes: [{
                                            name: 'color_0',
                                            shaderLocation: 1,
                                            offset: 0,
                                            format: 'float32x3'
                                        }],
                                },
                                data: colors
                            }
                        ], indexes, rays.length * 6);
                        material = new H.Material(H.buildinEffects.rColor, { u_color: new Float32Array([1, 1, 1]) }, undefined, { cullMode: 'none', primitiveType: 'line-list', depthCompare: 'always' });
                        mesh = new H.Mesh(geometry, material);
                        this._view.unmap();
                        return [2, { rays: rays, mesh: mesh }];
                }
            });
        });
    };
    DebugInfo.prototype._decodeDebugInfo = function (view, point1, len, step) {
        var res = [];
        var logs = [];
        for (var y = point1[1]; y < point1[1] + len[1] * step[1]; y += step[1]) {
            for (var x = point1[0]; x < point1[0] + len[0] * step[0]; x += step[0]) {
                var index = y * H.renderEnv.width + x;
                var offset = index * this._size;
                res.push({
                    preOrigin: view.slice(offset, offset + 4),
                    preDir: view.slice(offset + 4, offset + 8),
                    origin: view.slice(offset + 8, offset + 12),
                    dir: view.slice(offset + 12, offset + 16),
                    nextOrigin: view.slice(offset + 16, offset + 20),
                    nextDir: view.slice(offset + 20, offset + 24),
                    normal: view.slice(offset + 24, offset + 28)
                });
            }
        }
        console.log(logs.join('\n'));
        return res;
    };
    return DebugInfo;
}());
exports.DebugInfo = DebugInfo;
var plotS = [];
function debugRay(rayInfo, bvh, positions) {
    var ray = {
        origin: rayInfo.origin,
        dir: rayInfo.dir,
        invDir: new Float32Array(3)
    };
    H.math.vec3.div(ray.invDir, new Float32Array([1, 1, 1]), ray.dir);
    console.log('ray info', rayInfo);
    console.log('ray', ray);
    var fragInfo = hitTest(bvh, ray, positions);
    console.log(fragInfo);
}
exports.debugRay = debugRay;
function debugRayShadows(rayInfos, bvh, positions) {
    plotS = [];
    rayInfos.forEach(function (ray) { return debugRayShadow(ray, bvh, positions); });
    console.log('Show[\n' + plotS.join(',\n') + '\n]');
}
exports.debugRayShadows = debugRayShadows;
function debugRayShadow(rayInfo, bvh, positions) {
    var ray = {
        origin: rayInfo.origin,
        dir: rayInfo.dir,
        invDir: new Float32Array(3)
    };
    H.math.vec3.div(ray.invDir, new Float32Array([1, 1, 1]), ray.dir);
    var maxT = rayInfo.dir[3];
    console.log('rayInfo', rayInfo);
    console.log('ray maxT', ray, maxT);
    console.log(ray.origin.map(function (v, i) { return v + ray.dir[i] * maxT; }));
    plotS.push("ParametricPlot3D[{" + ray.dir[0] + "t + " + ray.origin[0] + ", " + ray.dir[1] + "t + " + ray.origin[1] + ", " + ray.dir[2] + "t + " + ray.origin[2] + "}, {t, 0, " + maxT + "}]");
    var fragInfo = hitTestShadow(bvh, ray, rayInfo.preOrigin[0], positions);
    console.log(fragInfo);
}
exports.debugRayShadow = debugRayShadow;
function sampleCircle(pi) {
    var p = [2.0 * pi[0] - 1.0, 2.0 * pi[1] - 1.0,];
    console.log('start', pi.slice(0, 2), p);
    var greater = Math.abs(p[0]) > Math.abs(p[1]);
    var r;
    var theta;
    if (greater) {
        r = p[0];
        theta = 0.25 * Math.PI * p[1] / p[0];
    }
    else {
        r = p[1];
        theta = Math.PI * (0.5 - 0.25 * p[0] / p[1]);
    }
    var x = r * Math.cos(theta);
    var y = r * Math.sin(theta);
    console.log(r, theta, Math.cos(theta), Math.sin(theta));
    console.log(x, y, Math.sqrt(1 - x * x - y * y));
}
exports.sampleCircle = sampleCircle;
var EPS = 0.005;
;
;
;
;
function boxHitTest(ray, max, min) {
    var t1 = H.math.vec3.sub(new Float32Array(3), min, ray.origin);
    H.math.vec3.mul(t1, t1, ray.invDir);
    var t2 = H.math.vec3.sub(new Float32Array(3), max, ray.origin);
    H.math.vec3.mul(t2, t2, ray.invDir);
    var tvmin = H.math.vec3.min(new Float32Array(3), t1, t2);
    var tvmax = H.math.vec3.max(new Float32Array(3), t1, t2);
    var tmin = Math.max(tvmin[0], Math.max(tvmin[1], tvmin[2]));
    var tmax = Math.min(tvmax[0], Math.min(tvmax[1], tvmax[2]));
    if (tmax - tmin < -EPS) {
        return -1.;
    }
    if (tmin > -EPS) {
        return tmin + EPS;
    }
    return tmax + EPS;
}
function decodeChild(index) {
    return {
        isLeaf: (index >> 31) !== 0,
        offset: (index << 1) >> 1,
    };
}
function getBVHNodeInfo(bvh, index) {
    var realOffset = index * 4;
    var data0 = bvh.buffer.slice(realOffset, realOffset + 4);
    var data1 = bvh.buffer.slice(realOffset + 4, realOffset + 8);
    var child0 = new Uint32Array(data0.buffer, 0, 1)[0];
    var child1 = new Uint32Array(data1.buffer, 0, 1)[0];
    return {
        child0Index: child0,
        child1Index: child1,
        min: data0.slice(1),
        max: data1.slice(1)
    };
}
function hitTest(bvh, ray, positions) {
    var fragInfo = {
        hit: false,
        t: Infinity,
        hitPoint: null,
        weights: null
    };
    var nodeStack = Array(bvh.maxDepth);
    nodeStack[0] = 0;
    var stackDepth = 0;
    while (stackDepth >= 0) {
        var _a = decodeChild(nodeStack[stackDepth]), isLeaf = _a.isLeaf, offset = _a.offset;
        stackDepth -= 1;
        if (isLeaf) {
            var info = leafHitTest(bvh, ray, positions, offset);
            console.log('leaf hit', info.hit && info.t < fragInfo.t);
            if (info.hit && info.t < fragInfo.t) {
                fragInfo = info;
            }
            continue;
        }
        var node = getBVHNodeInfo(bvh, offset);
        var hited = boxHitTest(ray, node.max, node.min);
        console.log('box hit', offset, node, hited, !(hited < 0 || hited > fragInfo.t));
        if (hited < 0) {
            continue;
        }
        stackDepth += 1;
        nodeStack[stackDepth] = node.child0Index;
        stackDepth += 1;
        nodeStack[stackDepth] = node.child1Index;
    }
    return fragInfo;
}
function getBVHLeafInfo(bvh, offset) {
    var realOffset = offset * 4;
    var data = new Uint32Array(bvh.buffer.buffer, realOffset * 4, 4);
    return {
        primitives: data[0],
        indexes: data.slice(1)
    };
}
function triangleHitTest(ray, leaf, positions) {
    var info = {
        hit: false,
        t: Infinity,
        hitPoint: null,
        weights: null
    };
    var indexes = leaf.indexes;
    var p0 = positions.slice(indexes[0] * 4, indexes[0] * 4 + 4);
    var p1 = positions.slice(indexes[1] * 4, indexes[1] * 4 + 4);
    var p2 = positions.slice(indexes[2] * 4, indexes[2] * 4 + 4);
    var e0 = H.math.vec3.sub(new Float32Array(3), p1, p0);
    var e1 = H.math.vec3.sub(new Float32Array(3), p2, p0);
    var p = H.math.vec3.cross(new Float32Array(3), ray.dir, e1);
    var det = H.math.vec3.dot(e0, p);
    var t = H.math.vec3.sub(new Float32Array(3), ray.origin, p0);
    if (det < 0) {
        H.math.vec3.scale(t, t, -1);
        det = -det;
    }
    if (det < 0.0001) {
        return info;
    }
    var u = H.math.vec3.dot(t, p);
    if (u < 0. || u > det) {
        return info;
    }
    var q = H.math.vec3.cross(new Float32Array(3), t, e0);
    var v = H.math.vec3.dot(ray.dir, q);
    if (v < 0 || v + u - det > 0) {
        return info;
    }
    var lt = H.math.vec3.dot(e1, q);
    if (lt < 0.) {
        return info;
    }
    var invDet = 1. / det;
    var hitPoint = H.math.vec3.add(new Float32Array(3), ray.origin, H.math.vec3.scale(new Float32Array(3), ray.dir, lt * invDet));
    var weights = H.math.vec3.scale(new Float32Array(3), new Float32Array([0., u, v]), invDet);
    weights[0] = 1. - weights[1] - weights[2];
    info.hit = true;
    info.weights = weights;
    info.hitPoint = hitPoint;
    info.t = lt * invDet;
    return info;
}
function leafHitTest(bvh, ray, positions, offset) {
    var leaf = getBVHLeafInfo(bvh, offset);
    var info = {
        hit: false,
        t: Infinity,
        hitPoint: null,
        weights: null
    };
    console.log(new Uint32Array([(offset + 0) | 0x80000000])[0], leaf);
    for (var i = 0; i < leaf.primitives; i = i + 1) {
        leaf = getBVHLeafInfo(bvh, offset + i);
        var cInfo = triangleHitTest(ray, leaf, positions);
        console.log('triangle hit', new Uint32Array([(offset + i) | 0x80000000])[0], cInfo, cInfo.hit && cInfo.t < info.t);
        if (cInfo.hit && cInfo.t < info.t) {
            info = cInfo;
        }
    }
    return info;
}
function hitTestShadow(bvh, ray, maxT, positions) {
    var fragInfo = {
        hit: false,
        t: maxT,
        hitPoint: null,
        weights: null
    };
    var nodeStack = Array(bvh.maxDepth);
    nodeStack[0] = 0;
    var stackDepth = 0;
    while (stackDepth >= 0) {
        var _a = decodeChild(nodeStack[stackDepth]), isLeaf = _a.isLeaf, offset = _a.offset;
        stackDepth -= 1;
        if (isLeaf) {
            var info = leafHitTest(bvh, ray, positions, offset);
            console.log('leaf hit', info.hit);
            if (info.hit && info.t < maxT) {
                return info;
            }
            continue;
        }
        var node = getBVHNodeInfo(bvh, offset);
        var hited = boxHitTest(ray, node.max, node.min);
        console.log('box hit', offset, node.child0Index, node.child1Index, node.max, node.min, hited);
        if (hited < 0) {
            continue;
        }
        stackDepth += 1;
        nodeStack[stackDepth] = node.child0Index;
        stackDepth += 1;
        nodeStack[stackDepth] = node.child1Index;
    }
    return fragInfo;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdDcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlYnVnQ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0EsMEJBQTRCO0FBYTVCO0lBQUE7SUF3SUEsQ0FBQztJQWpJUSx5QkFBSyxHQUFaLFVBQWEsU0FBOEI7UUFDbEMsSUFBQSxTQUFTLEdBQUksQ0FBQyxVQUFMLENBQU07UUFDdEIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWhDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hFLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNGLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXZJLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1FBQzVCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDeEUsQ0FBQztJQUVNLHVCQUFHLEdBQVYsVUFBVyxLQUFjO1FBQ3ZCLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVZLGlDQUFhLEdBQTFCLFVBQ0UsTUFBd0IsRUFDeEIsR0FBcUIsRUFDckIsSUFBc0I7Ozs7OzRCQUt0QixXQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBQTs7d0JBQTFDLFNBQTBDLENBQUM7d0JBQ3JDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7d0JBQ3JELElBQUksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7d0JBRXRELFNBQVMsR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzt3QkFDbEQsTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3dCQUMvQyxPQUFPLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQzt3QkFFakQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQXFELEVBQUUsS0FBSztnQ0FBM0QsU0FBUyxlQUFBLEVBQUUsTUFBTSxZQUFBLEVBQUUsTUFBTSxZQUFBLEVBQUUsR0FBRyxTQUFBLEVBQUUsVUFBVSxnQkFBQSxFQUFFLE9BQU8sYUFBQTs0QkFDaEUsSUFBTSxFQUFFLEdBQUcsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7NEJBQ3pCLElBQU0sRUFBRSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7NEJBRXJCLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7NEJBQ3pDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUMxQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQzs0QkFDMUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUM5QixTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDMUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQ3ZDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDOUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUM5QixTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQzs0QkFDL0MsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7NEJBQzVDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FB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Q0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDdEQsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN0RCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1RCxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRTdELElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtRQUNYLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUIsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDO0tBQ1o7SUFFRCxJQUFJLEdBQUcsR0FBRyxNQUFNLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFOUIsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFLcEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBRTtRQUM1QixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUVoQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsSUFBSSxNQUFNLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztJQUN0QixJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQzVCLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEVBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FDN0MsQ0FBQztJQUNsQixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFpQixD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LENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFO2dCQUM3QixPQUFPLElBQUksQ0FBQzthQUNiO1lBRUQsU0FBUztTQUNWO1FBRUQsSUFBTSxJQUFJLEdBQUcsY0FBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN6QyxJQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxELE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTlGLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtZQUNiLFNBQVM7U0FDVjtRQUVELFVBQVUsSUFBSSxDQUFDLENBQUM7UUFDaEIsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDekMsVUFBVSxJQUFJLENBQUMsQ0FBQztRQUNoQixTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztLQUMxQztJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBkZWJ1Z0NTLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDYvMjYvMjAyMSwgNzo0MDozMiBQTVxuICovXG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCAqIGFzIEggZnJvbSAnLi4vc3JjJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uL3NyYy9leHRlbnNpb24vQlZIJztcblxuaW50ZXJmYWNlIElEZWJ1Z1BpeGVsIHtcbiAgcHJlT3JpZ2luOiBGbG9hdDMyQXJyYXk7XG4gIHByZURpcjogRmxvYXQzMkFycmF5O1xuICBvcmlnaW46IEZsb2F0MzJBcnJheTtcbiAgZGlyOiBGbG9hdDMyQXJyYXk7XG4gIG5leHRPcmlnaW46IEZsb2F0MzJBcnJheTtcbiAgbmV4dERpcjogRmxvYXQzMkFycmF5O1xuICBub3JtYWw6IEZsb2F0MzJBcnJheTtcbn1cblxuZXhwb3J0IGNsYXNzIERlYnVnSW5mbyB7XG4gIHByb3RlY3RlZCBfY3B1OiBGbG9hdDMyQXJyYXk7XG4gIHByb3RlY3RlZCBfZ3B1OiBHUFVCdWZmZXI7XG4gIHByb3RlY3RlZCBfdmlldzogR1BVQnVmZmVyO1xuICBwcm90ZWN0ZWQgX3NpemU6IG51bWJlcjtcbiAgcHJvdGVjdGVkIF9ydE1hbmFnZXI6IEguUmF5VHJhY2luZ01hbmFnZXJcblxuICBwdWJsaWMgc2V0dXAocnRNYW5hZ2VyOiBILlJheVRyYWNpbmdNYW5hZ2VyKSB7XG4gICAgY29uc3Qge3JlbmRlckVudn0gPSBIO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gNCAqIDc7XG5cbiAgICB0aGlzLl9jcHUgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiByZW5kZXJFbnYud2lkdGggKiByZW5kZXJFbnYuaGVpZ2h0KTtcbiAgICB0aGlzLl9ncHUgPSBILmNyZWF0ZUdQVUJ1ZmZlcih0aGlzLl9jcHUsIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyk7XG4gICAgdGhpcy5fdmlldyA9IEguY3JlYXRlR1BVQnVmZmVyQnlTaXplKHNpemUgKiByZW5kZXJFbnYud2lkdGggKiByZW5kZXJFbnYuaGVpZ2h0ICogNCwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk7XG5cbiAgICB0aGlzLl9ydE1hbmFnZXIgPSBydE1hbmFnZXI7XG4gICAgdGhpcy5fcnRNYW5hZ2VyLnJ0VW5pdC5zZXRVbmlmb3JtKCd1X2RlYnVnSW5mbycsIHRoaXMuX2NwdSwgdGhpcy5fZ3B1KVxuICB9XG5cbiAgcHVibGljIHJ1bihzY2VuZTogSC5TY2VuZSkge1xuICAgIHNjZW5lLmNvcHlCdWZmZXIodGhpcy5fZ3B1LCB0aGlzLl92aWV3LCB0aGlzLl9jcHUuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2hvd0RlYnVnSW5mbyhcbiAgICBwb2ludDE6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgbGVuOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIHN0ZXA6IFtudW1iZXIsIG51bWJlcl1cbiAgKTogUHJvbWlzZTx7XG4gICAgcmF5czogSURlYnVnUGl4ZWxbXSxcbiAgICBtZXNoOiBILk1lc2hcbiAgfT4ge1xuICAgIGF3YWl0IHRoaXMuX3ZpZXcubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl92aWV3LmdldE1hcHBlZFJhbmdlKCkpO1xuICAgIGNvbnN0IHJheXMgPSB0aGlzLl9kZWNvZGVEZWJ1Z0luZm8oZGF0YSwgcG9pbnQxLCBsZW4sIHN0ZXApO1xuXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShyYXlzLmxlbmd0aCAqIDYgKiAzKTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHJheXMubGVuZ3RoICogNiAqIDMpO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgVWludDMyQXJyYXkocmF5cy5sZW5ndGggKiA2KTtcblxuICAgIHJheXMuZm9yRWFjaCgoe3ByZU9yaWdpbiwgcHJlRGlyLCBvcmlnaW4sIGRpciwgbmV4dE9yaWdpbiwgbmV4dERpcn0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwbyA9IGluZGV4ICogMyAqIDY7XG4gICAgICBjb25zdCBpbyA9IGluZGV4ICogNjtcblxuICAgICAgcG9zaXRpb25zLnNldChwcmVPcmlnaW4uc2xpY2UoMCwgMyksIHBvKTtcbiAgICAgIHBvc2l0aW9ucy5zZXQocHJlRGlyLnNsaWNlKDAsIDMpLCBwbyArIDMpO1xuICAgICAgY29sb3JzLnNldChbMSwgMCwgMF0sIHBvKTtcbiAgICAgIGNvbG9ycy5zZXQoWzEsIDAsIDBdLCBwbyArIDMpO1xuICAgICAgcG9zaXRpb25zLnNldChvcmlnaW4uc2xpY2UoMCwgMyksIHBvICsgNik7XG4gICAgICBwb3NpdGlvbnMuc2V0KGRpci5zbGljZSgwLCAzKSwgcG8gKyA5KTtcbiAgICAgIGNvbG9ycy5zZXQoWzAsIDEsIDBdLCBwbyArIDYpO1xuICAgICAgY29sb3JzLnNldChbMCwgMSwgMF0sIHBvICsgOSk7XG4gICAgICBwb3NpdGlvbnMuc2V0KG5leHRPcmlnaW4uc2xpY2UoMCwgMyksIHBvICsgMTIpO1xuICAgICAgcG9zaXRpb25zLnNldChuZXh0RGlyLnNsaWNlKDAsIDMpLCBwbyArIDE1KTtcbiAgICAgIGNvbG9ycy5zZXQoWzAsIDAsIDFdLCBwbyArIDEyKTtcbiAgICAgIGNvbG9ycy5zZXQoWzAsIDAsIDFdLCBwbyArIDE1KTtcbiAgICAgIGluZGV4ZXMuc2V0KFtpbmRleCAqIDMsIGluZGV4ICogMyArIDEsIGluZGV4ICogMyArIDIsIGluZGV4ICogMyArIDMsIGluZGV4ICogMyArIDQsIGluZGV4ICogMyArIDVdLCBpbyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBILkdlb21ldHJ5KFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBhcnJheVN0cmlkZTogMyAqIDQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogMCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICBmb3JtYXQ6ICdmbG9hdDMyeDMnXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGE6IHBvc2l0aW9uc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBhcnJheVN0cmlkZTogMyAqIDQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgICBuYW1lOiAnY29sb3JfMCcsXG4gICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAxLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGZvcm1hdDogJ2Zsb2F0MzJ4MydcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogY29sb3JzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBpbmRleGVzLFxuICAgICAgcmF5cy5sZW5ndGggKiA2XG4gICAgKTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBILk1hdGVyaWFsKFxuICAgICAgSC5idWlsZGluRWZmZWN0cy5yQ29sb3IsXG4gICAgICB7dV9jb2xvcjogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pfSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHtjdWxsTW9kZTogJ25vbmUnLCBwcmltaXRpdmVUeXBlOiAnbGluZS1saXN0JywgZGVwdGhDb21wYXJlOiAnYWx3YXlzJ31cbiAgICApO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgSC5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cbiAgICB0aGlzLl92aWV3LnVubWFwKCk7XG5cbiAgICByZXR1cm4ge3JheXMsIG1lc2h9O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9kZWNvZGVEZWJ1Z0luZm8oXG4gICAgdmlldzogRmxvYXQzMkFycmF5LFxuICAgIHBvaW50MTogW251bWJlciwgbnVtYmVyXSxcbiAgICBsZW46IFtudW1iZXIsIG51bWJlcl0sXG4gICAgc3RlcDogW251bWJlciwgbnVtYmVyXVxuICApIHtcbiAgICBjb25zdCByZXM6IElEZWJ1Z1BpeGVsW10gPSBbXTtcbiAgICBjb25zdCBsb2dzID0gW107XG5cbiAgICBmb3IgKGxldCB5ID0gcG9pbnQxWzFdOyB5IDwgcG9pbnQxWzFdICsgbGVuWzFdICogc3RlcFsxXTsgeSArPSBzdGVwWzFdKSB7XG4gICAgICBmb3IgKGxldCB4ID0gcG9pbnQxWzBdOyB4IDwgIHBvaW50MVswXSArIGxlblswXSAqIHN0ZXBbMF07IHggKz0gc3RlcFswXSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHkgKiBILnJlbmRlckVudi53aWR0aCArIHg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5fc2l6ZTtcbiAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgIHByZU9yaWdpbjogdmlldy5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLFxuICAgICAgICAgIHByZURpcjogdmlldy5zbGljZShvZmZzZXQgKyA0LCBvZmZzZXQgKyA4KSxcbiAgICAgICAgICBvcmlnaW46IHZpZXcuc2xpY2Uob2Zmc2V0ICsgOCwgb2Zmc2V0ICsgMTIpLFxuICAgICAgICAgIGRpcjogdmlldy5zbGljZShvZmZzZXQgKyAxMiwgb2Zmc2V0ICsgMTYpLFxuICAgICAgICAgIG5leHRPcmlnaW46IHZpZXcuc2xpY2Uob2Zmc2V0ICsgMTYsIG9mZnNldCArIDIwKSxcbiAgICAgICAgICBuZXh0RGlyOiB2aWV3LnNsaWNlKG9mZnNldCArIDIwLCBvZmZzZXQgKyAyNCksXG4gICAgICAgICAgbm9ybWFsOiB2aWV3LnNsaWNlKG9mZnNldCArIDI0LCBvZmZzZXQgKyAyOClcbiAgICAgICAgfSBhcyBJRGVidWdQaXhlbCk7XG4gIFxuICAgICAgICAvLyBpZiAodmlld1tvZmZzZXQgKyAzXSkge1xuICAgICAgICAvLyAgIGxvZ3MucHVzaChgJ2hpdGVkJywgJHtbeCwgeV19LCAke1t2aWV3W29mZnNldCArIDE5XSwgdmlld1tvZmZzZXQgKyAyM11dfSwgJHt0aGlzLl9ydE1hbmFnZXIubWVzaGVzW3ZpZXdbb2Zmc2V0ICsgMTFdXS5uYW1lfSwgJHt2aWV3W29mZnNldCArIDE1XX0sICR7dGhpcy5fcnRNYW5hZ2VyLm1lc2hlc1t2aWV3W29mZnNldCArIDE5XV0ubmFtZX0sICR7dmlld1tvZmZzZXQgKyAyM119LCAke3ZpZXcuc2xpY2Uob2Zmc2V0ICsgMTYsIG9mZnNldCArIDE5KX1gKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBsb2dzLnB1c2goYCdub3QgaGl0ZWQnLCAke1t4LCB5XX0sICR7W3ZpZXdbb2Zmc2V0ICsgMTldLCB2aWV3W29mZnNldCArIDIzXV19LCAke3ZpZXdbb2Zmc2V0ICsgN119YCk7XG4gICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhsb2dzLmpvaW4oJ1xcbicpKTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxubGV0IHBsb3RTOiBzdHJpbmdbXSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdSYXkocmF5SW5mbzoge29yaWdpbjogRmxvYXQzMkFycmF5LCBkaXI6IEZsb2F0MzJBcnJheX0sIGJ2aDogSC5CVkgsIHBvc2l0aW9uczogRmxvYXQzMkFycmF5KSB7XG4gIGNvbnN0IHJheTogUmF5ID0ge1xuICAgIG9yaWdpbjogcmF5SW5mby5vcmlnaW4sXG4gICAgZGlyOiByYXlJbmZvLmRpcixcbiAgICBpbnZEaXI6IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgfTtcbiAgSC5tYXRoLnZlYzMuZGl2KHJheS5pbnZEaXIsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKSwgcmF5LmRpcik7XG5cbiAgY29uc29sZS5sb2coJ3JheSBpbmZvJywgcmF5SW5mbyk7XG4gIGNvbnNvbGUubG9nKCdyYXknLCByYXkpO1xuXG4gIGNvbnN0IGZyYWdJbmZvID0gaGl0VGVzdChidmgsIHJheSwgcG9zaXRpb25zKTtcbiAgY29uc29sZS5sb2coZnJhZ0luZm8pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdSYXlTaGFkb3dzKFxuICByYXlJbmZvczoge29yaWdpbjogRmxvYXQzMkFycmF5LCBkaXI6IEZsb2F0MzJBcnJheSwgcHJlT3JpZ2luOiBGbG9hdDMyQXJyYXl9W10sIGJ2aDogSC5CVkgsIHBvc2l0aW9uczogRmxvYXQzMkFycmF5XG4pIHtcbiAgcGxvdFMgPSBbXTtcbiAgcmF5SW5mb3MuZm9yRWFjaChyYXkgPT4gZGVidWdSYXlTaGFkb3cocmF5LCBidmgsIHBvc2l0aW9ucykpO1xuICBjb25zb2xlLmxvZygnU2hvd1tcXG4nICsgcGxvdFMuam9pbignLFxcbicpICsgJ1xcbl0nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnUmF5U2hhZG93KHJheUluZm86IHtvcmlnaW46IEZsb2F0MzJBcnJheSwgZGlyOiBGbG9hdDMyQXJyYXksIHByZU9yaWdpbjogRmxvYXQzMkFycmF5fSwgYnZoOiBILkJWSCwgcG9zaXRpb25zOiBGbG9hdDMyQXJyYXkpIHtcbiAgY29uc3QgcmF5OiBSYXkgPSB7XG4gICAgb3JpZ2luOiByYXlJbmZvLm9yaWdpbixcbiAgICBkaXI6IHJheUluZm8uZGlyLFxuICAgIGludkRpcjogbmV3IEZsb2F0MzJBcnJheSgzKVxuICB9O1xuICBILm1hdGgudmVjMy5kaXYocmF5LmludkRpciwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pLCByYXkuZGlyKTtcblxuICAvLyBmdW5jdGlvbiBSU0koY2VudGVyOiBhbnksIHJhZGl1czogbnVtYmVyKSB7XG4gIC8vICAgY29uc3QgcmVzOiBhbnlbXSA9IFtdO1xuXG4gIC8vICAgY29uc3QgcHN1YmMgPSB2ZWMzLnN1YihuZXcgRmxvYXQzMkFycmF5KDMpLCByYXkub3JpZ2luLCBjZW50ZXIpO1xuICAvLyAgIGNvbnN0IGRkb3Rwc3ViYyA9IHZlYzMuZG90KHJheS5kaXIsIHBzdWJjKTtcbiAgLy8gICBjb25zdCBkZXQgPSBNYXRoLnBvdyhkZG90cHN1YmMsIDIpIC0gdmVjMy5kb3QocHN1YmMsIHBzdWJjKSArIHJhZGl1cyAqIHJhZGl1cztcblxuICAvLyAgIGlmIChkZXQgPCAwKSB7XG4gIC8vICAgICByZXR1cm4gcmVzO1xuICAvLyAgIH1cblxuICAvLyAgIGNvbnN0IGQgPSB2ZWMzLmxlbmd0aChyYXkuZGlyKSAqIHZlYzMubGVuZ3RoKHJheS5kaXIpO1xuXG4gIC8vICAgY29uc3QgdHMgPSBbKC1kZG90cHN1YmMgKyBNYXRoLnNxcnQoZGV0KSkgLyBkLCAoLWRkb3Rwc3ViYyAtIE1hdGguc3FydChkZXQpKSAvIGRdO1xuXG4gIC8vICAgdHMuZm9yRWFjaCh0ID0+IHtcbiAgLy8gICAgIHJlcy5wdXNoKHQsIHZlYzMuc2NhbGVBbmRBZGQobmV3IEZsb2F0MzJBcnJheSgzKSwgcmF5Lm9yaWdpbiwgcmF5LmRpciwgdCkpO1xuICAvLyAgIH0pXG5cbiAgLy8gICByZXR1cm4gcmVzO1xuICAvLyB9XG5cbiAgLy8gY29uc3QgcnNpUG9pbnRzID0gUlNJKFsxLjcxLCAxLCA2LjA5XSwgMSk7XG4gIC8vIGNvbnNvbGUubG9nKHJzaVBvaW50cyk7XG4gIC8vIHBsb3RTLnB1c2goYEdyYXBoaWNzM0Rbe1JlZCwgUG9pbnRTaXplWzAuMV0sIFBvaW50W3ske3JzaVBvaW50c1sxXS5qb2luKCcsJyl9fV19XWApO1xuXG4gIGNvbnN0IG1heFQgPSByYXlJbmZvLmRpclszXTtcbiAgY29uc29sZS5sb2coJ3JheUluZm8nLCByYXlJbmZvKTtcbiAgY29uc29sZS5sb2coJ3JheSBtYXhUJywgcmF5LCBtYXhUKTtcbiAgY29uc29sZS5sb2cocmF5Lm9yaWdpbi5tYXAoKHYsIGkpID0+IHYgKyByYXkuZGlyW2ldICogbWF4VCkpO1xuXG4gIHBsb3RTLnB1c2goYFBhcmFtZXRyaWNQbG90M0RbeyR7cmF5LmRpclswXX10ICsgJHtyYXkub3JpZ2luWzBdfSwgJHtyYXkuZGlyWzFdfXQgKyAke3JheS5vcmlnaW5bMV19LCAke3JheS5kaXJbMl19dCArICR7cmF5Lm9yaWdpblsyXX19LCB7dCwgMCwgJHttYXhUfX1dYCk7XG4gIGNvbnN0IGZyYWdJbmZvID0gaGl0VGVzdFNoYWRvdyhidmgsIHJheSwgcmF5SW5mby5wcmVPcmlnaW5bMF0sIHBvc2l0aW9ucyk7XG4gIGNvbnNvbGUubG9nKGZyYWdJbmZvKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbXBsZUNpcmNsZShwaTogRmxvYXQzMkFycmF5KSB7XG4gIGxldCBwID0gWzIuMCAqIHBpWzBdIC0gMS4wLCAyLjAgKiBwaVsxXSAtIDEuMCwgXTtcbiAgY29uc29sZS5sb2coJ3N0YXJ0JywgcGkuc2xpY2UoMCwgMiksIHApO1xuICBsZXQgZ3JlYXRlciA9IE1hdGguYWJzKHBbMF0pID4gTWF0aC5hYnMocFsxXSk7XG4gIGxldCByOiBudW1iZXI7XG4gIGxldCB0aGV0YTogbnVtYmVyO1xuXG4gIGlmIChncmVhdGVyKSB7XG4gICAgciA9IHBbMF07XG4gICAgdGhldGEgPSAwLjI1ICogTWF0aC5QSSAqIHBbMV0gLyBwWzBdO1xuICB9IGVsc2Uge1xuICAgIHIgPSBwWzFdO1xuICAgIHRoZXRhID0gTWF0aC5QSSAqICgwLjUgLSAwLjI1ICogcFswXSAvIHBbMV0pO1xuICB9XG5cbiAgY29uc3QgeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gIGNvbnN0IHkgPSByICogTWF0aC5zaW4odGhldGEpO1xuICBjb25zb2xlLmxvZyhyLCB0aGV0YSwgTWF0aC5jb3ModGhldGEpLCBNYXRoLnNpbih0aGV0YSkpO1xuICBjb25zb2xlLmxvZyh4LCB5LCBNYXRoLnNxcnQoMSAtIHggKiB4IC0geSAqIHkpKTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGRlYnVnQ2FtZXJhKGNhbWVyYTogSC5DYW1lcmEsIGJ2aDogSC5CVkgsIHBvc2l0aW9uczogRmxvYXQzMkFycmF5KSB7XG4vLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkgKz0gMSkge1xuLy8gICAgIGNvbnN0IHV2ID0gbmV3IEZsb2F0MzJBcnJheShbTWF0aC5yYW5kb20oKSAvIDIsIE1hdGgucmFuZG9tKCkgLyAyXSk7XG4vLyAgICAgY29uc3Qgc3NQb3MgPSBuZXcgRmxvYXQzMkFycmF5KFt1dlswXSAqIDIgLSAxLCAxIC0gdXZbMV0gKiAyLCAwLCAxXSk7XG4vLyAgICAgY29uc3Qgd29ybGRQb3MgPSBILm1hdGgudmVjNC50cmFuc2Zvcm1NYXQ0KG5ldyBGbG9hdDMyQXJyYXkoNCksIHNzUG9zLCBjYW1lcmEuaW52UHJvak1hdCk7XG4vLyAgICAgSC5tYXRoLnZlYzQudHJhbnNmb3JtTWF0NCh3b3JsZFBvcywgd29ybGRQb3MsIGNhbWVyYS5pbnZWaWV3TWF0KTtcbi8vICAgICBjb25zb2xlLmxvZyh3b3JsZFBvcylcbi8vICAgICBILm1hdGgudmVjNC5zY2FsZSh3b3JsZFBvcywgd29ybGRQb3MsIDEgLyB3b3JsZFBvc1szXSk7XG4vLyAgICAgY29uc3QgZGlyID0gSC5tYXRoLnZlYzMuc3ViKG5ldyBGbG9hdDMyQXJyYXkoMyksIHdvcmxkUG9zLnNsaWNlKDAsIDMpIGFzIEZsb2F0MzJBcnJheSwgY2FtZXJhLnBvcykgYXMgRmxvYXQzMkFycmF5O1xuLy8gICAgIEgubWF0aC52ZWMzLm5vcm1hbGl6ZShkaXIsIGRpcik7XG5cbi8vICAgICBjb25zb2xlLmxvZygndXYsIHNzUG9zLCB3b3JsZFBvcycsIHV2LCBzc1Bvcywgd29ybGRQb3MpO1xuXG4vLyAgICAgY29uc3QgcmF5OiBSYXkgPSB7XG4vLyAgICAgICBvcmlnaW46IGNhbWVyYS5wb3MsXG4vLyAgICAgICBkaXIsXG4vLyAgICAgICBpbnZEaXI6IG5ldyBGbG9hdDMyQXJyYXkoMylcbi8vICAgICB9O1xuLy8gICAgIEgubWF0aC52ZWMzLmRpdihyYXkuaW52RGlyLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSksIHJheS5kaXIpO1xuXG4vLyAgICAgY29uc3QgaGl0ZWROb2RlID0gaGl0VGVzdChidmgsIHJheSk7XG4vLyAgICAgY29uc29sZS5sb2coaGl0ZWROb2RlKTtcblxuLy8gICAgIGlmICghaGl0ZWROb2RlKSB7XG4vLyAgICAgICBjb250aW51ZTtcbi8vICAgICB9XG5cbi8vICAgICBpZiAoaGl0ZWROb2RlLmlzQ2hpbGQwTGVhZikge1xuLy8gICAgICAgY29uc29sZS5sb2cobGVhZkhpdFRlc3QoYnZoLCByYXksIHBvc2l0aW9ucywgaGl0ZWROb2RlLmNoaWxkME9mZnNldCkpO1xuLy8gICAgICAgY29udGludWU7XG4vLyAgICAgfVxuXG4vLyAgICAgaWYgKGhpdGVkTm9kZS5pc0NoaWxkMUxlYWYpIHtcbi8vICAgICAgIGNvbnNvbGUubG9nKGxlYWZIaXRUZXN0KGJ2aCwgcmF5LCBwb3NpdGlvbnMsIGhpdGVkTm9kZS5jaGlsZDFPZmZzZXQpKTtcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuY29uc3QgRVBTID0gMC4wMDU7XG5cbmludGVyZmFjZSBSYXkge1xuICBvcmlnaW46IEZsb2F0MzJBcnJheTtcbiAgZGlyOiBGbG9hdDMyQXJyYXk7XG4gIGludkRpcjogRmxvYXQzMkFycmF5O1xufTtcblxuXG5pbnRlcmZhY2UgQlZITm9kZSB7XG4gIGNoaWxkMEluZGV4OiBudW1iZXI7XG4gIGNoaWxkMUluZGV4OiBudW1iZXI7XG4gIG1heDogRmxvYXQzMkFycmF5O1xuICBtaW46IEZsb2F0MzJBcnJheTtcbn07XG5cbmludGVyZmFjZSBCVkhMZWFmIHtcbiAgcHJpbWl0aXZlczogbnVtYmVyO1xuICBpbmRleGVzOiBVaW50MzJBcnJheTtcbn07XG5cbmludGVyZmFjZSBGcmFnbWVudEluZm8ge1xuICBoaXQ6IGJvb2xlYW47XG4gIHQ6IG51bWJlcjtcbiAgaGl0UG9pbnQ6IEZsb2F0MzJBcnJheTtcbiAgLy8gYXJlYWwgY29vcmRpbmF0ZXNcbiAgd2VpZ2h0czogRmxvYXQzMkFycmF5O1xufTtcblxuZnVuY3Rpb24gYm94SGl0VGVzdChyYXk6IFJheSwgbWF4OiBGbG9hdDMyQXJyYXksIG1pbjogRmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgbGV0IHQxID0gSC5tYXRoLnZlYzMuc3ViKG5ldyBGbG9hdDMyQXJyYXkoMyksIG1pbiwgcmF5Lm9yaWdpbik7XG4gIEgubWF0aC52ZWMzLm11bCh0MSwgdDEsIHJheS5pbnZEaXIpO1xuICBsZXQgdDIgPSBILm1hdGgudmVjMy5zdWIobmV3IEZsb2F0MzJBcnJheSgzKSwgbWF4LCByYXkub3JpZ2luKTtcbiAgSC5tYXRoLnZlYzMubXVsKHQyLCB0MiwgcmF5LmludkRpcik7XG4gIGxldCB0dm1pbiA9IEgubWF0aC52ZWMzLm1pbihuZXcgRmxvYXQzMkFycmF5KDMpLCB0MSwgdDIpO1xuICBsZXQgdHZtYXggPSBILm1hdGgudmVjMy5tYXgobmV3IEZsb2F0MzJBcnJheSgzKSwgdDEsIHQyKTtcbiAgbGV0IHRtaW4gPSBNYXRoLm1heCh0dm1pblswXSwgTWF0aC5tYXgodHZtaW5bMV0sIHR2bWluWzJdKSk7XG4gIGxldCB0bWF4ID0gTWF0aC5taW4odHZtYXhbMF0sIE1hdGgubWluKHR2bWF4WzFdLCB0dm1heFsyXSkpO1xuXG4gIC8vIGNvbnNvbGUubG9nKCdib3ggaGl0IHRlc3QnLCBtYXgsIG1pbiwgdDEsIHQyLCB0dm1heCwgdHZtaW4sIHRtYXgsIHRtaW4pO1xuXG4gIGlmICh0bWF4IC0gdG1pbiA8IC1FUFMpIHtcbiAgICByZXR1cm4gLTEuO1xuICB9XG5cbiAgaWYgKHRtaW4gPiAtRVBTKSB7XG4gICAgcmV0dXJuIHRtaW4gKyBFUFM7XG4gIH1cblxuICByZXR1cm4gdG1heCArIEVQUztcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hpbGQoaW5kZXg6IG51bWJlcik6IHtpc0xlYWY6IGJvb2xlYW4sIG9mZnNldDogbnVtYmVyfSB7XG4gIHJldHVybiB7XG4gICAgaXNMZWFmOiAoaW5kZXggPj4gMzEpICE9PSAwLFxuICAgIG9mZnNldDogKGluZGV4IDw8IDEpID4+IDEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJWSE5vZGVJbmZvKGJ2aDogSC5CVkgsIGluZGV4OiBudW1iZXIpOiBCVkhOb2RlIHtcbiAgbGV0IHJlYWxPZmZzZXQgPSBpbmRleCAqIDQ7XG4gIGxldCBkYXRhMCA9IGJ2aC5idWZmZXIuc2xpY2UocmVhbE9mZnNldCwgcmVhbE9mZnNldCArIDQpO1xuICBsZXQgZGF0YTEgPSBidmguYnVmZmVyLnNsaWNlKHJlYWxPZmZzZXQgKyA0LCByZWFsT2Zmc2V0ICsgOCk7XG4gIGxldCBjaGlsZDAgPSBuZXcgVWludDMyQXJyYXkoZGF0YTAuYnVmZmVyLCAwLCAxKVswXTtcbiAgbGV0IGNoaWxkMSA9IG5ldyBVaW50MzJBcnJheShkYXRhMS5idWZmZXIsIDAsIDEpWzBdO1xuXG4gIHJldHVybiB7XG4gICAgY2hpbGQwSW5kZXg6IGNoaWxkMCxcbiAgICBjaGlsZDFJbmRleDogY2hpbGQxLFxuICAgIG1pbjogZGF0YTAuc2xpY2UoMSksXG4gICAgbWF4OiBkYXRhMS5zbGljZSgxKVxuICB9O1xufVxuXG5mdW5jdGlvbiBoaXRUZXN0KGJ2aDogSC5CVkgsIHJheTogUmF5LCBwb3NpdGlvbnM6IEZsb2F0MzJBcnJheSk6IEZyYWdtZW50SW5mbyB7XG4gIGxldCBmcmFnSW5mbzogRnJhZ21lbnRJbmZvID0ge1xuICAgIGhpdDogZmFsc2UsXG4gICAgdDogSW5maW5pdHksXG4gICAgaGl0UG9pbnQ6IG51bGwsXG4gICAgd2VpZ2h0czogbnVsbFxuICB9O1xuICBsZXQgbm9kZVN0YWNrOiBudW1iZXJbXSA9IEFycmF5KGJ2aC5tYXhEZXB0aCk7XG4gIG5vZGVTdGFja1swXSA9IDA7XG4gIGxldCBzdGFja0RlcHRoOiBudW1iZXIgPSAwO1xuXG4gIHdoaWxlIChzdGFja0RlcHRoID49IDApIHtcbiAgICBjb25zdCB7aXNMZWFmLCBvZmZzZXR9ID0gZGVjb2RlQ2hpbGQobm9kZVN0YWNrW3N0YWNrRGVwdGhdKTtcbiAgICBzdGFja0RlcHRoIC09IDE7XG5cbiAgICBpZiAoaXNMZWFmKSB7XG4gICAgICBjb25zdCBpbmZvID0gbGVhZkhpdFRlc3QoYnZoLCByYXksIHBvc2l0aW9ucywgb2Zmc2V0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdsZWFmIGhpdCcsIGluZm8uaGl0ICYmIGluZm8udCA8IGZyYWdJbmZvLnQpO1xuXG4gICAgICBpZiAoaW5mby5oaXQgJiYgaW5mby50IDwgZnJhZ0luZm8udCkge1xuICAgICAgICBmcmFnSW5mbyA9IGluZm87XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBnZXRCVkhOb2RlSW5mbyhidmgsIG9mZnNldCk7XG4gICAgY29uc3QgaGl0ZWQgPSBib3hIaXRUZXN0KHJheSwgbm9kZS5tYXgsIG5vZGUubWluKTtcbiAgICBjb25zb2xlLmxvZygnYm94IGhpdCcsIG9mZnNldCwgbm9kZSwgaGl0ZWQsICEoaGl0ZWQgPCAwIHx8IGhpdGVkID4gZnJhZ0luZm8udCkpO1xuXG4gICAgaWYgKGhpdGVkIDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhY2tEZXB0aCArPSAxO1xuICAgIG5vZGVTdGFja1tzdGFja0RlcHRoXSA9IG5vZGUuY2hpbGQwSW5kZXg7XG4gICAgc3RhY2tEZXB0aCArPSAxO1xuICAgIG5vZGVTdGFja1tzdGFja0RlcHRoXSA9IG5vZGUuY2hpbGQxSW5kZXg7XG4gIH1cblxuICByZXR1cm4gZnJhZ0luZm87XG59XG5cbmZ1bmN0aW9uIGdldEJWSExlYWZJbmZvKGJ2aDogSC5CVkgsIG9mZnNldDogbnVtYmVyKTogQlZITGVhZiB7XG4gIGxldCByZWFsT2Zmc2V0ID0gb2Zmc2V0ICogNDtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkoYnZoLmJ1ZmZlci5idWZmZXIsIHJlYWxPZmZzZXQgKiA0LCA0KTtcblxuICByZXR1cm4ge1xuICAgIHByaW1pdGl2ZXM6IGRhdGFbMF0sXG4gICAgaW5kZXhlczogZGF0YS5zbGljZSgxKVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmlhbmdsZUhpdFRlc3QocmF5OiBSYXksIGxlYWY6IEJWSExlYWYsIHBvc2l0aW9uczogRmxvYXQzMkFycmF5KTogRnJhZ21lbnRJbmZvIHtcbiAgY29uc3QgaW5mbzogRnJhZ21lbnRJbmZvID0ge1xuICAgIGhpdDogZmFsc2UsXG4gICAgdDogSW5maW5pdHksXG4gICAgaGl0UG9pbnQ6IG51bGwsXG4gICAgd2VpZ2h0czogbnVsbFxuICB9O1xuICBsZXQgaW5kZXhlcyA9IGxlYWYuaW5kZXhlcztcbiAgbGV0IHAwID0gcG9zaXRpb25zLnNsaWNlKGluZGV4ZXNbMF0gKiA0LCBpbmRleGVzWzBdICogNCArIDQpO1xuICBsZXQgcDEgPSBwb3NpdGlvbnMuc2xpY2UoaW5kZXhlc1sxXSAqIDQsIGluZGV4ZXNbMV0gKiA0ICsgNCk7XG4gIGxldCBwMiA9IHBvc2l0aW9ucy5zbGljZShpbmRleGVzWzJdICogNCwgaW5kZXhlc1syXSAqIDQgKyA0KTtcblxuICBsZXQgZTAgPSBILm1hdGgudmVjMy5zdWIobmV3IEZsb2F0MzJBcnJheSgzKSwgcDEsIHAwKTtcbiAgbGV0IGUxID0gSC5tYXRoLnZlYzMuc3ViKG5ldyBGbG9hdDMyQXJyYXkoMyksIHAyLCBwMCk7XG4gIGxldCBwID0gSC5tYXRoLnZlYzMuY3Jvc3MobmV3IEZsb2F0MzJBcnJheSgzKSwgcmF5LmRpciwgZTEpO1xuICBsZXQgZGV0ID0gSC5tYXRoLnZlYzMuZG90KGUwLCBwKTtcbiAgbGV0IHQgPSBILm1hdGgudmVjMy5zdWIobmV3IEZsb2F0MzJBcnJheSgzKSwgcmF5Lm9yaWdpbiwgcDApO1xuXG4gIGlmIChkZXQgPCAwKSB7XG4gICAgSC5tYXRoLnZlYzMuc2NhbGUodCwgdCwgLTEpO1xuICAgIGRldCA9IC1kZXQ7XG4gIH1cblxuICBpZiAoZGV0IDwgMC4wMDAxKSB7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBsZXQgdSA9IEgubWF0aC52ZWMzLmRvdCh0LCBwKTtcblxuICBpZiAodSA8IDAuIHx8IHUgPiBkZXQpIHtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGxldCBxID0gSC5tYXRoLnZlYzMuY3Jvc3MobmV3IEZsb2F0MzJBcnJheSgzKSwgdCwgZTApO1xuICBsZXQgdiA9IEgubWF0aC52ZWMzLmRvdChyYXkuZGlyLCBxKTtcblxuICAvLyBwbG90Uy5wdXNoKGBHcmFwaGljczNEW1RyaWFuZ2xlW3t7JHtwMC5qb2luKCcsJyl9fSwgeyR7cDEuam9pbignLCcpfX0sIHske3AyLmpvaW4oJywnKX19fV1dYCk7XG4gIC8vIGNvbnNvbGUubG9nKGRldCwgdSwgdiwgdiArIHUgLSBkZXQsIEgubWF0aC52ZWMzLmRvdChlMSwgcSkgLyBkZXQpXG5cbiAgaWYgKHYgPCAwIHx8IHYgKyB1IC0gZGV0ID4gMCkge1xuICAgIHJldHVybiBpbmZvO1xuICB9XG4gIFxuICBsZXQgbHQgPSBILm1hdGgudmVjMy5kb3QoZTEsIHEpO1xuXG4gIGlmIChsdCA8IDAuKSB7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBsZXQgaW52RGV0ID0gMS4gLyBkZXQ7XG4gIGxldCBoaXRQb2ludCA9IEgubWF0aC52ZWMzLmFkZChcbiAgICBuZXcgRmxvYXQzMkFycmF5KDMpLCByYXkub3JpZ2luLFxuICAgIEgubWF0aC52ZWMzLnNjYWxlKG5ldyBGbG9hdDMyQXJyYXkoMyksIHJheS5kaXIsIGx0ICogaW52RGV0KVxuICApIGFzIEZsb2F0MzJBcnJheTtcbiAgbGV0IHdlaWdodHMgPSBILm1hdGgudmVjMy5zY2FsZShuZXcgRmxvYXQzMkFycmF5KDMpLCBuZXcgRmxvYXQzMkFycmF5KFswLiwgdSwgdl0pLCBpbnZEZXQpIGFzIEZsb2F0MzJBcnJheTtcbiAgd2VpZ2h0c1swXSA9IDEuIC0gd2VpZ2h0c1sxXSAtIHdlaWdodHNbMl07XG4gIFxuICBpbmZvLmhpdCA9IHRydWU7XG4gIGluZm8ud2VpZ2h0cyA9IHdlaWdodHM7XG4gIGluZm8uaGl0UG9pbnQgPSBoaXRQb2ludDtcbiAgaW5mby50ID0gbHQgKiBpbnZEZXQ7XG5cbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIGxlYWZIaXRUZXN0KGJ2aDogSC5CVkgsIHJheTogUmF5LCBwb3NpdGlvbnM6IEZsb2F0MzJBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBGcmFnbWVudEluZm8ge1xuICBsZXQgbGVhZjogQlZITGVhZiA9IGdldEJWSExlYWZJbmZvKGJ2aCwgb2Zmc2V0KTtcbiAgbGV0IGluZm86IEZyYWdtZW50SW5mbyA9IHtcbiAgICBoaXQ6IGZhbHNlLFxuICAgIHQ6IEluZmluaXR5LFxuICAgIGhpdFBvaW50OiBudWxsLFxuICAgIHdlaWdodHM6IG51bGxcbiAgfTtcbiAgY29uc29sZS5sb2cobmV3IFVpbnQzMkFycmF5KFsob2Zmc2V0ICsgMCkgfCAweDgwMDAwMDAwXSlbMF0sIGxlYWYpO1xuXG4gIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBsZWFmLnByaW1pdGl2ZXM7IGkgPSBpICsgMSkge1xuICAgIGxlYWYgPSBnZXRCVkhMZWFmSW5mbyhidmgsIG9mZnNldCArIGkpO1xuICAgIGxldCBjSW5mbyA9IHRyaWFuZ2xlSGl0VGVzdChyYXksIGxlYWYsIHBvc2l0aW9ucyk7XG4gICAgY29uc29sZS5sb2coJ3RyaWFuZ2xlIGhpdCcsIG5ldyBVaW50MzJBcnJheShbKG9mZnNldCArIGkpIHwgMHg4MDAwMDAwMF0pWzBdLCBjSW5mbywgY0luZm8uaGl0ICYmIGNJbmZvLnQgPCBpbmZvLnQpO1xuXG4gICAgaWYgKGNJbmZvLmhpdCAmJiBjSW5mby50IDwgaW5mby50KSB7XG4gICAgICBpbmZvID0gY0luZm87XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIGhpdFRlc3RTaGFkb3coYnZoOiBILkJWSCwgcmF5OiBSYXksIG1heFQ6IG51bWJlciwgcG9zaXRpb25zOiBGbG9hdDMyQXJyYXkpOiBGcmFnbWVudEluZm8ge1xuICBsZXQgZnJhZ0luZm86IEZyYWdtZW50SW5mbyA9IHtcbiAgICBoaXQ6IGZhbHNlLFxuICAgIHQ6IG1heFQsXG4gICAgaGl0UG9pbnQ6IG51bGwsXG4gICAgd2VpZ2h0czogbnVsbFxuICB9O1xuICBsZXQgbm9kZVN0YWNrOiBudW1iZXJbXSA9IEFycmF5KGJ2aC5tYXhEZXB0aCk7XG4gIG5vZGVTdGFja1swXSA9IDA7XG4gIGxldCBzdGFja0RlcHRoOiBudW1iZXIgPSAwO1xuXG4gIHdoaWxlIChzdGFja0RlcHRoID49IDApIHtcbiAgICBjb25zdCB7aXNMZWFmLCBvZmZzZXR9ID0gZGVjb2RlQ2hpbGQobm9kZVN0YWNrW3N0YWNrRGVwdGhdKTtcbiAgICBzdGFja0RlcHRoIC09IDE7XG5cbiAgICBpZiAoaXNMZWFmKSB7XG4gICAgICBjb25zdCBpbmZvID0gbGVhZkhpdFRlc3QoYnZoLCByYXksIHBvc2l0aW9ucywgb2Zmc2V0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdsZWFmIGhpdCcsIGluZm8uaGl0KTtcblxuICAgICAgaWYgKGluZm8uaGl0ICYmIGluZm8udCA8IG1heFQpIHtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBnZXRCVkhOb2RlSW5mbyhidmgsIG9mZnNldCk7XG4gICAgY29uc3QgaGl0ZWQgPSBib3hIaXRUZXN0KHJheSwgbm9kZS5tYXgsIG5vZGUubWluKTtcbiAgICAvLyBwbG90Uy5wdXNoKGBHcmFwaGljczNEW0N1Ym9pZFt7JHtub2RlLm1heC5qb2luKCcsJyl9fSwgeyR7bm9kZS5taW4uam9pbignLCcpfX1dXWApO1xuICAgIGNvbnNvbGUubG9nKCdib3ggaGl0Jywgb2Zmc2V0LCBub2RlLmNoaWxkMEluZGV4LCBub2RlLmNoaWxkMUluZGV4LCBub2RlLm1heCwgbm9kZS5taW4sIGhpdGVkKTtcblxuICAgIGlmIChoaXRlZCA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YWNrRGVwdGggKz0gMTtcbiAgICBub2RlU3RhY2tbc3RhY2tEZXB0aF0gPSBub2RlLmNoaWxkMEluZGV4O1xuICAgIHN0YWNrRGVwdGggKz0gMTtcbiAgICBub2RlU3RhY2tbc3RhY2tEZXB0aF0gPSBub2RlLmNoaWxkMUluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGZyYWdJbmZvO1xufVxuIl19

/***/ }),

/***/ "./demo/index.ts":
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var H = __webpack_require__(/*! ../src/index */ "./src/index.ts");
var RayTracingApp_1 = __webpack_require__(/*! ./RayTracingApp */ "./demo/RayTracingApp.ts");
var fpsDom = document.createElement('div');
fpsDom.style.position = 'fixed';
fpsDom.style.left = fpsDom.style.top = '0';
fpsDom.style.color = 'red';
fpsDom.style.fontSize = '24px';
document.body.append(fpsDom);
var app = new RayTracingApp_1.default();
var preFPS = 0;
function update(dt) {
    return __awaiter(this, void 0, void 0, function () {
        var fps;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, app.update(dt)];
                case 1:
                    _a.sent();
                    fps = 1000 / dt;
                    if (Math.abs(fps - preFPS) > 2) {
                        fpsDom.innerText = fps.toFixed(2) + "fps";
                    }
                    preFPS = fps;
                    return [2];
            }
        });
    });
}
function main() {
    return __awaiter(this, void 0, void 0, function () {
        function _loop(ct) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, update(ct - t)];
                        case 1:
                            _a.sent();
                            t = ct;
                            requestAnimationFrame(_loop);
                            return [2];
                    }
                });
            });
        }
        var t;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, H.init(document.querySelector('canvas#mainCanvas'))];
                case 1:
                    _a.sent();
                    return [4, app.init()];
                case 2:
                    _a.sent();
                    t = 0;
                    return [4, _loop(performance.now())];
                case 3:
                    _a.sent();
                    return [2];
            }
        });
    });
}
main();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLGdDQUFrQztBQUdsQyxpREFBNEM7QUFFNUMsSUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM3QyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7QUFDaEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQzNDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUMzQixNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7QUFDL0IsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFJN0IsSUFBTSxHQUFHLEdBQUcsSUFBSSx1QkFBYSxFQUFFLENBQUM7QUFFaEMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsU0FBZSxNQUFNLENBQUMsRUFBVTs7Ozs7d0JBQzlCLFdBQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBQTs7b0JBQXBCLFNBQW9CLENBQUM7b0JBRWYsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7b0JBRXRCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUM5QixNQUFNLENBQUMsU0FBUyxHQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQUssQ0FBQztxQkFDM0M7b0JBRUQsTUFBTSxHQUFHLEdBQUcsQ0FBQzs7Ozs7Q0FDZDtBQUVELFNBQWUsSUFBSTs7UUFLakIsU0FBZSxLQUFLLENBQUMsRUFBVTs7OztnQ0FDN0IsV0FBTSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFBOzs0QkFBcEIsU0FBb0IsQ0FBQzs0QkFDckIsQ0FBQyxHQUFHLEVBQUUsQ0FBQzs0QkFDUCxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7U0FDOUI7Ozs7d0JBUkQsV0FBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQW9CLG1CQUFtQixDQUFDLENBQUMsRUFBQTs7b0JBQTVFLFNBQTRFLENBQUM7b0JBQzdFLFdBQU0sR0FBRyxDQUFDLElBQUksRUFBRSxFQUFBOztvQkFBaEIsU0FBZ0IsQ0FBQztvQkFFYixDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQU9WLFdBQU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFBOztvQkFBOUIsU0FBOEIsQ0FBQzs7Ozs7Q0FDaEM7QUFFRCxJQUFJLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IGluZGV4LnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi815LiL5Y2IMjo0NDoyOFxuICovXG5pbXBvcnQgKiBhcyBIIGZyb20gJy4uL3NyYy9pbmRleCc7XG5pbXBvcnQgU3VwZXJTaW1wbGVBcHAgZnJvbSAnLi9TdXBlclNpbXBsZUFwcCc7XG5pbXBvcnQgQmFzaWNUZXN0QXBwIGZyb20gJy4vQmFzaWNUZXN0QXBwJztcbmltcG9ydCBSYXlUcmFjaW5nQXBwIGZyb20gJy4vUmF5VHJhY2luZ0FwcCc7XG5cbmNvbnN0IGZwc0RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZnBzRG9tLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbmZwc0RvbS5zdHlsZS5sZWZ0ID0gZnBzRG9tLnN0eWxlLnRvcCA9ICcwJztcbmZwc0RvbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuZnBzRG9tLnN0eWxlLmZvbnRTaXplID0gJzI0cHgnO1xuZG9jdW1lbnQuYm9keS5hcHBlbmQoZnBzRG9tKTtcblxuLy8gY29uc3QgYXBwID0gbmV3IFN1cGVyU2ltcGxlQXBwKCk7XG4vLyBjb25zdCBhcHAgPSBuZXcgQmFzaWNUZXN0QXBwKCk7XG5jb25zdCBhcHAgPSBuZXcgUmF5VHJhY2luZ0FwcCgpO1xuXG5sZXQgcHJlRlBTID0gMDtcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gIGF3YWl0IGFwcC51cGRhdGUoZHQpO1xuXG4gIGNvbnN0IGZwcyA9IDEwMDAgLyBkdDtcblxuICBpZiAoTWF0aC5hYnMoZnBzIC0gcHJlRlBTKSA+IDIpIHtcbiAgICBmcHNEb20uaW5uZXJUZXh0ID0gYCR7ZnBzLnRvRml4ZWQoMil9ZnBzYDtcbiAgfVxuXG4gIHByZUZQUyA9IGZwcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgYXdhaXQgSC5pbml0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTENhbnZhc0VsZW1lbnQ+KCdjYW52YXMjbWFpbkNhbnZhcycpKTtcbiAgYXdhaXQgYXBwLmluaXQoKTtcbiAgXG4gIGxldCB0ID0gMDtcbiAgYXN5bmMgZnVuY3Rpb24gX2xvb3AoY3Q6IG51bWJlcikge1xuICAgIGF3YWl0IHVwZGF0ZShjdCAtIHQpO1xuICAgIHQgPSBjdDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2xvb3ApO1xuICB9XG5cbiAgYXdhaXQgX2xvb3AocGVyZm9ybWFuY2Uubm93KCkpO1xufVxuXG5tYWluKCk7XG4iXX0=

/***/ }),

/***/ "./src/buildin/effects.ts":
/*!********************************!*\
  !*** ./src/buildin/effects.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var Effect_1 = __webpack_require__(/*! ../core/Effect */ "./src/core/Effect.ts");
var shared_1 = __webpack_require__(/*! ../core/shared */ "./src/core/shared.ts");
var textures_1 = __webpack_require__(/*! ./textures */ "./src/buildin/textures.ts");
var effects = {};
exports["default"] = effects;
var commonMarcos = {
    USE_TEXCOORD_0: false,
    USE_NORMAL: false,
    USE_TANGENT: false,
    USE_COLOR_0: false,
    USE_TEXCOORD_1: false
};
function init() {
    var emptyStorageBuffer = {
        value: new Float32Array(4),
        gpuValue: shared_1.createGPUBuffer(new Float32Array(4), GPUBufferUsage.STORAGE)
    };
    effects.rColor = new Effect_1.default('rColor', {
        vs: __webpack_require__(/*! ./shaders/basic/model.vert.wgsl */ "./src/buildin/shaders/basic/model.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/basic/color.frag.wgsl */ "./src/buildin/shaders/basic/color.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_color',
                    type: 'vec4',
                    defaultValue: new Float32Array([1, 0, 0, 1])
                }
            ]
        },
        marcos: commonMarcos
    });
    effects.rUnlit = new Effect_1.default('rUnlit', {
        vs: __webpack_require__(/*! ./shaders/basic/model.vert.wgsl */ "./src/buildin/shaders/basic/model.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/basic/unlit.frag.wgsl */ "./src/buildin/shaders/basic/unlit.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_baseColorFactor',
                    type: 'vec4',
                    defaultValue: new Float32Array([1, 1, 1, 1])
                }
            ],
            textures: [
                {
                    name: 'u_baseColorTexture',
                    defaultValue: textures_1.default.white
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ]
        },
        marcos: commonMarcos
    });
    effects.rPBR = new Effect_1.default('rPBR', {
        vs: __webpack_require__(/*! ./shaders/basic/model.vert.wgsl */ "./src/buildin/shaders/basic/model.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/basic/unlit.frag.wgsl */ "./src/buildin/shaders/basic/unlit.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_baseColorFactor',
                    type: 'vec4',
                    defaultValue: new Float32Array([1, 1, 1, 1])
                },
                {
                    name: 'u_normalTextureScale',
                    type: 'number',
                    defaultValue: new Float32Array([1])
                },
                {
                    name: 'u_metallicFactor',
                    type: 'number',
                    defaultValue: new Float32Array([1])
                },
                {
                    name: 'u_roughnessFactor',
                    type: 'number',
                    defaultValue: new Float32Array([1])
                },
                {
                    name: 'u_specularFactor',
                    type: 'vec3',
                    defaultValue: new Float32Array([3])
                },
                {
                    name: 'u_glossinessFactor',
                    type: 'number',
                    defaultValue: new Float32Array([1])
                },
            ],
            textures: [
                {
                    name: 'u_baseColorTexture',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_normalTexture',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_metallicRoughnessTexture',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_specularGlossinessTexture',
                    defaultValue: textures_1.default.empty
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ]
        },
        marcos: Object.assign({}, commonMarcos, { USE_SPEC_GLOSS: false, USE_GLASS: false })
    });
    effects.rSkybox = new Effect_1.default('rSkybox', {
        vs: __webpack_require__(/*! ./shaders/basic/skybox.vert.wgsl */ "./src/buildin/shaders/basic/skybox.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/basic/skybox.frag.wgsl */ "./src/buildin/shaders/basic/skybox.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_color',
                    type: 'vec4',
                    defaultValue: gl_matrix_1.mat4.identity(new Float32Array(4))
                },
                {
                    name: 'u_factor',
                    type: 'number',
                    defaultValue: new Float32Array(1)
                },
                {
                    name: 'u_rotation',
                    type: 'number',
                    defaultValue: new Float32Array(1)
                },
                {
                    name: 'u_exposure',
                    type: 'number',
                    defaultValue: new Float32Array(1)
                },
            ],
            textures: [
                {
                    name: 'u_cubeTexture',
                    defaultValue: textures_1.default.cubeWhite
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ]
        }
    });
    effects.rRTGBuffer = new Effect_1.default('rRTGBuffer', {
        vs: __webpack_require__(/*! ./shaders/ray-tracing/gbuffer.vert.wgsl */ "./src/buildin/shaders/ray-tracing/gbuffer.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/ray-tracing/gbuffer.frag.wgsl */ "./src/buildin/shaders/ray-tracing/gbuffer.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_matId2TexturesId',
                    type: 'vec4',
                    format: 'i32',
                    size: 128,
                    defaultValue: new Int32Array(2 * 128)
                },
                {
                    name: 'u_baseColorFactors',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(4 * 128)
                },
                {
                    name: 'u_metallicRoughnessFactorNormalScaleMaterialTypes',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(128)
                },
                {
                    name: 'u_specularGlossinessFactors',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(128)
                }
            ],
            textures: [
                {
                    name: 'u_baseColorTextures',
                    defaultValue: textures_1.default.array1white
                },
                {
                    name: 'u_normalTextures',
                    defaultValue: textures_1.default.array1white
                },
                {
                    name: 'u_metalRoughOrSpecGlossTextures',
                    defaultValue: textures_1.default.array1white
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ],
        },
        marcos: commonMarcos
    });
    effects.rRTGBufferLight = new Effect_1.default('rRTGBufferLight', {
        vs: __webpack_require__(/*! ./shaders/basic/model.vert.wgsl */ "./src/buildin/shaders/basic/model.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/ray-tracing/gbufferLight.frag.wgsl */ "./src/buildin/shaders/ray-tracing/gbufferLight.frag.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_lightColor',
                    type: 'vec4',
                    defaultValue: new Float32Array(4)
                },
            ],
            textures: [],
            samplers: [],
        },
        marcos: commonMarcos
    });
    effects.cRTSS = new Effect_1.default('cRTSS', {
        cs: __webpack_require__(/*! ./shaders/ray-tracing/rtss.comp.wgsl */ "./src/buildin/shaders/ray-tracing/rtss.comp.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_randoms',
                    type: 'vec4',
                    size: 4,
                    defaultValue: new Float32Array(16)
                },
                {
                    name: 'u_matId2TexturesId',
                    type: 'vec4',
                    format: 'i32',
                    size: 128,
                    defaultValue: new Int32Array(2 * 128)
                },
                {
                    name: 'u_baseColorFactors',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(4 * 128)
                },
                {
                    name: 'u_metallicRoughnessFactorNormalScaleMaterialTypes',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(128)
                },
                {
                    name: 'u_specularGlossinessFactors',
                    type: 'vec4',
                    size: 128,
                    defaultValue: new Float32Array(128)
                }
            ],
            storages: [
                {
                    name: 'u_positions',
                    type: 'vec3',
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue,
                },
                {
                    name: 'u_normals',
                    type: 'vec3',
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue,
                },
                {
                    name: 'u_uvs',
                    type: 'vec2',
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue,
                },
                {
                    name: 'u_meshMatIndexes',
                    type: 'vec2',
                    format: 'u32',
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue,
                },
                {
                    name: 'u_bvh',
                    type: 'vec4',
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue,
                },
                {
                    name: 'u_debugInfo',
                    type: 'number',
                    customStruct: { name: 'DebugInfo', code: "\nstruct DebugRay {\n  preOrigin: vec4<f32>;\n  preDir: vec4<f32>;\n  origin: vec4<f32>;\n  dir: vec4<f32>;\n  nextOrigin: vec4<f32>;\n  nextDir: vec4<f32>;\n  normal: vec4<f32>;\n};\n\n[[block]] struct DebugInfo {\n  rays: array<DebugRay>;\n};"
                    },
                    writable: true,
                    defaultValue: emptyStorageBuffer.value,
                    gpuValue: emptyStorageBuffer.gpuValue
                }
            ],
            textures: [
                {
                    name: 'u_output',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'write-only',
                    storageFormat: 'rgba16float'
                },
                {
                    name: 'u_noise',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbPositionMetalOrSpec',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbBaseColorRoughOrGloss',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbNormalGlass',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbMeshIndexMatIndexMatType',
                    format: 'uint',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_baseColorTextures',
                    defaultValue: textures_1.default.array1white
                },
                {
                    name: 'u_normalTextures',
                    defaultValue: textures_1.default.array1white
                },
                {
                    name: 'u_metalRoughOrSpecGlossTextures',
                    defaultValue: textures_1.default.array1white
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                },
                {
                    name: 'u_samplerGB',
                    defaultValue: { magFilter: 'nearest', minFilter: 'nearest' }
                }
            ]
        },
        marcos: { BVH_DEPTH: 0 }
    });
    effects.cRTDenoiseTempor = new Effect_1.default('cRTDenoiseTempor', {
        cs: __webpack_require__(/*! ./shaders/ray-tracing/denoiseTempor.comp.wgsl */ "./src/buildin/shaders/ray-tracing/denoiseTempor.comp.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_preWeight',
                    type: 'number',
                    format: 'f32',
                    defaultValue: new Float32Array([1])
                }
            ],
            textures: [
                {
                    name: 'u_output',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'write-only',
                    storageFormat: 'rgba16float'
                },
                {
                    name: 'u_pre',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'read-only',
                    storageFormat: 'rgba16float'
                },
                {
                    name: 'u_current',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'read-only',
                    storageFormat: 'rgba16float'
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ]
        }
    });
    effects.cRTDenoiseSpace = new Effect_1.default('cRTDenoiseSpace', {
        cs: __webpack_require__(/*! ./shaders/ray-tracing/denoiseSpace.comp.wgsl */ "./src/buildin/shaders/ray-tracing/denoiseSpace.comp.wgsl"),
        uniformDesc: {
            uniforms: [
                {
                    name: 'u_filterFactors',
                    type: 'vec2',
                    size: 4,
                    defaultValue: shared_1.genGaussianParams(new Float32Array([1.5, 0.5, 1.5, 0.5]), [2, 3, 1, 3])
                }
            ],
            textures: [
                {
                    name: 'u_output',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'write-only'
                },
                {
                    name: 'u_mixed',
                    defaultValue: textures_1.default.empty,
                    storageAccess: 'read-only',
                    storageFormat: 'rgba16float'
                },
                {
                    name: 'u_gbPositionMetalOrSpec',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbNormalGlass',
                    defaultValue: textures_1.default.empty
                },
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'nearest' }
                }
            ]
        },
        marcos: { WINDOW_SIZE: 7 }
    });
    effects.iRTGShow = new Effect_1.default('iRTGShow', {
        vs: __webpack_require__(/*! ./shaders/image/image.vert.wgsl */ "./src/buildin/shaders/image/image.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/ray-tracing/gshow.frag.wgsl */ "./src/buildin/shaders/ray-tracing/gshow.frag.wgsl"),
        uniformDesc: {
            uniforms: [],
            textures: [
                {
                    name: 'u_gbPositionMetalOrSpec',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbBaseColorRoughOrGloss',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbNormalGlass',
                    defaultValue: textures_1.default.empty
                },
                {
                    name: 'u_gbMeshIndexMatIndexMatType',
                    format: 'uint',
                    defaultValue: textures_1.default.empty
                },
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear' }
                }
            ]
        },
        marcos: { FLIP: false }
    });
    effects.iBlit = new Effect_1.default('iBlit', {
        vs: __webpack_require__(/*! ./shaders/image/image.vert.wgsl */ "./src/buildin/shaders/image/image.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/image/blit.frag.wgsl */ "./src/buildin/shaders/image/blit.frag.wgsl"),
        uniformDesc: {
            uniforms: [],
            textures: [
                {
                    name: 'u_texture',
                    defaultValue: textures_1.default.white
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear' }
                }
            ]
        },
        marcos: { FLIP: false }
    });
    effects.iTone = new Effect_1.default('iTone', {
        vs: __webpack_require__(/*! ./shaders/image/image.vert.wgsl */ "./src/buildin/shaders/image/image.vert.wgsl"),
        fs: __webpack_require__(/*! ./shaders/image/tone.frag.wgsl */ "./src/buildin/shaders/image/tone.frag.wgsl"),
        uniformDesc: {
            uniforms: [],
            textures: [
                {
                    name: 'u_texture',
                    defaultValue: textures_1.default.white
                }
            ],
            samplers: [
                {
                    name: 'u_sampler',
                    defaultValue: { magFilter: 'linear', minFilter: 'linear' }
                }
            ]
        },
        marcos: { FLIP: false }
    });
    effects.cCreateSimpleBlur = function (radius) {
        var realKernelSize = Math.pow((radius * 2 + 1), 2);
        var mod = realKernelSize % 4;
        var kernelSize = realKernelSize + (4 - mod);
        return new Effect_1.default('cSimpleBlur-' + radius, {
            cs: __webpack_require__(/*! ./shaders/compute/blur.comp.wgsl */ "./src/buildin/shaders/compute/blur.comp.wgsl"),
            uniformDesc: {
                uniforms: [
                    {
                        name: 'u_kernel',
                        type: 'vec4',
                        size: kernelSize / 4,
                        defaultValue: new Float32Array(kernelSize).fill(1)
                    }
                ],
                textures: [
                    {
                        name: 'u_input',
                        defaultValue: textures_1.default.white
                    },
                    {
                        name: 'u_output',
                        defaultValue: textures_1.default.white,
                        storageAccess: 'write-only'
                    }
                ],
                samplers: [
                    {
                        name: 'u_sampler',
                        defaultValue: { magFilter: 'linear', minFilter: 'linear' }
                    }
                ]
            },
            marcos: { RADIUS: radius, WINDOW_SIZE: radius * 2 + 1, TILE_SIZE: radius * 4 + 1 }
        });
    };
}
exports.init = init;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZmZWN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImVmZmVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBTUEsdUNBQStCO0FBQy9CLHlDQUFvQztBQUNwQyx5Q0FBa0U7QUFDbEUsdUNBQWtDO0FBRWxDLElBQU0sT0FBTyxHQWNULEVBQVMsQ0FBQztBQUVkLGtCQUFlLE9BQU8sQ0FBQztBQUV2QixJQUFNLFlBQVksR0FBRztJQUNuQixjQUFjLEVBQUUsS0FBSztJQUNyQixVQUFVLEVBQUUsS0FBSztJQUNqQixXQUFXLEVBQUUsS0FBSztJQUNsQixXQUFXLEVBQUUsS0FBSztJQUNsQixjQUFjLEVBQUUsS0FBSztDQUN0QixDQUFDO0FBRUYsU0FBZ0IsSUFBSTtJQUNsQixJQUFNLGtCQUFrQixHQUFHO1FBQ3pCLEtBQUssRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDMUIsUUFBUSxFQUFFLHdCQUFlLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLE9BQU8sQ0FBQztLQUN2RSxDQUFDO0lBRUYsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLGdCQUFNLENBQUMsUUFBUSxFQUFFO1FBQ3BDLEVBQUUsRUFBRSxPQUFPLENBQUMsaUNBQWlDLENBQUM7UUFDOUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQztRQUM5QyxXQUFXLEVBQUU7WUFDWCxRQUFRLEVBQUU7Z0JBQ1I7b0JBQ0UsSUFBSSxFQUFFLFNBQVM7b0JBQ2YsSUFBSSxFQUFFLE1BQU07b0JBQ1osWUFBWSxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzdDO2FBQ0Y7U0FDRjtRQUNELE1BQU0sRUFBRSxZQUFZO0tBQ3JCLENBQUMsQ0FBQztJQUVILE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxnQkFBTSxDQUFDLFFBQVEsRUFBRTtR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RUFBRSxFQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLFNBQVMsRUFBRSxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBQztTQUNqRixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFDSixDQUFDO0FBempCRCxvQkF5akJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogZWZmZWN0cy50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiAyMDIxLzYvNuS4i+WNiDg6NTY6NDlcbiAqL1xuaW1wb3J0IHttYXQ0fSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEVmZmVjdCBmcm9tICcuLi9jb3JlL0VmZmVjdCc7XG5pbXBvcnQge2NyZWF0ZUdQVUJ1ZmZlciwgZ2VuR2F1c3NpYW5QYXJhbXN9IGZyb20gJy4uL2NvcmUvc2hhcmVkJztcbmltcG9ydCB0ZXh0dXJlcyBmcm9tICcuL3RleHR1cmVzJztcblxuY29uc3QgZWZmZWN0czoge1xuICByQ29sb3I6IEVmZmVjdCxcbiAgclVubGl0OiBFZmZlY3QsXG4gIHJQQlI6IEVmZmVjdCxcbiAgclNreWJveDogRWZmZWN0LFxuICBpQmxpdDogRWZmZWN0LFxuICBpVG9uZTogRWZmZWN0LFxuICByUlRHQnVmZmVyOiBFZmZlY3QsXG4gIHJSVEdCdWZmZXJMaWdodDogRWZmZWN0LFxuICBpUlRHU2hvdzogRWZmZWN0LFxuICBjUlRTUzogRWZmZWN0LFxuICBjUlREZW5vaXNlVGVtcG9yOiBFZmZlY3QsXG4gIGNSVERlbm9pc2VTcGFjZTogRWZmZWN0LFxuICBjQ3JlYXRlU2ltcGxlQmx1cjogKHJhZGl1czogbnVtYmVyKSA9PiBFZmZlY3Rcbn0gPSB7fSBhcyBhbnk7XG5cbmV4cG9ydCBkZWZhdWx0IGVmZmVjdHM7XG5cbmNvbnN0IGNvbW1vbk1hcmNvcyA9IHtcbiAgVVNFX1RFWENPT1JEXzA6IGZhbHNlLFxuICBVU0VfTk9STUFMOiBmYWxzZSxcbiAgVVNFX1RBTkdFTlQ6IGZhbHNlLFxuICBVU0VfQ09MT1JfMDogZmFsc2UsXG4gIFVTRV9URVhDT09SRF8xOiBmYWxzZVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGNvbnN0IGVtcHR5U3RvcmFnZUJ1ZmZlciA9IHtcbiAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICBncHVWYWx1ZTogY3JlYXRlR1BVQnVmZmVyKG5ldyBGbG9hdDMyQXJyYXkoNCksIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpXG4gIH07XG5cbiAgZWZmZWN0cy5yQ29sb3IgPSBuZXcgRWZmZWN0KCdyQ29sb3InLCB7XG4gICAgdnM6IHJlcXVpcmUoJy4vc2hhZGVycy9iYXNpYy9tb2RlbC52ZXJ0Lndnc2wnKSxcbiAgICBmczogcmVxdWlyZSgnLi9zaGFkZXJzL2Jhc2ljL2NvbG9yLmZyYWcud2dzbCcpLFxuICAgIHVuaWZvcm1EZXNjOiB7XG4gICAgICB1bmlmb3JtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfY29sb3InLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDFdKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBtYXJjb3M6IGNvbW1vbk1hcmNvc1xuICB9KTtcblxuICBlZmZlY3RzLnJVbmxpdCA9IG5ldyBFZmZlY3QoJ3JVbmxpdCcsIHtcbiAgICB2czogcmVxdWlyZSgnLi9zaGFkZXJzL2Jhc2ljL21vZGVsLnZlcnQud2dzbCcpLFxuICAgIGZzOiByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMvdW5saXQuZnJhZy53Z3NsJyksXG4gICAgdW5pZm9ybURlc2M6IHtcbiAgICAgIHVuaWZvcm1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JGYWN0b3InLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGV4dHVyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2Jhc2VDb2xvclRleHR1cmUnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMud2hpdGVcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHNhbXBsZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHttYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtaXBtYXBGaWx0ZXI6ICduZWFyZXN0J31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgbWFyY29zOiBjb21tb25NYXJjb3NcbiAgfSk7XG5cbiAgZWZmZWN0cy5yUEJSID0gbmV3IEVmZmVjdCgnclBCUicsIHtcbiAgICB2czogcmVxdWlyZSgnLi9zaGFkZXJzL2Jhc2ljL21vZGVsLnZlcnQud2dzbCcpLFxuICAgIGZzOiByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMvdW5saXQuZnJhZy53Z3NsJyksXG4gICAgdW5pZm9ybURlc2M6IHtcbiAgICAgIHVuaWZvcm1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JGYWN0b3InLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfbm9ybWFsVGV4dHVyZVNjYWxlJyxcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfbWV0YWxsaWNGYWN0b3InLFxuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMV0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9yb3VnaG5lc3NGYWN0b3InLFxuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMV0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zcGVjdWxhckZhY3RvcicsXG4gICAgICAgICAgdHlwZTogJ3ZlYzMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheShbM10pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9nbG9zc2luZXNzRmFjdG9yJyxcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKVxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHRleHR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JUZXh0dXJlJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9ub3JtYWxUZXh0dXJlJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3NwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHNhbXBsZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHttYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtaXBtYXBGaWx0ZXI6ICduZWFyZXN0J31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgbWFyY29zOiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25NYXJjb3MsIHtVU0VfU1BFQ19HTE9TUzogZmFsc2UsIFVTRV9HTEFTUzogZmFsc2V9KVxuICB9KTtcblxuICBlZmZlY3RzLnJTa3lib3ggPSBuZXcgRWZmZWN0KCdyU2t5Ym94Jywge1xuICAgIHZzOiByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMvc2t5Ym94LnZlcnQud2dzbCcpLFxuICAgIGZzOiByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMvc2t5Ym94LmZyYWcud2dzbCcpLFxuICAgIHVuaWZvcm1EZXNjOiB7XG4gICAgICB1bmlmb3JtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfY29sb3InLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSg0KSkgYXMgRmxvYXQzMkFycmF5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9mYWN0b3InLFxuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfcm90YXRpb24nLFxuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfZXhwb3N1cmUnLFxuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxKVxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHRleHR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9jdWJlVGV4dHVyZScsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5jdWJlV2hpdGVcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHNhbXBsZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHttYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtaXBtYXBGaWx0ZXI6ICduZWFyZXN0J31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSk7XG5cbiAgZWZmZWN0cy5yUlRHQnVmZmVyID0gbmV3IEVmZmVjdCgnclJUR0J1ZmZlcicsIHtcbiAgICB2czogcmVxdWlyZSgnLi9zaGFkZXJzL3JheS10cmFjaW5nL2didWZmZXIudmVydC53Z3NsJyksXG4gICAgZnM6IHJlcXVpcmUoJy4vc2hhZGVycy9yYXktdHJhY2luZy9nYnVmZmVyLmZyYWcud2dzbCcpLFxuICAgIHVuaWZvcm1EZXNjOiB7XG4gICAgICB1bmlmb3JtczogW1xuICAgICAgICAvLyBzdXBwb3J0IG1hdGVyaWFscyB1cCB0byAxMjhcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21hdElkMlRleHR1cmVzSWQnLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBmb3JtYXQ6ICdpMzInLFxuICAgICAgICAgIHNpemU6IDEyOCxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBJbnQzMkFycmF5KDIgKiAxMjgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JGYWN0b3JzJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgc2l6ZTogMTI4LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0ICogMTI4KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfbWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXMnLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBzaXplOiAxMjgsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDEyOClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3NwZWN1bGFyR2xvc3NpbmVzc0ZhY3RvcnMnLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBzaXplOiAxMjgsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDEyOClcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHRleHR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JUZXh0dXJlcycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5hcnJheTF3aGl0ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfbm9ybWFsVGV4dHVyZXMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuYXJyYXkxd2hpdGVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21ldGFsUm91Z2hPclNwZWNHbG9zc1RleHR1cmVzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmFycmF5MXdoaXRlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBzYW1wbGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfc2FtcGxlcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB7bWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJywgbWlwbWFwRmlsdGVyOiAnbmVhcmVzdCd9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgfSxcbiAgICBtYXJjb3M6IGNvbW1vbk1hcmNvc1xuICB9KTtcbiAgXG4gIGVmZmVjdHMuclJUR0J1ZmZlckxpZ2h0ID0gbmV3IEVmZmVjdCgnclJUR0J1ZmZlckxpZ2h0Jywge1xuICAgIHZzOiByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMvbW9kZWwudmVydC53Z3NsJyksXG4gICAgZnM6IHJlcXVpcmUoJy4vc2hhZGVycy9yYXktdHJhY2luZy9nYnVmZmVyTGlnaHQuZnJhZy53Z3NsJyksXG4gICAgdW5pZm9ybURlc2M6IHtcbiAgICAgIHVuaWZvcm1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9saWdodENvbG9yJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdGV4dHVyZXM6IFtdLFxuICAgICAgc2FtcGxlcnM6IFtdLFxuICAgIH0sXG4gICAgbWFyY29zOiBjb21tb25NYXJjb3NcbiAgfSk7XG5cbiAgZWZmZWN0cy5jUlRTUyA9IG5ldyBFZmZlY3QoJ2NSVFNTJywge1xuICAgIGNzOiByZXF1aXJlKCcuL3NoYWRlcnMvcmF5LXRyYWNpbmcvcnRzcy5jb21wLndnc2wnKSxcbiAgICB1bmlmb3JtRGVzYzoge1xuICAgICAgdW5pZm9ybXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3JhbmRvbXMnLFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxNilcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc3VwcG9ydCBtYXRlcmlhbHMgdXAgdG8gMTI4XG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9tYXRJZDJUZXh0dXJlc0lkJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgZm9ybWF0OiAnaTMyJyxcbiAgICAgICAgICBzaXplOiAxMjgsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgSW50MzJBcnJheSgyICogMTI4KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfYmFzZUNvbG9yRmFjdG9ycycsXG4gICAgICAgICAgdHlwZTogJ3ZlYzQnLFxuICAgICAgICAgIHNpemU6IDEyOCxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDEyOClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21ldGFsbGljUm91Z2huZXNzRmFjdG9yTm9ybWFsU2NhbGVNYXRlcmlhbFR5cGVzJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgc2l6ZTogMTI4LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxMjgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zcGVjdWxhckdsb3NzaW5lc3NGYWN0b3JzJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgc2l6ZTogMTI4LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxMjgpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBzdG9yYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfcG9zaXRpb25zJyxcbiAgICAgICAgICB0eXBlOiAndmVjMycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBlbXB0eVN0b3JhZ2VCdWZmZXIudmFsdWUsXG4gICAgICAgICAgZ3B1VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci5ncHVWYWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X25vcm1hbHMnLFxuICAgICAgICAgIHR5cGU6ICd2ZWMzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci52YWx1ZSxcbiAgICAgICAgICBncHVWYWx1ZTogZW1wdHlTdG9yYWdlQnVmZmVyLmdwdVZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfdXZzJyxcbiAgICAgICAgICB0eXBlOiAndmVjMicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBlbXB0eVN0b3JhZ2VCdWZmZXIudmFsdWUsXG4gICAgICAgICAgZ3B1VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci5ncHVWYWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21lc2hNYXRJbmRleGVzJyxcbiAgICAgICAgICB0eXBlOiAndmVjMicsXG4gICAgICAgICAgZm9ybWF0OiAndTMyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci52YWx1ZSxcbiAgICAgICAgICBncHVWYWx1ZTogZW1wdHlTdG9yYWdlQnVmZmVyLmdwdVZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfYnZoJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBlbXB0eVN0b3JhZ2VCdWZmZXIudmFsdWUsXG4gICAgICAgICAgZ3B1VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci5ncHVWYWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2RlYnVnSW5mbycsXG4gICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgY3VzdG9tU3RydWN0OiB7bmFtZTogJ0RlYnVnSW5mbycsIGNvZGU6IGBcbnN0cnVjdCBEZWJ1Z1JheSB7XG4gIHByZU9yaWdpbjogdmVjNDxmMzI+O1xuICBwcmVEaXI6IHZlYzQ8ZjMyPjtcbiAgb3JpZ2luOiB2ZWM0PGYzMj47XG4gIGRpcjogdmVjNDxmMzI+O1xuICBuZXh0T3JpZ2luOiB2ZWM0PGYzMj47XG4gIG5leHREaXI6IHZlYzQ8ZjMyPjtcbiAgbm9ybWFsOiB2ZWM0PGYzMj47XG59O1xuXG5bW2Jsb2NrXV0gc3RydWN0IERlYnVnSW5mbyB7XG4gIHJheXM6IGFycmF5PERlYnVnUmF5Pjtcbn07YFxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBlbXB0eVN0b3JhZ2VCdWZmZXIudmFsdWUsXG4gICAgICAgICAgZ3B1VmFsdWU6IGVtcHR5U3RvcmFnZUJ1ZmZlci5ncHVWYWx1ZVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGV4dHVyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X291dHB1dCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eSxcbiAgICAgICAgICBzdG9yYWdlQWNjZXNzOiAnd3JpdGUtb25seScsXG4gICAgICAgICAgc3RvcmFnZUZvcm1hdDogJ3JnYmExNmZsb2F0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfbm9pc2UnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2diUG9zaXRpb25NZXRhbE9yU3BlYycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfZ2JCYXNlQ29sb3JSb3VnaE9yR2xvc3MnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2diTm9ybWFsR2xhc3MnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2diTWVzaEluZGV4TWF0SW5kZXhNYXRUeXBlJyxcbiAgICAgICAgICBmb3JtYXQ6ICd1aW50JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9iYXNlQ29sb3JUZXh0dXJlcycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5hcnJheTF3aGl0ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfbm9ybWFsVGV4dHVyZXMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuYXJyYXkxd2hpdGVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21ldGFsUm91Z2hPclNwZWNHbG9zc1RleHR1cmVzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmFycmF5MXdoaXRlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBzYW1wbGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfc2FtcGxlcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB7bWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJywgbWlwbWFwRmlsdGVyOiAnbmVhcmVzdCd9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyR0InLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZToge21hZ0ZpbHRlcjogJ25lYXJlc3QnLCBtaW5GaWx0ZXI6ICduZWFyZXN0J31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgbWFyY29zOiB7QlZIX0RFUFRIOiAwfVxuICB9KTtcblxuICBlZmZlY3RzLmNSVERlbm9pc2VUZW1wb3IgPSBuZXcgRWZmZWN0KCdjUlREZW5vaXNlVGVtcG9yJywge1xuICAgIGNzOiByZXF1aXJlKCcuL3NoYWRlcnMvcmF5LXRyYWNpbmcvZGVub2lzZVRlbXBvci5jb21wLndnc2wnKSxcbiAgICB1bmlmb3JtRGVzYzoge1xuICAgICAgdW5pZm9ybXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3ByZVdlaWdodCcsXG4gICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgZm9ybWF0OiAnZjMyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGV4dHVyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X291dHB1dCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eSxcbiAgICAgICAgICBzdG9yYWdlQWNjZXNzOiAnd3JpdGUtb25seScsXG4gICAgICAgICAgc3RvcmFnZUZvcm1hdDogJ3JnYmExNmZsb2F0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfcHJlJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5LFxuICAgICAgICAgIHN0b3JhZ2VBY2Nlc3M6ICdyZWFkLW9ubHknLFxuICAgICAgICAgIHN0b3JhZ2VGb3JtYXQ6ICdyZ2JhMTZmbG9hdCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2N1cnJlbnQnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHksXG4gICAgICAgICAgc3RvcmFnZUFjY2VzczogJ3JlYWQtb25seScsXG4gICAgICAgICAgc3RvcmFnZUZvcm1hdDogJ3JnYmExNmZsb2F0J1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgc2FtcGxlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3NhbXBsZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZToge21hZ0ZpbHRlcjogJ2xpbmVhcicsIG1pbkZpbHRlcjogJ2xpbmVhcicsIG1pcG1hcEZpbHRlcjogJ25lYXJlc3QnfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICB9KTtcblxuICBlZmZlY3RzLmNSVERlbm9pc2VTcGFjZSA9IG5ldyBFZmZlY3QoJ2NSVERlbm9pc2VTcGFjZScsIHtcbiAgICBjczogcmVxdWlyZSgnLi9zaGFkZXJzL3JheS10cmFjaW5nL2Rlbm9pc2VTcGFjZS5jb21wLndnc2wnKSxcbiAgICB1bmlmb3JtRGVzYzoge1xuICAgICAgdW5pZm9ybXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIC8vIFtkaXN0YW5jZSwgY29sb3IsIGRlcHRoLCBub3JtYWxdXG4gICAgICAgICAgbmFtZTogJ3VfZmlsdGVyRmFjdG9ycycsXG4gICAgICAgICAgdHlwZTogJ3ZlYzInLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZW5HYXVzc2lhblBhcmFtcyhuZXcgRmxvYXQzMkFycmF5KFsxLjUsIDAuNSwgMS41LCAwLjVdKSwgWzIsIDMsIDEsIDNdKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGV4dHVyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X291dHB1dCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eSxcbiAgICAgICAgICBzdG9yYWdlQWNjZXNzOiAnd3JpdGUtb25seSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X21peGVkJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5LFxuICAgICAgICAgIHN0b3JhZ2VBY2Nlc3M6ICdyZWFkLW9ubHknLFxuICAgICAgICAgIHN0b3JhZ2VGb3JtYXQ6ICdyZ2JhMTZmbG9hdCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2diUG9zaXRpb25NZXRhbE9yU3BlYycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfZ2JOb3JtYWxHbGFzcycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eVxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHNhbXBsZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHttYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtaXBtYXBGaWx0ZXI6ICduZWFyZXN0J31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgbWFyY29zOiB7V0lORE9XX1NJWkU6IDd9XG4gIH0pO1xuXG4gIGVmZmVjdHMuaVJUR1Nob3cgPSBuZXcgRWZmZWN0KCdpUlRHU2hvdycsIHtcbiAgICB2czogcmVxdWlyZSgnLi9zaGFkZXJzL2ltYWdlL2ltYWdlLnZlcnQud2dzbCcpLFxuICAgIGZzOiByZXF1aXJlKCcuL3NoYWRlcnMvcmF5LXRyYWNpbmcvZ3Nob3cuZnJhZy53Z3NsJyksXG4gICAgdW5pZm9ybURlc2M6IHtcbiAgICAgIHVuaWZvcm1zOiBbXSxcbiAgICAgIHRleHR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9nYlBvc2l0aW9uTWV0YWxPclNwZWMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMuZW1wdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2diQmFzZUNvbG9yUm91Z2hPckdsb3NzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9nYk5vcm1hbEdsYXNzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLmVtcHR5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9nYk1lc2hJbmRleE1hdEluZGV4TWF0VHlwZScsXG4gICAgICAgICAgZm9ybWF0OiAndWludCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5lbXB0eVxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHNhbXBsZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9zYW1wbGVyJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHttYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBtYXJjb3M6IHtGTElQOiBmYWxzZX1cbiAgfSk7XG5cbiAgZWZmZWN0cy5pQmxpdCA9IG5ldyBFZmZlY3QoJ2lCbGl0Jywge1xuICAgIHZzOiByZXF1aXJlKCcuL3NoYWRlcnMvaW1hZ2UvaW1hZ2UudmVydC53Z3NsJyksXG4gICAgZnM6IHJlcXVpcmUoJy4vc2hhZGVycy9pbWFnZS9ibGl0LmZyYWcud2dzbCcpLFxuICAgIHVuaWZvcm1EZXNjOiB7XG4gICAgICB1bmlmb3JtczogW10sXG4gICAgICB0ZXh0dXJlczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfdGV4dHVyZScsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy53aGl0ZVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgc2FtcGxlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3NhbXBsZXInLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZToge21hZ0ZpbHRlcjogJ2xpbmVhcicsIG1pbkZpbHRlcjogJ2xpbmVhcid9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIG1hcmNvczoge0ZMSVA6IGZhbHNlfVxuICB9KTtcblxuICBlZmZlY3RzLmlUb25lID0gbmV3IEVmZmVjdCgnaVRvbmUnLCB7XG4gICAgdnM6IHJlcXVpcmUoJy4vc2hhZGVycy9pbWFnZS9pbWFnZS52ZXJ0Lndnc2wnKSxcbiAgICBmczogcmVxdWlyZSgnLi9zaGFkZXJzL2ltYWdlL3RvbmUuZnJhZy53Z3NsJyksXG4gICAgdW5pZm9ybURlc2M6IHtcbiAgICAgIHVuaWZvcm1zOiBbXSxcbiAgICAgIHRleHR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV90ZXh0dXJlJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLndoaXRlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBzYW1wbGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfc2FtcGxlcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB7bWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJ31cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgbWFyY29zOiB7RkxJUDogZmFsc2V9XG4gIH0pO1xuXG4gIGVmZmVjdHMuY0NyZWF0ZVNpbXBsZUJsdXIgPSAocmFkaXVzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZWFsS2VybmVsU2l6ZSA9IE1hdGgucG93KChyYWRpdXMgKiAyICsgMSksIDIpO1xuICAgIGNvbnN0IG1vZCA9IHJlYWxLZXJuZWxTaXplICUgNDtcbiAgICBjb25zdCBrZXJuZWxTaXplID0gcmVhbEtlcm5lbFNpemUgKyAoNCAtIG1vZCk7XG5cbiAgICByZXR1cm4gbmV3IEVmZmVjdCgnY1NpbXBsZUJsdXItJyArIHJhZGl1cywge1xuICAgICAgY3M6IHJlcXVpcmUoJy4vc2hhZGVycy9jb21wdXRlL2JsdXIuY29tcC53Z3NsJyksXG4gICAgICB1bmlmb3JtRGVzYzoge1xuICAgICAgICB1bmlmb3JtczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1X2tlcm5lbCcsXG4gICAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgICBzaXplOiBrZXJuZWxTaXplIC8gNCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheShrZXJuZWxTaXplKS5maWxsKDEpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0ZXh0dXJlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1X2lucHV0JyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGV4dHVyZXMud2hpdGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1X291dHB1dCcsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRleHR1cmVzLndoaXRlLFxuICAgICAgICAgICAgc3RvcmFnZUFjY2VzczogJ3dyaXRlLW9ubHknXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzYW1wbGVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1X3NhbXBsZXInLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB7bWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJ31cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBtYXJjb3M6IHtSQURJVVM6IHJhZGl1cywgV0lORE9XX1NJWkU6IHJhZGl1cyAqIDIgKyAxLCBUSUxFX1NJWkU6IHJhZGl1cyAqIDQgKyAxfVxuICAgIH0pO1xuICB9O1xufVxuIl19

/***/ }),

/***/ "./src/buildin/geometries.ts":
/*!***********************************!*\
  !*** ./src/buildin/geometries.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = void 0;
var Geometry_1 = __webpack_require__(/*! ../core/Geometry */ "./src/core/Geometry.ts");
var geometries = {};
exports["default"] = geometries;
function init() {
    geometries.skybox = new Geometry_1.default([
        {
            layout: {
                arrayStride: 8,
                attributes: [
                    {
                        name: 'position',
                        shaderLocation: 0, offset: 0,
                        format: 'float32x2'
                    },
                ]
            },
            data: new Float32Array([
                -1.0, -1.0,
                1.0, -1.0,
                -1.0, 1.0,
                -1.0, 1.0,
                1.0, -1.0,
                1.0, 1.0
            ]),
        }
    ], new Uint16Array([
        0, 1, 2, 3, 4, 5,
    ]), 6);
    geometries.rectLight = new Geometry_1.default([
        {
            layout: {
                arrayStride: 12,
                attributes: [
                    {
                        name: 'position',
                        shaderLocation: 0, offset: 0,
                        format: 'float32x3'
                    },
                ]
            },
            data: new Float32Array([
                -.5, -.5, 0,
                .5, -.5, 0,
                .5, .5, 0,
                -.5, .5, 0
            ]),
        }
    ], new Uint16Array([
        0, 1, 2, 2, 3, 0
    ]), 6);
    var discLightData = createDisc(512);
    geometries.discLight = new Geometry_1.default([
        {
            layout: {
                arrayStride: 12,
                attributes: [
                    {
                        name: 'position',
                        shaderLocation: 0, offset: 0,
                        format: 'float32x3'
                    },
                ]
            },
            data: discLightData.vertexes,
        }
    ], discLightData.indexes, discLightData.indexes.length);
}
exports.init = init;
function createDisc(samples) {
    var step = Math.PI * 2 / samples;
    var vertexes = new Float32Array((1 + samples) * 3);
    var indexes = new Uint16Array(samples * 3);
    vertexes.set([0, 0, 0]);
    var theta = 0;
    for (var index = 0; index < samples; index += 1) {
        vertexes[(index + 1) * 3] = Math.cos(theta);
        vertexes[(index + 1) * 3 + 1] = Math.sin(theta);
        vertexes[(index + 1) * 3 + 2] = 0;
        indexes[index * 3] = 0;
        indexes[index * 3 + 1] = index + 2;
        indexes[index * 3 + 2] = index + 1;
        theta += step;
    }
    return { vertexes: vertexes, indexes: indexes };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvbWV0cmllcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdlb21ldHJpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBTUEsNkNBQXdDO0FBRXhDLElBQU0sVUFBVSxHQUlaLEVBQVMsQ0FBQztBQUVkLGtCQUFlLFVBQVUsQ0FBQztBQUUxQixTQUFnQixJQUFJO0lBQ2xCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsSUFBSSxrQkFBUSxDQUM5QjtRQUNFO1lBQ0UsTUFBTSxFQUFFO2dCQUNOLFdBQVcsRUFBRSxDQUFDO2dCQUNkLFVBQVUsRUFBRTtvQkFDVjt3QkFDRSxJQUFJLEVBQUUsVUFBVTt3QkFDaEIsY0FBYyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQzt3QkFDNUIsTUFBTSxFQUFFLFdBQThCO3FCQUN2QztpQkFDRjthQUNGO1lBQ0QsSUFBSSxFQUFFLElBQUksWUFBWSxDQUFDO2dCQUNyQixDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUc7Z0JBQ1YsR0FBRyxFQUFFLENBQUMsR0FBRztnQkFDVCxDQUFDLEdBQUcsRUFBRSxHQUFHO2dCQUNULENBQUMsR0FBRyxFQUFFLEdBQUc7Z0JBQ1QsR0FBRyxFQUFFLENBQUMsR0FBRztnQkFDVCxHQUFHLEVBQUUsR0FBRzthQUNULENBQUM7U0FDSDtLQUNGLEVBQ0QsSUFBSSxXQUFXLENBQUM7UUFDZCxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7S0FDWixDQUFDLEVBQ0YsQ0FBQyxDQUNGLENBQUM7SUFFRixVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksa0JBQVEsQ0FDakM7UUFDRTtZQUNFLE1BQU0sRUFBRTtnQkFDTixXQUFXLEVBQUUsRUFBRTtnQkFDZixVQUFVLEVBQUU7b0JBQ1Y7d0JBQ0UsSUFBSSxFQUFFLFVBQVU7d0JBQ2hCLGNBQWMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUM7d0JBQzVCLE1BQU0sRUFBRSxXQUE4QjtxQkFDdkM7aUJBQ0Y7YUFDRjtZQUNELElBQUksRUFBRSxJQUFJLFlBQVksQ0FBQztnQkFDckIsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDWCxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDVixFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ1QsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7YUFDWCxDQUFDO1NBQ0g7S0FDRixFQUNELElBQUksV0FBVyxDQUFDO1FBQ2QsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO0tBQ1osQ0FBQyxFQUNGLENBQUMsQ0FDRixDQUFDO0lBRUYsSUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxrQkFBUSxDQUNqQztRQUNFO1lBQ0UsTUFBTSxFQUFFO2dCQUNOLFdBQVcsRUFBRSxFQUFFO2dCQUNmLFVBQVUsRUFBRTtvQkFDVjt3QkFDRSxJQUFJLEVBQUUsVUFBVTt3QkFDaEIsY0FBYyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQzt3QkFDNUIsTUFBTSxFQUFFLFdBQThCO3FCQUN2QztpQkFDRjthQUNGO1lBQ0QsSUFBSSxFQUFFLGFBQWEsQ0FBQyxRQUFRO1NBQzdCO0tBQ0YsRUFDRCxhQUFhLENBQUMsT0FBTyxFQUNyQixhQUFhLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FDN0IsQ0FBQztBQUNKLENBQUM7QUE3RUQsb0JBNkVDO0FBRUQsU0FBUyxVQUFVLENBQUMsT0FBZTtJQUNqQyxJQUFNLElBQUksR0FBVyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDM0MsSUFBTSxRQUFRLEdBQWlCLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ25FLElBQU0sT0FBTyxHQUFnQixJQUFJLFdBQVcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUQsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV4QixJQUFJLEtBQUssR0FBVyxDQUFDLENBQUM7SUFDdEIsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFO1FBQy9DLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoRCxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVsQyxPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7UUFFbkMsS0FBSyxJQUFJLElBQUksQ0FBQztLQUNmO0lBRUQsT0FBTyxFQUFDLFFBQVEsVUFBQSxFQUFFLE9BQU8sU0FBQSxFQUFDLENBQUM7QUFDN0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZ2VvbWV0cmllcy50c1xuICogXG4gKiBAQXV0aG9yICA6ZHR5c2t5KGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBEYXRlICAgIDogNi85LzIwMjEsIDc6MTY6NTIgUE1cbiovXG5pbXBvcnQgR2VvbWV0cnkgZnJvbSBcIi4uL2NvcmUvR2VvbWV0cnlcIjtcblxuY29uc3QgZ2VvbWV0cmllczoge1xuICBza3lib3g6IEdlb21ldHJ5LFxuICBkaXNjTGlnaHQ6IEdlb21ldHJ5LFxuICByZWN0TGlnaHQ6IEdlb21ldHJ5XG59ID0ge30gYXMgYW55O1xuXG5leHBvcnQgZGVmYXVsdCBnZW9tZXRyaWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgZ2VvbWV0cmllcy5za3lib3ggPSBuZXcgR2VvbWV0cnkoXG4gICAgW1xuICAgICAge1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBhcnJheVN0cmlkZTogOCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAwLCBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGZvcm1hdDogJ2Zsb2F0MzJ4MicgYXMgR1BVVmVydGV4Rm9ybWF0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgLTEuMCwgLTEuMCxcbiAgICAgICAgICAxLjAsIC0xLjAsXG4gICAgICAgICAgLTEuMCwgMS4wLFxuICAgICAgICAgIC0xLjAsIDEuMCxcbiAgICAgICAgICAxLjAsIC0xLjAsXG4gICAgICAgICAgMS4wLCAxLjBcbiAgICAgICAgXSksXG4gICAgICB9XG4gICAgXSxcbiAgICBuZXcgVWludDE2QXJyYXkoW1xuICAgICAgMCwxLDIsMyw0LDUsXG4gICAgXSksXG4gICAgNlxuICApO1xuXG4gIGdlb21ldHJpZXMucmVjdExpZ2h0ID0gbmV3IEdlb21ldHJ5KFxuICAgIFtcbiAgICAgIHtcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgYXJyYXlTdHJpZGU6IDEyLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngzJyBhcyBHUFVWZXJ0ZXhGb3JtYXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAtLjUsIC0uNSwgMCxcbiAgICAgICAgICAuNSwgLS41LCAwLFxuICAgICAgICAgIC41LCAuNSwgMCxcbiAgICAgICAgICAtLjUsIC41LCAwXG4gICAgICAgIF0pLFxuICAgICAgfVxuICAgIF0sXG4gICAgbmV3IFVpbnQxNkFycmF5KFtcbiAgICAgIDAsMSwyLDIsMywwXG4gICAgXSksXG4gICAgNlxuICApO1xuXG4gIGNvbnN0IGRpc2NMaWdodERhdGEgPSBjcmVhdGVEaXNjKDUxMik7XG4gIGdlb21ldHJpZXMuZGlzY0xpZ2h0ID0gbmV3IEdlb21ldHJ5KFxuICAgIFtcbiAgICAgIHtcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgYXJyYXlTdHJpZGU6IDEyLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngzJyBhcyBHUFVWZXJ0ZXhGb3JtYXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBkaXNjTGlnaHREYXRhLnZlcnRleGVzLFxuICAgICAgfVxuICAgIF0sXG4gICAgZGlzY0xpZ2h0RGF0YS5pbmRleGVzLFxuICAgIGRpc2NMaWdodERhdGEuaW5kZXhlcy5sZW5ndGhcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlzYyhzYW1wbGVzOiBudW1iZXIpOiB7dmVydGV4ZXM6IEZsb2F0MzJBcnJheSwgaW5kZXhlczogVWludDE2QXJyYXl9IHtcbiAgY29uc3Qgc3RlcDogbnVtYmVyID0gTWF0aC5QSSAqIDIgLyBzYW1wbGVzO1xuICBjb25zdCB2ZXJ0ZXhlczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgoMSArIHNhbXBsZXMpICogMyk7XG4gIGNvbnN0IGluZGV4ZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNhbXBsZXMgKiAzKTtcbiAgdmVydGV4ZXMuc2V0KFswLCAwLCAwXSk7XG5cbiAgbGV0IHRoZXRhOiBudW1iZXIgPSAwO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2FtcGxlczsgaW5kZXggKz0gMSkge1xuICAgIHZlcnRleGVzWyhpbmRleCArIDEpICogM10gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmVydGV4ZXNbKGluZGV4ICsgMSkgKiAzICsgMV0gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgdmVydGV4ZXNbKGluZGV4ICsgMSkgKiAzICsgMl0gPSAwO1xuXG4gICAgaW5kZXhlc1tpbmRleCAqIDNdID0gMDtcbiAgICBpbmRleGVzW2luZGV4ICogMyArIDFdID0gaW5kZXggKyAyO1xuICAgIGluZGV4ZXNbaW5kZXggKiAzICsgMl0gPSBpbmRleCArIDE7XG5cbiAgICB0aGV0YSArPSBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHt2ZXJ0ZXhlcywgaW5kZXhlc307XG59XG4iXX0=

/***/ }),

/***/ "./src/buildin/index.ts":
/*!******************************!*\
  !*** ./src/buildin/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = exports.buildinUBTemplates = exports.buildinEffects = exports.buildinGeometries = exports.buildinTextures = void 0;
var textures_1 = __webpack_require__(/*! ./textures */ "./src/buildin/textures.ts");
exports.buildinTextures = textures_1.default;
var geometries_1 = __webpack_require__(/*! ./geometries */ "./src/buildin/geometries.ts");
exports.buildinGeometries = geometries_1.default;
var effects_1 = __webpack_require__(/*! ./effects */ "./src/buildin/effects.ts");
exports.buildinEffects = effects_1.default;
var ubTemplates_1 = __webpack_require__(/*! ./ubTemplates */ "./src/buildin/ubTemplates.ts");
exports.buildinUBTemplates = ubTemplates_1.default;
function init() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, textures_1.init()];
                case 1:
                    _a.sent();
                    ubTemplates_1.init();
                    geometries_1.init();
                    effects_1.init();
                    return [2];
            }
        });
    });
}
exports.init = init;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSx1Q0FBaUU7QUFDekQsMEJBREQsa0JBQWUsQ0FDQztBQUN2QiwyQ0FBdUU7QUFDL0QsNEJBREQsb0JBQWlCLENBQ0M7QUFDekIscUNBQThEO0FBQ3RELHlCQURELGlCQUFjLENBQ0M7QUFDdEIsNkNBQTBFO0FBQ2xFLDZCQURELHFCQUFrQixDQUNDO0FBRTFCLFNBQXNCLElBQUk7Ozs7d0JBQ3hCLFdBQU0sZUFBWSxFQUFFLEVBQUE7O29CQUFwQixTQUFvQixDQUFDO29CQUNyQixrQkFBZSxFQUFFLENBQUM7b0JBQ2xCLGlCQUFjLEVBQUUsQ0FBQztvQkFDakIsY0FBVyxFQUFFLENBQUM7Ozs7O0NBQ2Y7QUFMRCxvQkFLQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IGluZGV4LnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2IODo1Njo0OVxuICovXG5pbXBvcnQgYnVpbGRpblRleHR1cmVzLCB7aW5pdCBhcyBpbml0VGV4dHVyZXN9IGZyb20gJy4vdGV4dHVyZXMnO1xuZXhwb3J0IHtidWlsZGluVGV4dHVyZXN9O1xuaW1wb3J0IGJ1aWxkaW5HZW9tZXRyaWVzLCB7aW5pdCBhcyBpbml0R2VvbWV0cmllc30gZnJvbSAnLi9nZW9tZXRyaWVzJztcbmV4cG9ydCB7YnVpbGRpbkdlb21ldHJpZXN9O1xuaW1wb3J0IGJ1aWxkaW5FZmZlY3RzLCB7aW5pdCBhcyBpbml0RWZmZWN0c30gZnJvbSAnLi9lZmZlY3RzJztcbmV4cG9ydCB7YnVpbGRpbkVmZmVjdHN9O1xuaW1wb3J0IGJ1aWxkaW5VQlRlbXBsYXRlcywge2luaXQgYXMgaW5pdFVCVGVtcGxhdGVzfSBmcm9tICcuL3ViVGVtcGxhdGVzJztcbmV4cG9ydCB7YnVpbGRpblVCVGVtcGxhdGVzfTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gIGF3YWl0IGluaXRUZXh0dXJlcygpO1xuICBpbml0VUJUZW1wbGF0ZXMoKTtcbiAgaW5pdEdlb21ldHJpZXMoKTtcbiAgaW5pdEVmZmVjdHMoKTtcbn1cbiJdfQ==

/***/ }),

/***/ "./src/buildin/textures.ts":
/*!*********************************!*\
  !*** ./src/buildin/textures.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = void 0;
var CubeTexture_1 = __webpack_require__(/*! ../core/CubeTexture */ "./src/core/CubeTexture.ts");
var shared_1 = __webpack_require__(/*! ../core/shared */ "./src/core/shared.ts");
var Texture_1 = __webpack_require__(/*! ../core/Texture */ "./src/core/Texture.ts");
var textures = {};
exports["default"] = textures;
function createTexture(width, height, buffer) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c, _d;
        var _this = this;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (!shared_1.isArray(buffer)) return [3, 2];
                    _a = Texture_1.default.bind;
                    _b = [void 0, width, height];
                    return [4, Promise.all(buffer.map(function (b) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, createImageBitmap(new ImageData(b, width, height))];
                                    case 1: return [2, _a.sent()];
                                }
                            });
                        }); }))];
                case 1: return [2, new (_a.apply(Texture_1.default, _b.concat([_e.sent()])))()];
                case 2:
                    _c = Texture_1.default.bind;
                    _d = [void 0, width, height];
                    return [4, createImageBitmap(new ImageData(buffer, width, height))];
                case 3: return [2, new (_c.apply(Texture_1.default, _d.concat([_e.sent()])))()];
            }
        });
    });
}
function init() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c, _d, _e, _f, _g;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _a = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([255, 255, 255, 255]))];
                case 1:
                    _a.empty = _h.sent();
                    _b = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([255, 255, 255, 255]))];
                case 2:
                    _b.white = _h.sent();
                    _c = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([0, 0, 0, 255]))];
                case 3:
                    _c.black = _h.sent();
                    _d = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([255, 0, 0, 255]))];
                case 4:
                    _d.red = _h.sent();
                    _e = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([0, 255, 0, 255]))];
                case 5:
                    _e.green = _h.sent();
                    _f = textures;
                    return [4, createTexture(1, 1, new Uint8ClampedArray([0, 0, 255, 255]))];
                case 6:
                    _f.blue = _h.sent();
                    _g = textures;
                    return [4, createTexture(1, 1, [
                            new Uint8ClampedArray([255, 255, 255, 255]),
                            new Uint8ClampedArray([255, 255, 255, 255])
                        ])];
                case 7:
                    _g.array1white = _h.sent();
                    textures.cubeWhite = new CubeTexture_1.default(1, 1, new Array(6).fill(new Uint8Array([255, 255, 255, 255]).buffer));
                    textures.cubeBlack = new CubeTexture_1.default(1, 1, new Array(6).fill(new Uint8Array([0, 0, 0, 255]).buffer));
                    return [2];
            }
        });
    });
}
exports.init = init;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dHVyZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXh0dXJlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSxtREFBOEM7QUFDOUMseUNBQXlDO0FBQ3pDLDJDQUFzQztBQUV0QyxJQUFNLFFBQVEsR0FhVixFQUFTLENBQUM7QUFFZCxrQkFBZSxRQUFRLENBQUM7QUFFeEIsU0FBZSxhQUFhLENBQUMsS0FBYSxFQUFFLE1BQWMsRUFBRSxNQUErQzs7Ozs7Ozt5QkFDckcsZ0JBQU8sQ0FBb0IsTUFBTSxDQUFDLEVBQWxDLGNBQWtDO3lCQUN6QixpQkFBTztrQ0FBQyxLQUFLLEVBQUUsTUFBTTtvQkFBRSxXQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFNLENBQUM7Ozs0Q0FDN0QsV0FBTSxpQkFBaUIsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUE7NENBQS9ELFdBQU8sU0FBd0QsRUFBQzs7OzZCQUNqRSxDQUFDLENBQUMsRUFBQTt3QkFGSCxXQUFPLGNBQUksaUJBQU8sYUFBZ0IsU0FFL0IsTUFBQyxFQUFDOzt5QkFFTSxpQkFBTztrQ0FBQyxLQUFLLEVBQUUsTUFBTTtvQkFBRSxXQUFNLGlCQUFpQixDQUFDLElBQUksU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBQTt3QkFBL0YsV0FBTyxjQUFJLGlCQUFPLGFBQWdCLFNBQTZELE1BQUMsRUFBQzs7OztDQUVwRztBQUVELFNBQXNCLElBQUk7Ozs7OztvQkFDeEIsS0FBQSxRQUFRLENBQUE7b0JBQVMsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBdkYsR0FBUyxLQUFLLEdBQUcsU0FBc0UsQ0FBQztvQkFDeEYsS0FBQSxRQUFRLENBQUE7b0JBQVMsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBdkYsR0FBUyxLQUFLLEdBQUcsU0FBc0UsQ0FBQztvQkFDeEYsS0FBQSxRQUFRLENBQUE7b0JBQVMsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBakYsR0FBUyxLQUFLLEdBQUcsU0FBZ0UsQ0FBQztvQkFDbEYsS0FBQSxRQUFRLENBQUE7b0JBQU8sV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBakYsR0FBUyxHQUFHLEdBQUcsU0FBa0UsQ0FBQztvQkFDbEYsS0FBQSxRQUFRLENBQUE7b0JBQVMsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBbkYsR0FBUyxLQUFLLEdBQUcsU0FBa0UsQ0FBQztvQkFDcEYsS0FBQSxRQUFRLENBQUE7b0JBQVEsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFBOztvQkFBbEYsR0FBUyxJQUFJLEdBQUcsU0FBa0UsQ0FBQztvQkFDbkYsS0FBQSxRQUFRLENBQUE7b0JBQWUsV0FBTSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTs0QkFDL0MsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDOzRCQUMzQyxJQUFJLGlCQUFpQixDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7eUJBQzVDLENBQUMsRUFBQTs7b0JBSEYsR0FBUyxXQUFXLEdBQUcsU0FHckIsQ0FBQztvQkFDSCxRQUFRLENBQUMsU0FBUyxHQUFHLElBQUkscUJBQVcsQ0FDbEMsQ0FBQyxFQUFFLENBQUMsRUFDSixJQUFJLEtBQUssQ0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUM1RSxDQUFDO29CQUNGLFFBQVEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxxQkFBVyxDQUNsQyxDQUFDLEVBQUUsQ0FBQyxFQUNKLElBQUksS0FBSyxDQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQ3RFLENBQUM7Ozs7O0NBQ0g7QUFuQkQsb0JBbUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogdGV4dHVyZXMudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzbkuIvljYg4OjU2OjQ5XG4gKi9cbmltcG9ydCBDdWJlVGV4dHVyZSBmcm9tIFwiLi4vY29yZS9DdWJlVGV4dHVyZVwiO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gXCIuLi9jb3JlL3NoYXJlZFwiO1xuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL2NvcmUvVGV4dHVyZVwiO1xuXG5jb25zdCB0ZXh0dXJlczoge1xuICAvKipcbiAgICogQSB0cmljayBmb3IgZGVmYXVsdFZhbHVlXG4gICAqL1xuICBlbXB0eTogVGV4dHVyZSxcbiAgd2hpdGU6IFRleHR1cmUsXG4gIHJlZDogVGV4dHVyZSxcbiAgZ3JlZW46IFRleHR1cmUsXG4gIGJsdWU6IFRleHR1cmUsXG4gIGJsYWNrOiBUZXh0dXJlLFxuICBhcnJheTF3aGl0ZTogVGV4dHVyZSxcbiAgY3ViZVdoaXRlOiBDdWJlVGV4dHVyZSxcbiAgY3ViZUJsYWNrOiBDdWJlVGV4dHVyZVxufSA9IHt9IGFzIGFueTtcblxuZXhwb3J0IGRlZmF1bHQgdGV4dHVyZXM7XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGJ1ZmZlcjogVWludDhDbGFtcGVkQXJyYXkgfCBVaW50OENsYW1wZWRBcnJheVtdKSB7XG4gIGlmIChpc0FycmF5PFVpbnQ4Q2xhbXBlZEFycmF5PihidWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGF3YWl0IFByb21pc2UuYWxsKGJ1ZmZlci5tYXAoYXN5bmMgYiA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAobmV3IEltYWdlRGF0YShiLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfSkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFRleHR1cmUod2lkdGgsIGhlaWdodCwgYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAobmV3IEltYWdlRGF0YShidWZmZXIsIHdpZHRoLCBoZWlnaHQpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRleHR1cmVzLmVtcHR5ID0gYXdhaXQgY3JlYXRlVGV4dHVyZSgxLCAxLCBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NV0pKTtcbiAgdGV4dHVyZXMud2hpdGUgPSBhd2FpdCBjcmVhdGVUZXh0dXJlKDEsIDEsIG5ldyBVaW50OENsYW1wZWRBcnJheShbMjU1LCAyNTUsIDI1NSwgMjU1XSkpO1xuICB0ZXh0dXJlcy5ibGFjayA9IGF3YWl0IGNyZWF0ZVRleHR1cmUoMSwgMSwgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFswLCAwLCAwLCAyNTVdKSk7XG4gIHRleHR1cmVzLnJlZCA9IGF3YWl0IGNyZWF0ZVRleHR1cmUoMSwgMSwgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsyNTUsIDAsIDAsIDI1NV0pKTtcbiAgdGV4dHVyZXMuZ3JlZW4gPSBhd2FpdCBjcmVhdGVUZXh0dXJlKDEsIDEsIG5ldyBVaW50OENsYW1wZWRBcnJheShbMCwgMjU1LCAwLCAyNTVdKSk7XG4gIHRleHR1cmVzLmJsdWUgPSBhd2FpdCBjcmVhdGVUZXh0dXJlKDEsIDEsIG5ldyBVaW50OENsYW1wZWRBcnJheShbMCwgMCwgMjU1LCAyNTVdKSk7XG4gIHRleHR1cmVzLmFycmF5MXdoaXRlID0gYXdhaXQgY3JlYXRlVGV4dHVyZSgxLCAxLCBbXG4gICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTVdKSxcbiAgICBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NV0pXG4gIF0pO1xuICB0ZXh0dXJlcy5jdWJlV2hpdGUgPSBuZXcgQ3ViZVRleHR1cmUoXG4gICAgMSwgMSxcbiAgICBuZXcgQXJyYXk8QXJyYXlCdWZmZXI+KDYpLmZpbGwobmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NV0pLmJ1ZmZlcilcbiAgKTtcbiAgdGV4dHVyZXMuY3ViZUJsYWNrID0gbmV3IEN1YmVUZXh0dXJlKFxuICAgIDEsIDEsXG4gICAgbmV3IEFycmF5PEFycmF5QnVmZmVyPig2KS5maWxsKG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKS5idWZmZXIpXG4gICk7XG59XG4iXX0=

/***/ }),

/***/ "./src/buildin/ubTemplates.ts":
/*!************************************!*\
  !*** ./src/buildin/ubTemplates.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var UBTemplate_1 = __webpack_require__(/*! ../core/UBTemplate */ "./src/core/UBTemplate.ts");
var textures_1 = __webpack_require__(/*! ./textures */ "./src/buildin/textures.ts");
var ubTemplates = {};
exports["default"] = ubTemplates;
function init() {
    ubTemplates.global = new UBTemplate_1.default({
        uniforms: [
            {
                name: 'u_vp',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_view',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_proj',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_viewInverse',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_projInverse',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_skyVP',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
            {
                name: 'u_gameTime',
                type: 'number',
                defaultValue: new Float32Array([0])
            },
            {
                name: 'u_envColor',
                type: 'vec4',
                defaultValue: new Float32Array([0, 0, 0, 0])
            },
            {
                name: 'u_lightInfos',
                customType: {
                    name: 'LightInfo',
                    len: 40,
                    code: "\nstruct LightInfo {\n  lightType: u32;\n  areaMode: u32;\n  areaSize: vec2<f32>;\n  color: vec4<f32>;\n  worldTransform: mat4x4<f32>;\n  worldTransformInverse: mat4x4<f32>;\n};"
                },
                type: 'vec4',
                size: 4,
                defaultValue: new Float32Array(40 * 4)
            }
        ],
        textures: [
            {
                name: 'u_envTexture',
                defaultValue: textures_1.default.cubeBlack
            }
        ]
    }, UBTemplate_1.EUBGroup.Global);
    ubTemplates.staticMesh = new UBTemplate_1.default({
        uniforms: [
            {
                name: 'u_world',
                type: 'mat4x4',
                defaultValue: gl_matrix_1.mat4.identity(new Float32Array(16))
            },
        ]
    }, UBTemplate_1.EUBGroup.Mesh);
}
exports.init = init;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWJUZW1wbGF0ZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ1YlRlbXBsYXRlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFNQSx1Q0FBK0I7QUFDL0IsaURBQTBEO0FBQzFELHVDQUFrQztBQUVsQyxJQUFNLFdBQVcsR0FHYixFQUFTLENBQUM7QUFFZCxrQkFBZSxXQUFXLENBQUM7QUFFM0IsU0FBZ0IsSUFBSTtJQUNsQixXQUFXLENBQUMsTUFBTSxHQUFHLElBQUksb0JBQVUsQ0FDakM7UUFDRSxRQUFRLEVBQUU7WUFDUjtnQkFDRSxJQUFJLEVBQUUsTUFBTTtnQkFDWixJQUFJLEVBQUUsUUFBUTtnQkFDZCxZQUFZLEVBQUUsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDLENBQWlCO2FBQ2xFO1lBQ0Q7Z0JBQ0UsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsWUFBWSxFQUFFLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFpQjthQUNsRTtZQUNEO2dCQUNFLElBQUksRUFBRSxRQUFRO2dCQUNkLElBQUksRUFBRSxRQUFRO2dCQUNkLFlBQVksRUFBRSxnQkFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBaUI7YUFDbEU7WUFDRDtnQkFDRSxJQUFJLEVBQUUsZUFBZTtnQkFDckIsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsWUFBWSxFQUFFLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFpQjthQUNsRTtZQUNEO2dCQUNFLElBQUksRUFBRSxlQUFlO2dCQUNyQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxZQUFZLEVBQUUsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDLENBQWlCO2FBQ2xFO1lBQ0Q7Z0JBQ0UsSUFBSSxFQUFFLFNBQVM7Z0JBQ2YsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsWUFBWSxFQUFFLGdCQUFJLENBQUMsUUFBUSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFpQjthQUNsRTtZQUNEO2dCQUNFLElBQUksRUFBRSxZQUFZO2dCQUNsQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxZQUFZLEVBQUUsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwQztZQUNEO2dCQUNFLElBQUksRUFBRSxZQUFZO2dCQUNsQixJQUFJLEVBQUUsTUFBTTtnQkFDWixZQUFZLEVBQUUsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUM3QztZQUNEO2dCQUVFLElBQUksRUFBRSxjQUFjO2dCQUNwQixVQUFVLEVBQUU7b0JBQ1YsSUFBSSxFQUFFLFdBQVc7b0JBQ2pCLEdBQUcsRUFBRSxFQUFFO29CQUNQLElBQUksRUFBRSxtTEFRZjtpQkFDUTtnQkFDRCxJQUFJLEVBQUUsTUFBTTtnQkFDWixJQUFJLEVBQUUsQ0FBQztnQkFDUCxZQUFZLEVBQUUsSUFBSSxZQUFZLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQzthQUN2QztTQUNGO1FBQ0QsUUFBUSxFQUFFO1lBQ1I7Z0JBQ0UsSUFBSSxFQUFFLGNBQWM7Z0JBQ3BCLFlBQVksRUFBRSxrQkFBUSxDQUFDLFNBQVM7YUFDakM7U0FDRjtLQUNGLEVBQ0QscUJBQVEsQ0FBQyxNQUFNLENBQ2hCLENBQUM7SUFFRixXQUFXLENBQUMsVUFBVSxHQUFHLElBQUksb0JBQVUsQ0FDckM7UUFDRSxRQUFRLEVBQUU7WUFDUjtnQkFDRSxJQUFJLEVBQUUsU0FBUztnQkFDZixJQUFJLEVBQUUsUUFBUTtnQkFDZCxZQUFZLEVBQUUsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDLENBQWlCO2FBQ2xFO1NBQ0Y7S0FDRixFQUNELHFCQUFRLENBQUMsSUFBSSxDQUNkLENBQUM7QUFDSixDQUFDO0FBdkZELG9CQXVGQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IHViVGVtcGxhdGVzLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICAgOiA2LzI0LzIwMjEsIDIzOjAwOjU1IFBNXG4gKi9cbmltcG9ydCB7bWF0NH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBVQlRlbXBsYXRlLCB7IEVVQkdyb3VwIH0gZnJvbSBcIi4uL2NvcmUvVUJUZW1wbGF0ZVwiO1xuaW1wb3J0IHRleHR1cmVzIGZyb20gJy4vdGV4dHVyZXMnO1xuXG5jb25zdCB1YlRlbXBsYXRlczoge1xuICBnbG9iYWw6IFVCVGVtcGxhdGUsXG4gIHN0YXRpY01lc2g6IFVCVGVtcGxhdGVcbn0gPSB7fSBhcyBhbnk7XG5cbmV4cG9ydCBkZWZhdWx0IHViVGVtcGxhdGVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdWJUZW1wbGF0ZXMuZ2xvYmFsID0gbmV3IFVCVGVtcGxhdGUoXG4gICAge1xuICAgICAgdW5pZm9ybXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3ZwJyxcbiAgICAgICAgICB0eXBlOiAnbWF0NHg0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfdmlldycsXG4gICAgICAgICAgdHlwZTogJ21hdDR4NCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBtYXQ0LmlkZW50aXR5KG5ldyBGbG9hdDMyQXJyYXkoMTYpKSBhcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3Byb2onLFxuICAgICAgICAgIHR5cGU6ICdtYXQ0eDQnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbWF0NC5pZGVudGl0eShuZXcgRmxvYXQzMkFycmF5KDE2KSkgYXMgRmxvYXQzMkFycmF5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV92aWV3SW52ZXJzZScsXG4gICAgICAgICAgdHlwZTogJ21hdDR4NCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBtYXQ0LmlkZW50aXR5KG5ldyBGbG9hdDMyQXJyYXkoMTYpKSBhcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X3Byb2pJbnZlcnNlJyxcbiAgICAgICAgICB0eXBlOiAnbWF0NHg0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3Vfc2t5VlAnLFxuICAgICAgICAgIHR5cGU6ICdtYXQ0eDQnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbWF0NC5pZGVudGl0eShuZXcgRmxvYXQzMkFycmF5KDE2KSkgYXMgRmxvYXQzMkFycmF5XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV9nYW1lVGltZScsXG4gICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswXSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd1X2VudkNvbG9yJyxcbiAgICAgICAgICB0eXBlOiAndmVjNCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwXSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIGluZm86IGJpdDEocGFjayAoNGJpdHMgdHlwZXw0Yml0cyBtb2RlKXxyfGd8YiksIGJpdDIoaW50ZW5zaXR5KSwgYml0My80KGFyZWFMaWdodFNpemUueHkpXG4gICAgICAgICAgbmFtZTogJ3VfbGlnaHRJbmZvcycsXG4gICAgICAgICAgY3VzdG9tVHlwZToge1xuICAgICAgICAgICAgbmFtZTogJ0xpZ2h0SW5mbycsXG4gICAgICAgICAgICBsZW46IDQwLFxuICAgICAgICAgICAgY29kZTogYFxuc3RydWN0IExpZ2h0SW5mbyB7XG4gIGxpZ2h0VHlwZTogdTMyO1xuICBhcmVhTW9kZTogdTMyO1xuICBhcmVhU2l6ZTogdmVjMjxmMzI+O1xuICBjb2xvcjogdmVjNDxmMzI+O1xuICB3b3JsZFRyYW5zZm9ybTogbWF0NHg0PGYzMj47XG4gIHdvcmxkVHJhbnNmb3JtSW52ZXJzZTogbWF0NHg0PGYzMj47XG59O2BcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6ICd2ZWM0JyxcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0MCAqIDQpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0ZXh0dXJlczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3VfZW52VGV4dHVyZScsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiB0ZXh0dXJlcy5jdWJlQmxhY2tcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgRVVCR3JvdXAuR2xvYmFsXG4gICk7XG5cbiAgdWJUZW1wbGF0ZXMuc3RhdGljTWVzaCA9IG5ldyBVQlRlbXBsYXRlKFxuICAgIHtcbiAgICAgIHVuaWZvcm1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndV93b3JsZCcsXG4gICAgICAgICAgdHlwZTogJ21hdDR4NCcsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBtYXQ0LmlkZW50aXR5KG5ldyBGbG9hdDMyQXJyYXkoMTYpKSBhcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICB9LFxuICAgIEVVQkdyb3VwLk1lc2hcbiAgKTtcbn1cbiJdfQ==

/***/ }),

/***/ "./src/core/Camera.ts":
/*!****************************!*\
  !*** ./src/core/Camera.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var Mesh_1 = __webpack_require__(/*! ./Mesh */ "./src/core/Mesh.ts");
var Node_1 = __webpack_require__(/*! ./Node */ "./src/core/Node.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var Camera = (function (_super) {
    __extends(Camera, _super);
    function Camera(viewOptions, cameraOptions, _justAsView) {
        if (_justAsView === void 0) { _justAsView = false; }
        var _this = _super.call(this) || this;
        _this._justAsView = _justAsView;
        _this.isCamera = true;
        _this.controlMode = 'free';
        _this.drawSkybox = false;
        cameraOptions = cameraOptions || {};
        _this._near = cameraOptions.near || 0;
        _this._far = cameraOptions.far || 1000;
        _this._aspect = cameraOptions.aspect || (renderEnv_1.default.width / renderEnv_1.default.height);
        if (cameraOptions.isOrth) {
            var sizeX = cameraOptions.sizeX, sizeY = cameraOptions.sizeY;
            if (cameraOptions.sizeX > cameraOptions.sizeY) {
                sizeX = sizeY * _this._aspect;
            }
            else {
                sizeY = sizeX / _this._aspect;
            }
            _this._sizeX = sizeX;
            _this._sizeY = sizeY;
            _this._isOrth = true;
        }
        else {
            _this._fov = cameraOptions.fov || (Math.PI / 3);
        }
        _this.clearColor = viewOptions.clearColor || [0, 0, 0, 1];
        _this.clearDepth = viewOptions.clearDepth !== undefined ? viewOptions.clearDepth : 1;
        _this.clearStencil = viewOptions.clearStencil || 0;
        _this.colorOp = viewOptions.colorOp || 'store';
        _this.depthOp = viewOptions.depthOp || 'store';
        _this.stencilOp = viewOptions.stencilOp || 'store';
        _this.viewport = viewOptions.viewport || { x: 0, y: 0, w: 1, h: 1 };
        _this._viewMat = gl_matrix_1.mat4.identity(new Float32Array(16));
        _this._projMat = gl_matrix_1.mat4.identity(new Float32Array(16));
        _this._projInverseMat = gl_matrix_1.mat4.identity(new Float32Array(16));
        _this._vpMat = gl_matrix_1.mat4.identity(new Float32Array(16));
        _this._skyVPMat = gl_matrix_1.mat4.identity(new Float32Array(16));
        return _this;
    }
    Camera.IS = function (value) {
        return !!value.isCamera;
    };
    Object.defineProperty(Camera.prototype, "isOrth", {
        get: function () {
            return this._isOrth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "skyboxMat", {
        get: function () {
            return this._skyboxMat;
        },
        set: function (value) {
            this._skyboxMat = value;
            if (!this._skyboxMesh) {
                this._skyboxMesh = new Mesh_1.default(buildin_1.buildinGeometries.skybox, value);
            }
            else {
                this._skyboxMesh.material = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "vpMat", {
        get: function () {
            return this._vpMat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "invViewMat", {
        get: function () {
            return this._worldMat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "invProjMat", {
        get: function () {
            return this._projInverseMat;
        },
        enumerable: false,
        configurable: true
    });
    Camera.prototype.updateMatrix = function () {
        _super.prototype.updateMatrix.call(this);
        this._updateViewMat();
        this._updateProjMat();
        gl_matrix_1.mat4.multiply(this._vpMat, this._projMat, this._viewMat);
        if (this._skyboxMat) {
            var mat = this._skyVPMat;
            mat.set(this._viewMat);
            var rotation = this._skyboxMat.getUniform('u_rotation')[0];
            rotation && gl_matrix_1.mat4.rotateY(mat, mat, -rotation);
            mat[12] = 0;
            mat[13] = 0;
            mat[14] = 0;
            gl_matrix_1.mat4.multiply(mat, this._projMat, mat);
            gl_matrix_1.mat4.invert(mat, mat);
        }
        renderEnv_1.default.setUniform('u_vp', this._vpMat);
        renderEnv_1.default.setUniform('u_view', this._viewMat);
        renderEnv_1.default.setUniform('u_proj', this._projMat);
        renderEnv_1.default.setUniform('u_viewInverse', this._worldMat);
        renderEnv_1.default.setUniform('u_projInverse', this._projInverseMat);
        if (this._skyboxMat) {
            renderEnv_1.default.setUniform('u_skyVP', this._skyVPMat);
            renderEnv_1.default.setUniform('u_envTexture', this._skyboxMat.getUniform('u_cubeTexture'));
            renderEnv_1.default.setUniform('u_envColor', this._skyboxMat.getUniform('u_color'));
        }
    };
    Camera.prototype.render = function (cmd, rt, meshes, clear) {
        var _this = this;
        if (clear === void 0) { clear = false; }
        var _a = this.clearColor, r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        var _b = this.viewport, x = _b.x, y = _b.y, w = _b.w, h = _b.h;
        var width = rt.width, height = rt.height, colorViews = rt.colorViews, depthStencilView = rt.depthStencilView;
        var renderPassDescriptor = {
            colorAttachments: colorViews.map(function (view) { return ({
                view: view,
                loadValue: clear ? { r: r, g: g, b: b, a: a } : 'load',
                storeOp: _this.colorOp
            }); }),
            depthStencilAttachment: depthStencilView && {
                view: depthStencilView,
                depthLoadValue: this.clearDepth,
                stencilLoadValue: this.clearStencil,
                depthStoreOp: this.depthOp,
                stencilStoreOp: this.stencilOp
            }
        };
        var pass = cmd.beginRenderPass(renderPassDescriptor);
        pass.setViewport(x * width, y * height, w * width, h * height, 0, 1);
        pass.setBindGroup(0, renderEnv_1.default.bindingGroup);
        for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
            var mesh = meshes_1[_i];
            mesh.render(pass, rt);
        }
        if (this.drawSkybox && this._skyboxMesh) {
            this._skyboxMesh.render(pass, rt);
        }
        pass.endPass();
    };
    Camera.prototype.cull = function (mesh) {
        return 0;
    };
    Camera.prototype._updateViewMat = function () {
        var _a = this, controlMode = _a.controlMode, target = _a.target, _worldMat = _a._worldMat;
        if (controlMode === 'target' && !target) {
            throw new Error('Camera with control mode "target" must has target!');
        }
        if (controlMode === 'target') {
            var eye = gl_matrix_1.mat4.getTranslation(new Float32Array(3), _worldMat);
            var center = gl_matrix_1.mat4.getTranslation(new Float32Array(3), target.worldMat);
            var forward = gl_matrix_1.vec3.sub(new Float32Array(3), center, eye);
            gl_matrix_1.vec3.normalize(forward, forward);
            var up = this._worldMat.slice(4, 7);
            gl_matrix_1.vec3.normalize(up, up);
            if (gl_matrix_1.vec3.sqrLen(up) === 0) {
                up.set([0, 1, 0]);
            }
            gl_matrix_1.mat4.lookAt(this._viewMat, eye, center, up);
        }
        else {
            gl_matrix_1.mat4.invert(this._viewMat, this._worldMat);
        }
    };
    Camera.prototype._updateProjMat = function () {
        if (this._isOrth) {
            this._orthHalfZ(this._projMat, -this._sizeX, this._sizeX, -this._sizeY, this._sizeY, this._near, this._far);
        }
        else {
            gl_matrix_1.mat4.perspective(this._projMat, this._fov, this._aspect, this._near, this._far);
        }
        gl_matrix_1.mat4.invert(this._projInverseMat, this._projMat);
    };
    Camera.prototype._orthHalfZ = function (out, left, right, top, bottom, near, far) {
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = near * p;
        out[0] = 2 * w;
        out[4] = 0;
        out[8] = 0;
        out[12] = -x;
        out[1] = 0;
        out[5] = 2 * h;
        out[9] = 0;
        out[13] = -y;
        out[2] = 0;
        out[6] = 0;
        out[10] = -1 * p;
        out[14] = -z;
        out[3] = 0;
        out[7] = 0;
        out[11] = 0;
        out[15] = 1;
    };
    Camera.CLASS_NAME = 'Node';
    return Camera;
}(Node_1.default));
exports["default"] = Camera;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FtZXJhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQ2FtZXJhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQU1BLHVDQUFxQztBQUNyQyxzQ0FBNkM7QUFFN0MsK0JBQTBCO0FBQzFCLCtCQUEwQjtBQUMxQix5Q0FBb0M7QUFHcEM7SUFBb0MsMEJBQUk7SUFpRXRDLGdCQUNFLFdBUUMsRUFDRCxhQVFDLEVBQ1MsV0FBNEI7UUFBNUIsNEJBQUEsRUFBQSxtQkFBNEI7UUFuQnhDLFlBcUJFLGlCQUFPLFNBbUNSO1FBckNXLGlCQUFXLEdBQVgsV0FBVyxDQUFpQjtRQTdFakMsY0FBUSxHQUFZLElBQUksQ0FBQztRQUV6QixpQkFBVyxHQUFzQixNQUFNLENBQUM7UUFTeEMsZ0JBQVUsR0FBWSxLQUFLLENBQUM7UUFzRWpDLGFBQWEsR0FBRyxhQUFhLElBQUksRUFBRSxDQUFDO1FBQ3BDLEtBQUksQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7UUFDckMsS0FBSSxDQUFDLElBQUksR0FBRyxhQUFhLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQztRQUN0QyxLQUFJLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQyxNQUFNLElBQUksQ0FBQyxtQkFBUyxDQUFDLEtBQUssR0FBRyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTVFLElBQUksYUFBYSxDQUFDLE1BQU0sRUFBRTtZQUNuQixJQUFBLEtBQUssR0FBVyxhQUFhLE1BQXhCLEVBQUUsS0FBSyxHQUFJLGFBQWEsTUFBakIsQ0FBa0I7WUFFbkMsSUFBSSxhQUFhLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxLQUFLLEVBQUU7Z0JBQzdDLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQzthQUM5QjtpQkFBTTtnQkFDTCxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUM7YUFDOUI7WUFFRCxL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RyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUM7UUFDL0IsSUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBRTdCLElBQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3QixJQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0IsSUFBTSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUVuQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JELEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQXpQYSxpQkFBVSxHQUFXLE1BQU0sQ0FBQztJQTBQNUMsYUFBQztDQUFBLEFBM1BELENBQW9DLGNBQUksR0EyUHZDO2tCQTNQb0IsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IENhbWVyYS50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiAyMDIxLzYvNuS4i+WNiDc6MjQ6NTFcbiAqL1xuaW1wb3J0IHttYXQ0LCB2ZWMzfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHtidWlsZGluR2VvbWV0cmllc30gZnJvbSAnLi4vYnVpbGRpbic7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi9NYXRlcmlhbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlJztcbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9yZW5kZXJFbnYnO1xuaW1wb3J0IFJlbmRlclRleHR1cmUgZnJvbSAnLi9SZW5kZXJUZXh0dXJlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FtZXJhIGV4dGVuZHMgTm9kZSB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ05vZGUnO1xuXG4gIHB1YmxpYyBzdGF0aWMgSVModmFsdWU6IGFueSk6IHZhbHVlIGlzIENhbWVyYSB7XG4gICAgcmV0dXJuICEhKHZhbHVlIGFzIENhbWVyYSkuaXNDYW1lcmE7XG4gIH1cblxuICBwdWJsaWMgaXNDYW1lcmE6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHB1YmxpYyBjb250cm9sTW9kZTogJ2ZyZWUnIHwgJ3RhcmdldCcgPSAnZnJlZSc7XG4gIHB1YmxpYyB0YXJnZXQ6IE5vZGU7XG4gIHB1YmxpYyB2aWV3cG9ydDogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIgfTtcbiAgcHVibGljIGNsZWFyQ29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBwdWJsaWMgY29sb3JPcDogR1BVU3RvcmVPcDtcbiAgcHVibGljIGNsZWFyRGVwdGg6IG51bWJlcjtcbiAgcHVibGljIGRlcHRoT3A6IEdQVVN0b3JlT3A7XG4gIHB1YmxpYyBjbGVhclN0ZW5jaWw6IG51bWJlcjtcbiAgcHVibGljIHN0ZW5jaWxPcDogR1BVU3RvcmVPcDtcbiAgcHVibGljIGRyYXdTa3lib3g6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgX3NreWJveE1hdDogTWF0ZXJpYWw7XG4gIHByb3RlY3RlZCBfc2t5Ym94TWVzaDogTWVzaDtcbiAgcHJvdGVjdGVkIF9uZWFyOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfZmFyOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfZm92OiBudW1iZXI7XG4gIHByb3RlY3RlZCBfYXNwZWN0OiBudW1iZXI7XG4gIHByb3RlY3RlZCBfc2l6ZVg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIF9zaXplWTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX2lzT3J0aDogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIF92aWV3TWF0OiBGbG9hdDMyQXJyYXk7XG4gIHByb3RlY3RlZCBfcHJvak1hdDogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX3Byb2pJbnZlcnNlTWF0OiBGbG9hdDMyQXJyYXk7XG4gIHByb3RlY3RlZCBfdnBNYXQ6IEZsb2F0MzJBcnJheTtcbiAgcHJvdGVjdGVkIF9za3lWUE1hdDogRmxvYXQzMkFycmF5O1xuXG4gIGdldCBpc09ydGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzT3J0aDtcbiAgfVxuXG4gIGdldCBza3lib3hNYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NreWJveE1hdDtcbiAgfVxuXG4gIHNldCBza3lib3hNYXQodmFsdWU6IE1hdGVyaWFsKSB7XG4gICAgdGhpcy5fc2t5Ym94TWF0ID0gdmFsdWU7XG5cbiAgICBpZiAoIXRoaXMuX3NreWJveE1lc2gpIHtcbiAgICAgIHRoaXMuX3NreWJveE1lc2ggPSBuZXcgTWVzaChidWlsZGluR2VvbWV0cmllcy5za3lib3gsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2t5Ym94TWVzaC5tYXRlcmlhbCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB2cE1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdnBNYXQ7XG4gIH1cblxuICBnZXQgaW52Vmlld01hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGRNYXQ7XG4gIH1cblxuICBnZXQgaW52UHJvak1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvakludmVyc2VNYXQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICB2aWV3T3B0aW9uczoge1xuICAgICAgdmlld3BvcnQ/OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlciB9LFxuICAgICAgY2xlYXJDb2xvcj86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgY29sb3JPcD86IEdQVVN0b3JlT3AsXG4gICAgICBjbGVhckRlcHRoPzogbnVtYmVyLFxuICAgICAgZGVwdGhPcD86IEdQVVN0b3JlT3AsXG4gICAgICBjbGVhclN0ZW5jaWw/OiBudW1iZXIsXG4gICAgICBzdGVuY2lsT3A/OiBHUFVTdG9yZU9wLFxuICAgIH0sXG4gICAgY2FtZXJhT3B0aW9ucz86IHtcbiAgICAgIG5lYXI/OiBudW1iZXIsXG4gICAgICBmYXI/OiBudW1iZXIsXG4gICAgICBmb3Y/OiBudW1iZXIsXG4gICAgICBhc3BlY3Q/OiBudW1iZXIsXG4gICAgICBpc09ydGg/OiBib29sZWFuLFxuICAgICAgc2l6ZVg/OiBudW1iZXIsXG4gICAgICBzaXplWT86IG51bWJlclxuICAgIH0sXG4gICAgcHJvdGVjdGVkIF9qdXN0QXNWaWV3OiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNhbWVyYU9wdGlvbnMgPSBjYW1lcmFPcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX25lYXIgPSBjYW1lcmFPcHRpb25zLm5lYXIgfHwgMDtcbiAgICB0aGlzLl9mYXIgPSBjYW1lcmFPcHRpb25zLmZhciB8fCAxMDAwO1xuICAgIHRoaXMuX2FzcGVjdCA9IGNhbWVyYU9wdGlvbnMuYXNwZWN0IHx8IChyZW5kZXJFbnYud2lkdGggLyByZW5kZXJFbnYuaGVpZ2h0KTtcblxuICAgIGlmIChjYW1lcmFPcHRpb25zLmlzT3J0aCkge1xuICAgICAgbGV0IHtzaXplWCwgc2l6ZVl9ID0gY2FtZXJhT3B0aW9ucztcblxuICAgICAgaWYgKGNhbWVyYU9wdGlvbnMuc2l6ZVggPiBjYW1lcmFPcHRpb25zLnNpemVZKSB7XG4gICAgICAgIHNpemVYID0gc2l6ZVkgKiB0aGlzLl9hc3BlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplWSA9IHNpemVYIC8gdGhpcy5fYXNwZWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaXplWCA9IHNpemVYO1xuICAgICAgdGhpcy5fc2l6ZVkgPSBzaXplWTtcbiAgICAgIHRoaXMuX2lzT3J0aCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvdiA9IGNhbWVyYU9wdGlvbnMuZm92IHx8IChNYXRoLlBJIC8gMyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckNvbG9yID0gdmlld09wdGlvbnMuY2xlYXJDb2xvciB8fCBbMCwgMCwgMCwgMV07XG4gICAgdGhpcy5jbGVhckRlcHRoID0gdmlld09wdGlvbnMuY2xlYXJEZXB0aCAhPT0gdW5kZWZpbmVkID8gdmlld09wdGlvbnMuY2xlYXJEZXB0aCA6IDE7XG4gICAgdGhpcy5jbGVhclN0ZW5jaWwgPSB2aWV3T3B0aW9ucy5jbGVhclN0ZW5jaWwgfHwgMDtcbiAgICB0aGlzLmNvbG9yT3AgPSB2aWV3T3B0aW9ucy5jb2xvck9wIHx8ICdzdG9yZSc7XG4gICAgdGhpcy5kZXB0aE9wID0gdmlld09wdGlvbnMuZGVwdGhPcCB8fCAnc3RvcmUnO1xuICAgIHRoaXMuc3RlbmNpbE9wID0gdmlld09wdGlvbnMuc3RlbmNpbE9wIHx8ICdzdG9yZSc7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdPcHRpb25zLnZpZXdwb3J0IHx8IHsgeDogMCwgeTogMCwgdzogMSwgaDogMSB9O1xuICAgIHRoaXMuX3ZpZXdNYXQgPSBtYXQ0LmlkZW50aXR5KG5ldyBGbG9hdDMyQXJyYXkoMTYpKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgdGhpcy5fcHJvak1hdCA9IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheTtcbiAgICB0aGlzLl9wcm9qSW52ZXJzZU1hdCA9IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheTtcbiAgICB0aGlzLl92cE1hdCA9IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheTtcbiAgICB0aGlzLl9za3lWUE1hdCA9IG1hdDQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVNYXRyaXgoKSB7XG4gICAgc3VwZXIudXBkYXRlTWF0cml4KCk7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3TWF0KCk7XG4gICAgdGhpcy5fdXBkYXRlUHJvak1hdCgpO1xuICAgIG1hdDQubXVsdGlwbHkodGhpcy5fdnBNYXQsIHRoaXMuX3Byb2pNYXQsIHRoaXMuX3ZpZXdNYXQpO1xuXG4gICAgaWYgKHRoaXMuX3NreWJveE1hdCkge1xuICAgICAgY29uc3QgbWF0ID0gdGhpcy5fc2t5VlBNYXQ7XG4gICAgICBtYXQuc2V0KHRoaXMuX3ZpZXdNYXQpO1xuICAgICAgY29uc3Qgcm90YXRpb24gPSAodGhpcy5fc2t5Ym94TWF0LmdldFVuaWZvcm0oJ3Vfcm90YXRpb24nKSBhcyBGbG9hdDMyQXJyYXkpWzBdO1xuICAgICAgcm90YXRpb24gJiYgbWF0NC5yb3RhdGVZKG1hdCwgbWF0LCAtcm90YXRpb24pO1xuXG4gICAgICBtYXRbMTJdID0gMDtcbiAgICAgIG1hdFsxM10gPSAwO1xuICAgICAgbWF0WzE0XSA9IDA7XG5cbiAgICAgIG1hdDQubXVsdGlwbHkobWF0LCB0aGlzLl9wcm9qTWF0LCBtYXQpO1xuICAgICAgbWF0NC5pbnZlcnQobWF0LCBtYXQpO1xuICAgIH1cblxuICAgIHJlbmRlckVudi5zZXRVbmlmb3JtKCd1X3ZwJywgdGhpcy5fdnBNYXQpO1xuICAgIHJlbmRlckVudi5zZXRVbmlmb3JtKCd1X3ZpZXcnLCB0aGlzLl92aWV3TWF0KTtcbiAgICByZW5kZXJFbnYuc2V0VW5pZm9ybSgndV9wcm9qJywgdGhpcy5fcHJvak1hdCk7XG4gICAgcmVuZGVyRW52LnNldFVuaWZvcm0oJ3Vfdmlld0ludmVyc2UnLCB0aGlzLl93b3JsZE1hdCk7XG4gICAgcmVuZGVyRW52LnNldFVuaWZvcm0oJ3VfcHJvakludmVyc2UnLCB0aGlzLl9wcm9qSW52ZXJzZU1hdCk7XG5cbiAgICBpZiAodGhpcy5fc2t5Ym94TWF0KSB7XG4gICAgICByZW5kZXJFbnYuc2V0VW5pZm9ybSgndV9za3lWUCcsIHRoaXMuX3NreVZQTWF0KTtcbiAgICAgIHJlbmRlckVudi5zZXRVbmlmb3JtKCd1X2VudlRleHR1cmUnLCB0aGlzLl9za3lib3hNYXQuZ2V0VW5pZm9ybSgndV9jdWJlVGV4dHVyZScpKTtcbiAgICAgIHJlbmRlckVudi5zZXRVbmlmb3JtKCd1X2VudkNvbG9yJywgdGhpcy5fc2t5Ym94TWF0LmdldFVuaWZvcm0oJ3VfY29sb3InKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcihcbiAgICBjbWQ6IEdQVUNvbW1hbmRFbmNvZGVyLFxuICAgIHJ0OiBSZW5kZXJUZXh0dXJlLFxuICAgIG1lc2hlczogTWVzaFtdLFxuICAgIGNsZWFyOiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5jbGVhckNvbG9yO1xuICAgIGNvbnN0IHsgeCwgeSwgdywgaCB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNvbG9yVmlld3MsIGRlcHRoU3RlbmNpbFZpZXcgfSA9IHJ0O1xuXG4gICAgY29uc3QgcmVuZGVyUGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yID0ge1xuICAgICAgY29sb3JBdHRhY2htZW50czogY29sb3JWaWV3cy5tYXAodmlldyA9PiAoe1xuICAgICAgICB2aWV3LFxuICAgICAgICBsb2FkVmFsdWU6IGNsZWFyID8geyByLCBnLCBiLCBhIH0gOiAnbG9hZCcgYXMgR1BVTG9hZE9wLFxuICAgICAgICBzdG9yZU9wOiB0aGlzLmNvbG9yT3BcbiAgICAgIH0pKSxcbiAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ6IGRlcHRoU3RlbmNpbFZpZXcgJiYge1xuICAgICAgICB2aWV3OiBkZXB0aFN0ZW5jaWxWaWV3LFxuICAgICAgICBkZXB0aExvYWRWYWx1ZTogdGhpcy5jbGVhckRlcHRoLFxuICAgICAgICBzdGVuY2lsTG9hZFZhbHVlOiB0aGlzLmNsZWFyU3RlbmNpbCxcbiAgICAgICAgZGVwdGhTdG9yZU9wOiB0aGlzLmRlcHRoT3AsXG4gICAgICAgIHN0ZW5jaWxTdG9yZU9wOiB0aGlzLnN0ZW5jaWxPcFxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwYXNzID0gY21kLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgcGFzcy5zZXRWaWV3cG9ydCh4ICogd2lkdGgsIHkgKiBoZWlnaHQsIHcgKiB3aWR0aCwgaCAqIGhlaWdodCwgMCwgMSk7XG4gICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgcmVuZGVyRW52LmJpbmRpbmdHcm91cCk7XG5cbiAgICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICBtZXNoLnJlbmRlcihwYXNzLCBydCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZHJhd1NreWJveCAmJiB0aGlzLl9za3lib3hNZXNoKSB7XG4gICAgICB0aGlzLl9za3lib3hNZXNoLnJlbmRlcihwYXNzLCBydCk7XG4gICAgfVxuXG4gICAgcGFzcy5lbmRQYXNzKCk7XG4gIH1cblxuICBwdWJsaWMgY3VsbChtZXNoOiBNZXNoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlVmlld01hdCgpIHtcbiAgICBjb25zdCB7Y29udHJvbE1vZGUsIHRhcmdldCwgX3dvcmxkTWF0fSA9IHRoaXM7XG5cbiAgICBpZiAoY29udHJvbE1vZGUgPT09ICd0YXJnZXQnICYmICF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FtZXJhIHdpdGggY29udHJvbCBtb2RlIFwidGFyZ2V0XCIgbXVzdCBoYXMgdGFyZ2V0IScpO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sTW9kZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgIGNvbnN0IGV5ZSA9IG1hdDQuZ2V0VHJhbnNsYXRpb24obmV3IEZsb2F0MzJBcnJheSgzKSwgX3dvcmxkTWF0KSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBjZW50ZXIgPSBtYXQ0LmdldFRyYW5zbGF0aW9uKG5ldyBGbG9hdDMyQXJyYXkoMyksIHRhcmdldC53b3JsZE1hdCkgYXMgRmxvYXQzMkFycmF5O1xuXG4gICAgICBjb25zdCBmb3J3YXJkID0gdmVjMy5zdWIobmV3IEZsb2F0MzJBcnJheSgzKSwgY2VudGVyLCBleWUpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHZlYzMubm9ybWFsaXplKGZvcndhcmQsIGZvcndhcmQpO1xuICAgICAgY29uc3QgdXAgPSB0aGlzLl93b3JsZE1hdC5zbGljZSg0LCA3KTtcbiAgICAgIHZlYzMubm9ybWFsaXplKHVwLCB1cCk7XG5cbiAgICAgIGlmICh2ZWMzLnNxckxlbih1cCkgPT09IDApIHtcbiAgICAgICAgdXAuc2V0KFswLCAxLCAwXSk7XG4gICAgICB9XG5cbiAgICAgIG1hdDQubG9va0F0KHRoaXMuX3ZpZXdNYXQsIGV5ZSwgY2VudGVyLCB1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuX3ZpZXdNYXQsIHRoaXMuX3dvcmxkTWF0KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZVByb2pNYXQoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3J0aCkge1xuICAgICAgLy8gd2ViZ3B1IGhhcyBoYWxmIHpcbiAgICAgIHRoaXMuX29ydGhIYWxmWih0aGlzLl9wcm9qTWF0LCAtdGhpcy5fc2l6ZVgsIHRoaXMuX3NpemVYLCAtdGhpcy5fc2l6ZVksIHRoaXMuX3NpemVZLCB0aGlzLl9uZWFyLCB0aGlzLl9mYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMuX3Byb2pNYXQsIHRoaXMuX2ZvdiwgdGhpcy5fYXNwZWN0LCB0aGlzLl9uZWFyLCB0aGlzLl9mYXIpO1xuICAgIH1cbiAgICBtYXQ0LmludmVydCh0aGlzLl9wcm9qSW52ZXJzZU1hdCwgdGhpcy5fcHJvak1hdCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX29ydGhIYWxmWihvdXQ6IEZsb2F0MzJBcnJheSwgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCB0b3A6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIG5lYXI6IG51bWJlciwgZmFyOiBudW1iZXIpIHtcbiAgICBjb25zdCB3ID0gMS4wIC8gKHJpZ2h0IC0gbGVmdCk7XG4gICAgY29uc3QgaCA9IDEuMCAvICh0b3AgLSBib3R0b20pO1xuICAgIGNvbnN0IHAgPSAxLjAgLyAoZmFyIC0gbmVhcik7XG4gIFxuICAgIGNvbnN0IHggPSAocmlnaHQgKyBsZWZ0KSAqIHc7XG4gICAgY29uc3QgeSA9ICh0b3AgKyBib3R0b20pICogaDtcbiAgICBjb25zdCB6ID0gbmVhciAqIHA7XG4gIFxuICAgIG91dFswXSA9IDIgKiB3O1x0b3V0WzRdID0gMDtcdG91dFs4XSA9IDA7XHRvdXRbMTJdID0gLXg7XG4gICAgb3V0WzFdID0gMDtcdG91dFs1XSA9IDIgKiBoO1x0b3V0WzldID0gMDtcdG91dFsxM10gPSAteTtcbiAgICBvdXRbMl0gPSAwO1x0b3V0WzZdID0gMDtcdG91dFsxMF0gPSAtMSAqIHA7XHRvdXRbMTRdID0gLXo7XG4gICAgb3V0WzNdID0gMDtcdG91dFs3XSA9IDA7XHRvdXRbMTFdID0gMDtcdG91dFsxNV0gPSAxO1xuICB9XG59Il19

/***/ }),

/***/ "./src/core/ComputeUnit.ts":
/*!*********************************!*\
  !*** ./src/core/ComputeUnit.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var Material_1 = __webpack_require__(/*! ./Material */ "./src/core/Material.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var ComputeUnit = (function (_super) {
    __extends(ComputeUnit, _super);
    function ComputeUnit(_effect, _groups, values, marcos) {
        var _this = _super.call(this) || this;
        _this._effect = _effect;
        _this._groups = _groups;
        _this.isComputeUnite = true;
        _this._matVersion = -1;
        if (!_effect.isCompute) {
            throw new Error('ComputeUnit can only receive effect has compute shader!');
        }
        _this._material = new Material_1.default(_effect, values, marcos);
        return _this;
    }
    Object.defineProperty(ComputeUnit.prototype, "groups", {
        get: function () {
            return this._groups;
        },
        enumerable: false,
        configurable: true
    });
    ComputeUnit.prototype.compute = function (pass) {
        var _a = this, _material = _a._material, _groups = _a._groups;
        if (_material.version !== this._matVersion) {
            this._createPipeline();
            this._matVersion = _material.version;
        }
        pass.setPipeline(this._pipeline);
        pass.setBindGroup(1, _material.bindingGroup);
        pass.dispatch(_groups.x, _groups.y, _groups.z);
    };
    ComputeUnit.prototype.setUniform = function (name, value, rtSubNameOrGPUBuffer) {
        this._material.setUniform(name, value, rtSubNameOrGPUBuffer);
    };
    ComputeUnit.prototype.getUniform = function (name) {
        return this._material.getUniform(name);
    };
    ComputeUnit.prototype.setGroups = function (x, y, z) {
        this._groups = { x: x, y: y, z: z };
    };
    ComputeUnit.prototype._createPipeline = function () {
        var device = renderEnv_1.default.device;
        var _material = this._material;
        var marcos = Object.assign({}, _material.marcos);
        var cs = _material.effect.getShader(marcos, '', renderEnv_1.default.shaderPrefix, '').cs;
        this._pipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [
                    renderEnv_1.default.uniformLayout,
                    _material.effect.uniformLayout
                ] }),
            compute: {
                module: cs,
                entryPoint: "main"
            }
        });
    };
    ComputeUnit.CLASS_NAME = 'ComputeUnit';
    return ComputeUnit;
}(HObject_1.default));
exports["default"] = ComputeUnit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tcHV0ZVVuaXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJDb21wdXRlVW5pdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFPQSxxQ0FBZ0M7QUFFaEMsdUNBQWtDO0FBQ2xDLHlDQUFvQztBQUdwQztJQUF5QywrQkFBTztJQVk5QyxxQkFDWSxPQUFlLEVBQ2YsT0FBNEMsRUFDdEQsTUFBd0MsRUFDeEMsTUFBMkM7UUFKN0MsWUFNRSxpQkFBTyxTQU9SO1FBWlcsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLGFBQU8sR0FBUCxPQUFPLENBQXFDO1FBWmpELG9CQUFjLEdBQVksSUFBSSxDQUFDO1FBRzVCLGlCQUFXLEdBQVcsQ0FBQyxDQUFDLENBQUM7UUFlakMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO1NBQzVFO1FBRUQsS0FBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGtCQUFRLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQzs7SUFDekQsQ0FBQztJQWpCRCxzQkFBSSwrQkFBTTthQUFWO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7OztPQUFBO0lBaUJNLDZCQUFPLEdBQWQsVUFBZSxJQUEyQjtRQUNsQyxJQUFBLEtBQXVCLElBQUksRUFBMUIsU0FBUyxlQUFBLEVBQUUsT0FBTyxhQUFRLENBQUM7UUFFbEMsSUFBSSxTQUFTLENBQUMsT0FBTyxLQUFLLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQztTQUN0QztRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVNLGdDQUFVLEdBQWpCLFVBQWtCLElBQVksRUFBRSxLQUFvQixFQUFFLG9CQUF5QztRQUM3RixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVNLGdDQUFVLEdBQWpCLFVBQWtCLElBQVk7UUFDNUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU0sK0JBQVMsR0FBaEIsVUFBaUIsQ0FBUyxFQUFFLENBQVUsRUFBRSxDQUFVO1FBQ2hELElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBQyxDQUFDLEdBQUEsRUFBRSxDQUFDLEdBQUEsRUFBRSxDQUFDLEdBQUEsRUFBQyxDQUFDO0lBQzNCLENBQUM7SUFFUyxxQ0FBZSxHQUF6QjtRQUNTLElBQUEsTUFBTSxHQUFJLG1CQUFTLE9BQWIsQ0FBYztRQUNwQixJQUFBLFNBQVMsR0FBSSxJQUFJLFVBQVIsQ0FBUztRQUV6QixJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsSUFBQSxFQUFFLEdBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxtQkFBUyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsR0FBdEUsQ0FBdUU7UUFFaEYsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUM7WUFDNUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFDLGdCQUFnQixFQUFFO29CQUNyRCxtQkFBUyxDQUFDLGFBQWE7b0JBQ3ZCLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYTtpQkFDL0IsRUFBQyxDQUFDO1lBRUgsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxFQUFFO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25CO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQXJFYSxzQkFBVSxHQUFHLGFBQWEsQ0FBQztJQXNFM0Msa0JBQUM7Q0FBQSxBQXZFRCxDQUF5QyxpQkFBTyxHQXVFL0M7a0JBdkVvQixXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogQ29tcHV0ZVVuaXQudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzbkuIvljYg4OjU2OjQ5XG4gKi9cblxuaW1wb3J0IEhPYmplY3QgZnJvbSBcIi4vSE9iamVjdFwiO1xuaW1wb3J0IEVmZmVjdCBmcm9tIFwiLi9FZmZlY3RcIjtcbmltcG9ydCBNYXRlcmlhbCBmcm9tIFwiLi9NYXRlcmlhbFwiO1xuaW1wb3J0IHJlbmRlckVudiBmcm9tIFwiLi9yZW5kZXJFbnZcIjtcbmltcG9ydCB7IFRVbmlmb3JtVmFsdWUgfSBmcm9tIFwiLi9VQlRlbXBsYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXB1dGVVbml0IGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRSA9ICdDb21wdXRlVW5pdCc7XG4gIHB1YmxpYyBpc0NvbXB1dGVVbml0ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9tYXRlcmlhbDogTWF0ZXJpYWw7XG4gIHByb3RlY3RlZCBfbWF0VmVyc2lvbjogbnVtYmVyID0gLTE7XG4gIHByb3RlY3RlZCBfcGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcblxuICBnZXQgZ3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cHM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX2VmZmVjdDogRWZmZWN0LFxuICAgIHByb3RlY3RlZCBfZ3JvdXBzOiB7eDogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyfSxcbiAgICB2YWx1ZXM/OiB7W25hbWU6IHN0cmluZ106IFRVbmlmb3JtVmFsdWV9LFxuICAgIG1hcmNvcz86IHtbbmFtZTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn1cbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghX2VmZmVjdC5pc0NvbXB1dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcHV0ZVVuaXQgY2FuIG9ubHkgcmVjZWl2ZSBlZmZlY3QgaGFzIGNvbXB1dGUgc2hhZGVyIScpO1xuICAgIH1cblxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IE1hdGVyaWFsKF9lZmZlY3QsIHZhbHVlcywgbWFyY29zKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wdXRlKHBhc3M6IEdQVUNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgIGNvbnN0IHtfbWF0ZXJpYWwsIF9ncm91cHN9ID0gdGhpcztcblxuICAgIGlmIChfbWF0ZXJpYWwudmVyc2lvbiAhPT0gdGhpcy5fbWF0VmVyc2lvbikge1xuICAgICAgdGhpcy5fY3JlYXRlUGlwZWxpbmUoKTtcbiAgICAgIHRoaXMuX21hdFZlcnNpb24gPSBfbWF0ZXJpYWwudmVyc2lvbjtcbiAgICB9XG5cbiAgICBwYXNzLnNldFBpcGVsaW5lKHRoaXMuX3BpcGVsaW5lKTtcbiAgICBwYXNzLnNldEJpbmRHcm91cCgxLCBfbWF0ZXJpYWwuYmluZGluZ0dyb3VwKTtcbiAgICBwYXNzLmRpc3BhdGNoKF9ncm91cHMueCwgX2dyb3Vwcy55LCBfZ3JvdXBzLnopO1xuICB9XG5cbiAgcHVibGljIHNldFVuaWZvcm0obmFtZTogc3RyaW5nLCB2YWx1ZTogVFVuaWZvcm1WYWx1ZSwgcnRTdWJOYW1lT3JHUFVCdWZmZXI/OiBzdHJpbmcgfCBHUFVCdWZmZXIpIHtcbiAgICB0aGlzLl9tYXRlcmlhbC5zZXRVbmlmb3JtKG5hbWUsIHZhbHVlLCBydFN1Yk5hbWVPckdQVUJ1ZmZlcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0VW5pZm9ybShuYW1lOiBzdHJpbmcpOiBUVW5pZm9ybVZhbHVlIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWwuZ2V0VW5pZm9ybShuYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRHcm91cHMoeDogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyKSB7XG4gICAgdGhpcy5fZ3JvdXBzID0ge3gsIHksIHp9O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVQaXBlbGluZSgpIHtcbiAgICBjb25zdCB7ZGV2aWNlfSA9IHJlbmRlckVudjtcbiAgICBjb25zdCB7X21hdGVyaWFsfSA9IHRoaXM7XG4gICAgXG4gICAgY29uc3QgbWFyY29zID0gT2JqZWN0LmFzc2lnbih7fSwgX21hdGVyaWFsLm1hcmNvcyk7XG4gICAgY29uc3Qge2NzfSA9IF9tYXRlcmlhbC5lZmZlY3QuZ2V0U2hhZGVyKG1hcmNvcywgJycsIHJlbmRlckVudi5zaGFkZXJQcmVmaXgsICcnKTtcblxuICAgIHRoaXMuX3BpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XG4gICAgICBsYXlvdXQ6IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7YmluZEdyb3VwTGF5b3V0czogW1xuICAgICAgICByZW5kZXJFbnYudW5pZm9ybUxheW91dCxcbiAgICAgICAgX21hdGVyaWFsLmVmZmVjdC51bmlmb3JtTGF5b3V0XG4gICAgICBdfSksXG4gIFxuICAgICAgY29tcHV0ZToge1xuICAgICAgICBtb2R1bGU6IGNzLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/core/CubeTexture.ts":
/*!*********************************!*\
  !*** ./src/core/CubeTexture.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var CubeTexture = (function (_super) {
    __extends(CubeTexture, _super);
    function CubeTexture(_width, _height, _src, _format) {
        if (_format === void 0) { _format = 'rgba8unorm'; }
        var _this = _super.call(this) || this;
        _this._width = _width;
        _this._height = _height;
        _this._src = _src;
        _this._format = _format;
        _this.isCubeTexture = true;
        if (_src.length < 6) {
            throw new Error('CubeTexture must has 6 slice');
        }
        _this._gpuTexture = renderEnv_1.default.device.createTexture({
            size: { width: _width, height: _height, depthOrArrayLayers: 6 },
            format: _format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        });
        _this._view = _this._gpuTexture.createView({
            dimension: 'cube'
        });
        if (_src[0] instanceof ImageBitmap) {
            _this._loadImg();
        }
        else {
            _this._loadBuffer();
        }
        return _this;
    }
    CubeTexture.IS = function (value) {
        return !!value.isCubeTexture;
    };
    Object.defineProperty(CubeTexture.prototype, "view", {
        get: function () {
            return this._view;
        },
        enumerable: false,
        configurable: true
    });
    CubeTexture.prototype._loadImg = function () {
        var _this = this;
        this._src.forEach(function (img, index) {
            renderEnv_1.default.device.queue.copyExternalImageToTexture({ source: img }, { texture: _this._gpuTexture, origin: { x: 0, y: 0, z: index } }, { width: _this._width, height: _this._height, depthOrArrayLayers: 1 });
        });
    };
    CubeTexture.prototype._loadBuffer = function () {
        var _this = this;
        this._src.forEach(function (img, index) {
            renderEnv_1.default.device.queue.writeTexture({ texture: _this._gpuTexture, origin: { x: 0, y: 0, z: index } }, img, {}, { width: _this._width, height: _this._height, depthOrArrayLayers: 1 });
        });
    };
    CubeTexture.CLASS_NAME = 'CubeTexture';
    return CubeTexture;
}(HObject_1.default));
exports["default"] = CubeTexture;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3ViZVRleHR1cmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJDdWJlVGV4dHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFNQSxxQ0FBZ0M7QUFDaEMseUNBQW9DO0FBRXBDO0lBQXlDLCtCQUFPO0lBZTlDLHFCQUNZLE1BQWMsRUFDZCxPQUFlLEVBQ2YsSUFBbUMsRUFDbkMsT0FBd0M7UUFBeEMsd0JBQUEsRUFBQSxzQkFBd0M7UUFKcEQsWUFNRSxpQkFBTyxTQXFCUjtRQTFCVyxZQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUksR0FBSixJQUFJLENBQStCO1FBQ25DLGFBQU8sR0FBUCxPQUFPLENBQWlDO1FBakI3QyxtQkFBYSxHQUFZLElBQUksQ0FBQztRQXFCbkMsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDakQ7UUFFRCxLQUFJLENBQUMsV0FBVyxHQUFHLG1CQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztZQUNoRCxJQUFJLEVBQUUsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxFQUFDO1lBQzdELE1BQU0sRUFBRSxPQUFPO1lBQ2YsS0FBSyxFQUFFLGVBQWUsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUMsaUJBQWlCO1NBQ3RHLENBQUMsQ0FBQztRQUVILEtBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7WUFDdkMsU0FBUyxFQUFFLE1BQU07U0FDbEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksV0FBVyxFQUFFO1lBQ2xDLEtBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNqQjthQUFNO1lBQ0wsS0FBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCOztJQUNILENBQUM7SUF0Q2EsY0FBRSxHQUFoQixVQUFpQixLQUFVO1FBQ3pCLE9BQU8sQ0FBQyxDQUFFLEtBQXFCLENBQUMsYUFBYSxDQUFDO0lBQ2hELENBQUM7SUFLRCxzQkFBSSw2QkFBSTthQUFSO1lBQ0UsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7OztPQUFBO0lBK0JTLDhCQUFRLEdBQWxCO1FBQUEsaUJBUUM7UUFQRSxJQUFJLENBQUMsSUFBc0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHLEVBQUUsS0FBSztZQUM5QyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsMEJBQTBCLENBQy9DLEVBQUMsTUFBTSxFQUFFLEdBQUcsRUFBQyxFQUNiLEVBQUMsT0FBTyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEVBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUMsRUFBQyxFQUMzRCxFQUFDLEtBQUssRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFJLENBQUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLENBQUMsRUFBQyxDQUNsRSxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBRVMsaUNBQVcsR0FBckI7UUFBQSxpQkFTQztRQVJFLElBQUksQ0FBQyxJQUFzQixDQUFDLE9BQU8sQ0FBQyxVQUFDLEdBQUcsRUFBRSxLQUFLO1lBQzlDLG1CQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQ2pDLEVBQUMsT0FBTyxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEVBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUMsRUFBQyxFQUMzRCxHQUFHLEVBQ0gsRUFBRSxFQUNGLEVBQUMsS0FBSyxFQUFFLEtBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUksQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxFQUFDLENBQ2xFLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUE5RGEsc0JBQVUsR0FBVyxhQUFhLENBQUM7SUErRG5ELGtCQUFDO0NBQUEsQUFoRUQsQ0FBeUMsaUJBQU8sR0FnRS9DO2tCQWhFb0IsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3ViZVRleHR1cmUudHNcbiAqIFxuICogQEF1dGhvciAgOmR0eXNreShkdHlza3lAb3V0bG9vay5jb20pXG4gKiBARGF0ZSAgICA6IDYvMTMvMjAyMSwgMTI6MTA6MDcgQU1cbiovXG5pbXBvcnQgSE9iamVjdCBmcm9tICcuL0hPYmplY3QnO1xuaW1wb3J0IHJlbmRlckVudiBmcm9tICcuL3JlbmRlckVudic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmVUZXh0dXJlIGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0N1YmVUZXh0dXJlJztcbiAgcHVibGljIGlzQ3ViZVRleHR1cmU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHB1YmxpYyBzdGF0aWMgSVModmFsdWU6IGFueSk6IHZhbHVlIGlzIEN1YmVUZXh0dXJlIHtcbiAgICByZXR1cm4gISEodmFsdWUgYXMgQ3ViZVRleHR1cmUpLmlzQ3ViZVRleHR1cmU7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dwdVRleHR1cmU6IEdQVVRleHR1cmU7XG4gIHByb3RlY3RlZCBfdmlldzogR1BVVGV4dHVyZVZpZXc7XG5cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX3dpZHRoOiBudW1iZXIsXG4gICAgcHJvdGVjdGVkIF9oZWlnaHQ6IG51bWJlcixcbiAgICBwcm90ZWN0ZWQgX3NyYzogQXJyYXlCdWZmZXJbXSB8IEltYWdlQml0bWFwW10sXG4gICAgcHJvdGVjdGVkIF9mb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQgPSAncmdiYTh1bm9ybSdcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChfc3JjLmxlbmd0aCA8IDYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ViZVRleHR1cmUgbXVzdCBoYXMgNiBzbGljZScpO1xuICAgIH1cblxuICAgIHRoaXMuX2dwdVRleHR1cmUgPSByZW5kZXJFbnYuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgc2l6ZToge3dpZHRoOiBfd2lkdGgsIGhlaWdodDogX2hlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiA2fSxcbiAgICAgIGZvcm1hdDogX2Zvcm1hdCxcbiAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UXG4gICAgfSk7XG5cbiAgICB0aGlzLl92aWV3ID0gdGhpcy5fZ3B1VGV4dHVyZS5jcmVhdGVWaWV3KHtcbiAgICAgIGRpbWVuc2lvbjogJ2N1YmUnXG4gICAgfSk7XG5cbiAgICBpZiAoX3NyY1swXSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICB0aGlzLl9sb2FkSW1nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvYWRCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2xvYWRJbWcoKSB7XG4gICAgKHRoaXMuX3NyYyBhcyBJbWFnZUJpdG1hcFtdKS5mb3JFYWNoKChpbWcsIGluZGV4KSA9PiB7XG4gICAgICByZW5kZXJFbnYuZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxuICAgICAgICB7c291cmNlOiBpbWd9LFxuICAgICAgICB7dGV4dHVyZTogdGhpcy5fZ3B1VGV4dHVyZSwgb3JpZ2luOiB7eDogMCwgeTogMCwgejogaW5kZXh9fSxcbiAgICAgICAge3dpZHRoOiB0aGlzLl93aWR0aCwgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMX1cbiAgICAgICk7XG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfbG9hZEJ1ZmZlcigpIHtcbiAgICAodGhpcy5fc3JjIGFzIEFycmF5QnVmZmVyW10pLmZvckVhY2goKGltZywgaW5kZXgpID0+IHtcbiAgICAgIHJlbmRlckVudi5kZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxuICAgICAgICB7dGV4dHVyZTogdGhpcy5fZ3B1VGV4dHVyZSwgb3JpZ2luOiB7eDogMCwgeTogMCwgejogaW5kZXh9fSxcbiAgICAgICAgaW1nLFxuICAgICAgICB7fSxcbiAgICAgICAge3dpZHRoOiB0aGlzLl93aWR0aCwgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMX1cbiAgICAgICk7XG4gICAgfSlcbiAgfVxufSJdfQ==

/***/ }),

/***/ "./src/core/Effect.ts":
/*!****************************!*\
  !*** ./src/core/Effect.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_RENDER_STATES = void 0;
var shared_1 = __webpack_require__(/*! ./shared */ "./src/core/shared.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var UBTemplate_1 = __webpack_require__(/*! ./UBTemplate */ "./src/core/UBTemplate.ts");
exports.DEFAULT_RENDER_STATES = {
    cullMode: 'back',
    primitiveType: 'triangle-list',
    depthCompare: 'less-equal'
};
function isComputeOptions(value) {
    return !!value.cs;
}
var Effect = (function (_super) {
    __extends(Effect, _super);
    function Effect(name, _options) {
        var _this = _super.call(this) || this;
        _this._options = _options;
        _this.isEffect = true;
        _this._shaders = {};
        _this.name = name;
        var options = _options;
        var visibility = options.cs ? GPUShaderStage.COMPUTE : GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
        _this._ubTemplate = new UBTemplate_1.default(options.uniformDesc, UBTemplate_1.EUBGroup.Material, visibility);
        _this._renderStates = Object.assign({}, exports.DEFAULT_RENDER_STATES, options.renderState || {});
        _this._marcos = options.marcos || {};
        _this._marcosRegex = {};
        for (var key in _this._marcos) {
            var value = _this._marcos[key];
            if (typeof value === 'number') {
                _this._marcosRegex[key] = new RegExp("\\$\\{" + key + "\\}", 'g');
            }
            else {
                _this._marcosRegex[key] = {
                    hasElse: new RegExp("#if defined\\(" + key + "\\)([\\s\\S]+?)#else([\\s\\S]+?)#endif", 'g'),
                    noElse: new RegExp("#if defined\\(" + key + "\\)([\\s\\S]+?)#endif", 'g'),
                };
            }
        }
        if (isComputeOptions(options)) {
            _this._cs = options.cs;
        }
        else {
            _this._vs = options.vs;
            _this._fs = options.fs;
        }
        return _this;
    }
    Object.defineProperty(Effect.prototype, "ubTemplate", {
        get: function () {
            return this._ubTemplate;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effect.prototype, "uniformLayout", {
        get: function () {
            return this._ubTemplate.uniformLayout;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effect.prototype, "renderStates", {
        get: function () {
            return this._renderStates;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effect.prototype, "isCompute", {
        get: function () {
            return !!this._cs;
        },
        enumerable: false,
        configurable: true
    });
    Effect.prototype.createDefaultUniformBlock = function () {
        return this._ubTemplate.createUniformBlock();
    };
    Effect.prototype.getShader = function (marcos, attributesDef, globalPrefix, objectPrefix) {
        marcos = Object.assign({}, this._marcos, marcos);
        var device = renderEnv_1.default.device;
        var hash = this._calcHash(attributesDef, globalPrefix, objectPrefix, marcos);
        var shaders = this._shaders[hash];
        if (shaders) {
            return shaders;
        }
        var tmp = [this._vs, this._fs, this._cs];
        var _loop_1 = function (key) {
            var value = marcos[key];
            var regex = this_1._marcosRegex[key];
            tmp.forEach(function (s, i) {
                if (!s) {
                    return;
                }
                if (typeof value === 'number') {
                    tmp[i] = s.replace(regex, "" + value);
                }
                else {
                    var _a = regex, hasElse = _a.hasElse, noElse = _a.noElse;
                    hasElse.lastIndex = 0;
                    noElse.lastIndex = 0;
                    tmp[i] = s.replace(hasElse, value ? '$1' : '$2');
                    tmp[i] = tmp[i].replace(noElse, value ? '$1' : '');
                }
            });
        };
        var this_1 = this;
        for (var key in this._marcos) {
            _loop_1(key);
        }
        var prefix = globalPrefix + '\n' + objectPrefix + '\n' + this._ubTemplate.shaderPrefix;
        var vs = tmp[0], fs = tmp[1], cs = tmp[2];
        var res = this._shaders[hash] = {
            vs: vs && device.createShaderModule({ code: attributesDef + prefix + vs }),
            fs: fs && device.createShaderModule({ code: prefix + fs }),
            cs: cs && device.createShaderModule({ code: prefix + cs })
        };
        return res;
    };
    Effect.prototype._calcHash = function (def, globalPrefix, objectPrefix, marcos) {
        var hash = shared_1.hashCode(def);
        hash = (hash << 5) - hash + shared_1.hashCode(globalPrefix);
        hash = (hash << 5) - hash + shared_1.hashCode(objectPrefix);
        for (var key in this._marcos) {
            var value = marcos[key];
            var hashValue = typeof value === 'number' ? value : (value ? 1 : 0);
            hash = (hash << 5) - hash + hashValue;
        }
        return hash;
    };
    Effect.CLASS_NAME = 'Effect';
    return Effect;
}(HObject_1.default));
exports["default"] = Effect;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWZmZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiRWZmZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSxtQ0FBa0M7QUFDbEMseUNBQW9DO0FBQ3BDLHFDQUFnQztBQUNoQywyQ0FBdUU7QUFVMUQsUUFBQSxxQkFBcUIsR0FBa0I7SUFDbEQsUUFBUSxFQUFFLE1BQU07SUFDaEIsYUFBYSxFQUFFLGVBQWU7SUFDOUIsWUFBWSxFQUFFLFlBQVk7Q0FDM0IsQ0FBQztBQWdCRixTQUFTLGdCQUFnQixDQUFDLEtBQXFCO0lBQzdDLE9BQU8sQ0FBQyxDQUFFLEtBQStCLENBQUMsRUFBRSxDQUFDO0FBQy9DLENBQUM7QUFFRDtJQUFvQywwQkFBTztJQWlDekMsZ0JBQ0UsSUFBWSxFQUNKLFFBQXdCO1FBRmxDLFlBSUUsaUJBQU8sU0E0QlI7UUE5QlMsY0FBUSxHQUFSLFFBQVEsQ0FBZ0I7UUFqQzNCLGNBQVEsR0FBWSxJQUFJLENBQUM7UUFRdEIsY0FBUSxHQUliLEVBQUUsQ0FBQztRQXlCTixLQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQTtRQUNoQixJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBTSxVQUFVLEdBQUksT0FBaUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztRQUNwSSxLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksb0JBQVUsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLHFCQUFRLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3RGLEtBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsNkJBQXFCLEVBQUcsT0FBZ0MsQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLENBQUM7UUFFbkgsS0FBSSxDQUFDLE9B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WyIvKipcbiAqIEVmZmVjdC50c1xuICogXG4gKiBAQXV0aG9yICA6ZHR5c2t5KGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBEYXRlICAgIDogMjAyMS82LzfkuIvljYgxOjUxOjExXG4gKi9cbmltcG9ydCB7aGFzaENvZGV9IGZyb20gXCIuL3NoYXJlZFwiO1xuaW1wb3J0IHJlbmRlckVudiBmcm9tIFwiLi9yZW5kZXJFbnZcIjtcbmltcG9ydCBIT2JqZWN0IGZyb20gXCIuL0hPYmplY3RcIjtcbmltcG9ydCBVQlRlbXBsYXRlLCB7RVVCR3JvdXAsIElVbmlmb3Jtc0Rlc2NyaXB0b3J9IGZyb20gXCIuL1VCVGVtcGxhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJUmVuZGVyU3RhdGVzIHtcbiAgY3VsbE1vZGU/OiBHUFVDdWxsTW9kZTtcbiAgcHJpbWl0aXZlVHlwZT86IEdQVVByaW1pdGl2ZVRvcG9sb2d5O1xuICBibGVuZENvbG9yPzogR1BVQmxlbmRDb21wb25lbnQ7XG4gIGJsZW5kQWxwaGE/OiBHUFVCbGVuZENvbXBvbmVudDtcbiAgZGVwdGhDb21wYXJlPzogR1BVQ29tcGFyZUZ1bmN0aW9uO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRU5ERVJfU1RBVEVTOiBJUmVuZGVyU3RhdGVzID0ge1xuICBjdWxsTW9kZTogJ2JhY2snLFxuICBwcmltaXRpdmVUeXBlOiAndHJpYW5nbGUtbGlzdCcsXG4gIGRlcHRoQ29tcGFyZTogJ2xlc3MtZXF1YWwnXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElFZmZlY3RPcHRpb25zUmVuZGVyIHtcbiAgdnM6IHN0cmluZztcbiAgZnM6IHN0cmluZztcbiAgdW5pZm9ybURlc2M6IElVbmlmb3Jtc0Rlc2NyaXB0b3I7XG4gIG1hcmNvcz86IHtba2V5OiBzdHJpbmddOiBudW1iZXIgfCBib29sZWFufTtcbiAgcmVuZGVyU3RhdGU/OiBJUmVuZGVyU3RhdGVzO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRWZmZWN0T3B0aW9uc0NvbXB1dGUge1xuICBjczogc3RyaW5nO1xuICB1bmlmb3JtRGVzYzogSVVuaWZvcm1zRGVzY3JpcHRvcjtcbiAgbWFyY29zPzoge1trZXk6IHN0cmluZ106IG51bWJlciB8IGJvb2xlYW59O1xufVxuZXhwb3J0IHR5cGUgVEVmZmVjdE9wdGlvbnMgPSBJRWZmZWN0T3B0aW9uc1JlbmRlciB8IElFZmZlY3RPcHRpb25zQ29tcHV0ZTtcblxuZnVuY3Rpb24gaXNDb21wdXRlT3B0aW9ucyh2YWx1ZTogVEVmZmVjdE9wdGlvbnMpOiB2YWx1ZSBpcyBJRWZmZWN0T3B0aW9uc0NvbXB1dGUge1xuICByZXR1cm4gISEodmFsdWUgYXMgSUVmZmVjdE9wdGlvbnNDb21wdXRlKS5jcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWZmZWN0IGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0VmZmVjdCc7XG4gIHB1YmxpYyBpc0VmZmVjdDogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9tYXJjb3M/OiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn07XG4gIHByb3RlY3RlZCBfcmVuZGVyU3RhdGVzOiBJUmVuZGVyU3RhdGVzO1xuICBwcm90ZWN0ZWQgX21hcmNvc1JlZ2V4OiB7W2tleTogc3RyaW5nXTogUmVnRXhwIHwge2hhc0Vsc2U6IFJlZ0V4cCwgbm9FbHNlOiBSZWdFeHB9fTtcbiAgcHJvdGVjdGVkIF92czogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX2ZzOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfY3M6IHN0cmluZztcbiAgcHJvdGVjdGVkIF9zaGFkZXJzOiB7W2hhc2g6IG51bWJlcl06IHtcbiAgICB2cz86IEdQVVNoYWRlck1vZHVsZSxcbiAgICBmcz86IEdQVVNoYWRlck1vZHVsZSxcbiAgICBjcz86IEdQVVNoYWRlck1vZHVsZVxuICB9fSA9IHt9O1xuICBwcm90ZWN0ZWQgX3ViVGVtcGxhdGU6IFVCVGVtcGxhdGU7XG5cbiAgZ2V0IHViVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ViVGVtcGxhdGU7XG4gIH1cblxuICBnZXQgdW5pZm9ybUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWJUZW1wbGF0ZS51bmlmb3JtTGF5b3V0O1xuICB9XG5cbiAgZ2V0IHJlbmRlclN0YXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyU3RhdGVzO1xuICB9XG5cbiAgZ2V0IGlzQ29tcHV0ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9jcztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIF9vcHRpb25zOiBURWZmZWN0T3B0aW9uc1xuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIGNvbnN0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0gKG9wdGlvbnMgYXMgSUVmZmVjdE9wdGlvbnNDb21wdXRlKS5jcyA/IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUgOiBHUFVTaGFkZXJTdGFnZS5WRVJURVggfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVDtcbiAgICB0aGlzLl91YlRlbXBsYXRlID0gbmV3IFVCVGVtcGxhdGUob3B0aW9ucy51bmlmb3JtRGVzYywgRVVCR3JvdXAuTWF0ZXJpYWwsIHZpc2liaWxpdHkpO1xuICAgIHRoaXMuX3JlbmRlclN0YXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUkVOREVSX1NUQVRFUywgKG9wdGlvbnMgYXMgSUVmZmVjdE9wdGlvbnNSZW5kZXIpLnJlbmRlclN0YXRlIHx8IHt9KTtcblxuICAgIHRoaXMuX21hcmNvcyA9IG9wdGlvbnMubWFyY29zIHx8IHt9O1xuICAgIHRoaXMuX21hcmNvc1JlZ2V4ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fbWFyY29zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX21hcmNvc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5fbWFyY29zUmVnZXhba2V5XSA9IG5ldyBSZWdFeHAoYFxcXFxcXCRcXFxceyR7a2V5fVxcXFxcXH1gLCAnZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWFyY29zUmVnZXhba2V5XSA9IHtcbiAgICAgICAgICBoYXNFbHNlOiBuZXcgUmVnRXhwKGAjaWYgZGVmaW5lZFxcXFwoJHtrZXl9XFxcXCkoW1xcXFxzXFxcXFNdKz8pI2Vsc2UoW1xcXFxzXFxcXFNdKz8pI2VuZGlmYCwgJ2cnKSxcbiAgICAgICAgICBub0Vsc2U6IG5ldyBSZWdFeHAoYCNpZiBkZWZpbmVkXFxcXCgke2tleX1cXFxcKShbXFxcXHNcXFxcU10rPykjZW5kaWZgLCAnZycpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NvbXB1dGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLl9jcyA9IG9wdGlvbnMuY3NcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdnMgPSBvcHRpb25zLnZzO1xuICAgICAgdGhpcy5fZnMgPSBvcHRpb25zLmZzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVEZWZhdWx0VW5pZm9ybUJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl91YlRlbXBsYXRlLmNyZWF0ZVVuaWZvcm1CbG9jaygpO1xuICB9XG5cbiAgcHVibGljIGdldFNoYWRlcihcbiAgICBtYXJjb3M6IHtba2V5OiBzdHJpbmddOiBudW1iZXIgfCBib29sZWFufSxcbiAgICBhdHRyaWJ1dGVzRGVmOiBzdHJpbmcsIGdsb2JhbFByZWZpeDogc3RyaW5nLCBvYmplY3RQcmVmaXg6IHN0cmluZ1xuICApIHtcbiAgICBtYXJjb3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9tYXJjb3MsIG1hcmNvcyk7XG4gICAgY29uc3Qge2RldmljZX0gPSByZW5kZXJFbnY7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NhbGNIYXNoKGF0dHJpYnV0ZXNEZWYsIGdsb2JhbFByZWZpeCwgb2JqZWN0UHJlZml4LCBtYXJjb3MpO1xuICAgIGNvbnN0IHNoYWRlcnMgPSB0aGlzLl9zaGFkZXJzW2hhc2hdO1xuXG4gICAgaWYgKHNoYWRlcnMpIHtcbiAgICAgIHJldHVybiBzaGFkZXJzO1xuICAgIH1cblxuICAgIGNvbnN0IHRtcCA9IFt0aGlzLl92cywgdGhpcy5fZnMsIHRoaXMuX2NzXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX21hcmNvcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtYXJjb3Nba2V5XTtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gdGhpcy5fbWFyY29zUmVnZXhba2V5XTtcblxuICAgICAgdG1wLmZvckVhY2goKHMsIGkpID0+IHtcbiAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0bXBbaV0gPSBzLnJlcGxhY2UocmVnZXggYXMgUmVnRXhwLCBgJHt2YWx1ZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB7aGFzRWxzZSwgbm9FbHNlfSA9IHJlZ2V4IGFzIHtoYXNFbHNlOiBSZWdFeHAsIG5vRWxzZTogUmVnRXhwfTtcbiAgICAgICAgICBoYXNFbHNlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgbm9FbHNlLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgICB0bXBbaV0gPSBzLnJlcGxhY2UoaGFzRWxzZSwgdmFsdWUgPyAnJDEnIDogJyQyJyk7XG4gICAgICAgICAgdG1wW2ldID0gdG1wW2ldLnJlcGxhY2Uobm9FbHNlLCB2YWx1ZSA/ICckMScgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeCA9IGdsb2JhbFByZWZpeCArICdcXG4nICsgb2JqZWN0UHJlZml4ICsgJ1xcbicgKyB0aGlzLl91YlRlbXBsYXRlLnNoYWRlclByZWZpeDtcbiAgICBjb25zdCBbdnMsIGZzLCBjc10gPSB0bXA7XG4gICAgY29uc3QgcmVzID0gdGhpcy5fc2hhZGVyc1toYXNoXSA9IHtcbiAgICAgIHZzOiB2cyAmJiBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOiBhdHRyaWJ1dGVzRGVmICsgcHJlZml4ICsgdnN9KSxcbiAgICAgIGZzOiBmcyAmJiBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOiBwcmVmaXggKyBmc30pLFxuICAgICAgY3M6IGNzICYmIGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6IHByZWZpeCArIGNzfSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHByaXZhdGUgX2NhbGNIYXNoKFxuICAgIGRlZjogc3RyaW5nLCBnbG9iYWxQcmVmaXg6IHN0cmluZywgb2JqZWN0UHJlZml4OiBzdHJpbmcsXG4gICAgbWFyY29zOiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn1cbiAgKTogbnVtYmVyIHtcbiAgICBsZXQgaGFzaDogbnVtYmVyID0gaGFzaENvZGUoZGVmKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgaGFzaENvZGUoZ2xvYmFsUHJlZml4KTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgaGFzaENvZGUob2JqZWN0UHJlZml4KTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX21hcmNvcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtYXJjb3Nba2V5XTtcbiAgICAgIGNvbnN0IGhhc2hWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6ICh2YWx1ZSA/IDEgOiAwKTtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBoYXNoVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./src/core/Geometry.ts":
/*!******************************!*\
  !*** ./src/core/Geometry.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var shared_1 = __webpack_require__(/*! ./shared */ "./src/core/shared.ts");
var Geometry = (function (_super) {
    __extends(Geometry, _super);
    function Geometry(_vertexes, _indexData, count, _boundingBox) {
        var _this = _super.call(this) || this;
        _this._vertexes = _vertexes;
        _this._indexData = _indexData;
        _this.count = count;
        _this._boundingBox = _boundingBox;
        _this.isGeometry = true;
        _this._iBuffer = shared_1.createGPUBuffer(_indexData, GPUBufferUsage.INDEX);
        _this._vBuffers = new Array(_vertexes.length);
        _this._vLayouts = new Array(_vertexes.length);
        _this._indexFormat = _indexData instanceof Uint16Array ? 'uint16' : 'uint32';
        _this._vInfo = {};
        _this._marcos = {};
        _this._attributesDef = 'struct Attrs {\n';
        _vertexes.forEach(function (_a, index) {
            var layout = _a.layout, data = _a.data, usage = _a.usage;
            var vBuffer = shared_1.createGPUBuffer(data, GPUBufferUsage.VERTEX | (usage | 0));
            layout.attributes.forEach(function (attr) {
                _this._marcos["USE_" + attr.name.toUpperCase()] = true;
                _this._attributesDef += "  [[location(" + attr.shaderLocation + ")]] " + attr.name + ": " + _this._convertFormat(attr.format) + ";\n";
                _this._vInfo[attr.name.toLowerCase()] = {
                    data: data, index: index,
                    offset: attr.offset / 4, stride: layout.arrayStride / 4, length: _this._getLength(attr.format)
                };
            });
            _this._vBuffers[index] = vBuffer;
            _this._vLayouts[index] = layout;
            _this._vertexCount = data.byteLength / layout.arrayStride;
        });
        _this._attributesDef += '};\n\n';
        return _this;
    }
    Object.defineProperty(Geometry.prototype, "indexes", {
        get: function () {
            return this._iBuffer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "indexData", {
        get: function () {
            return this._indexData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "vertexes", {
        get: function () {
            return this._vBuffers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "vertexLayouts", {
        get: function () {
            return this._vLayouts;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "vertexCount", {
        get: function () {
            return this._vertexCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "vertexInfo", {
        get: function () {
            return this._vInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "attributesDef", {
        get: function () {
            return this._attributesDef;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "indexFormat", {
        get: function () {
            return this._indexFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "marcos", {
        get: function () {
            return this._marcos;
        },
        enumerable: false,
        configurable: true
    });
    Geometry.prototype.calculateNormals = function () {
        var _a = this, _vInfo = _a._vInfo, _vertexCount = _a._vertexCount, _indexData = _a._indexData, count = _a.count;
        if (_vInfo.normal) {
            return;
        }
        var position = _vInfo.position;
        var data = new Float32Array(_vertexCount * 3);
        var boundingMin;
        var boundingMax;
        var calcBounding = !this._boundingBox;
        if (calcBounding) {
            boundingMax = [-Infinity, -Infinity, -Infinity];
            boundingMin = [Infinity, Infinity, Infinity];
        }
        var vMultiFaceCount = new Uint8Array(_vertexCount);
        var v31;
        var v32;
        var v33;
        var offset;
        for (var i = 0; i < count; i += 1) {
            offset = position.offset + _indexData[i] * position.stride;
            v31 = position.data.slice(offset, offset + position.length);
            offset = position.offset + _indexData[i + 1] * position.stride;
            v32 = position.data.slice(offset, offset + position.length);
            offset = position.offset + _indexData[i + 2] * position.stride;
            v33 = position.data.slice(offset, offset + position.length);
            if (calcBounding) {
                this._calcBonding(boundingMax, boundingMin, v31);
                this._calcBonding(boundingMax, boundingMin, v32);
                this._calcBonding(boundingMax, boundingMin, v33);
            }
            gl_matrix_1.vec3.sub(v32, v32, v31);
            gl_matrix_1.vec3.sub(v33, v33, v31);
            gl_matrix_1.vec3.cross(v32, v32, v33);
            for (var vi = 0; vi < 3; vi += 1) {
                var index = _indexData[i + vi];
                if (vMultiFaceCount[index]) {
                    var oldData = new Float32Array(data.buffer, index * 3 * 4, 3);
                    gl_matrix_1.vec3.scale(oldData, oldData, vMultiFaceCount[index]);
                    gl_matrix_1.vec3.add(oldData, oldData, v32);
                    gl_matrix_1.vec3.scale(oldData, oldData, 1 / (vMultiFaceCount[i] + 1));
                }
                else {
                    data.set(v32, index * 3);
                }
                vMultiFaceCount[index] += 1;
            }
        }
        _vInfo.normal = { offset: 0, length: 3, stride: 3, data: data, index: 0 };
        if (calcBounding) {
            this._boundingBox = {
                start: boundingMin,
                center: boundingMax.map(function (v, i) { return (v + boundingMin[i]) / 2; }),
                size: boundingMax.map(function (v, i) { return v - boundingMin[i]; })
            };
        }
    };
    Geometry.prototype.getValues = function (name) {
        return {
            cpu: this._vInfo[name].data,
            gpu: this._vBuffers[this._vInfo[name].index]
        };
    };
    Geometry.prototype._calcBonding = function (max, min, p) {
        for (var index = 0; index < 3; index += 1) {
            max[index] = Math.max(max[index], p[index]);
            min[index] = Math.min(min[index], p[index]);
        }
    };
    Geometry.prototype._convertFormat = function (f) {
        switch (f) {
            case 'float32':
                return 'f32';
            case 'float32x2':
                return 'vec2<f32>';
            case 'float32x3':
                return 'vec3<f32>';
            case 'float32x4':
                return 'vec4<f32>';
            case 'uint32':
                return 'u32';
            case 'uint32x2':
                return 'vec2<u32>';
            case 'uint32x3':
                return 'vec3<u32>';
            case 'uint32x4':
                return 'vec4<u32>';
        }
        throw new Error("Not support format " + f + "!");
    };
    Geometry.prototype._getLength = function (f) {
        switch (f) {
            case 'float32':
            case 'uint32':
                return 1;
            case 'float32x2':
            case 'uint32x2':
                return 2;
            case 'float32x3':
            case 'uint32x3':
                return 3;
            case 'float32x4':
            case 'uint32x4':
                return 4;
        }
        throw new Error("Not support format " + f + "!");
    };
    Geometry.prototype.updateVertexes = function () {
        console.warn('Not implemented!');
    };
    Geometry.prototype.updateIndexes = function () {
        console.warn('Not implemented!');
    };
    Geometry.CLASS_NAME = 'Geometry';
    return Geometry;
}(HObject_1.default));
exports["default"] = Geometry;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2VvbWV0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJHZW9tZXRyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFPQSx1Q0FBaUM7QUFDakMscUNBQWdDO0FBQ2hDLG1DQUFzRDtBQVF0RDtJQUFzQyw0QkFBTztJQTBEM0Msa0JBQ1ksU0FPUCxFQUNPLFVBQXFDLEVBQ3hDLEtBQWEsRUFDVixZQUEyQjtRQVh2QyxZQWFFLGlCQUFPLFNBNkJSO1FBekNXLGVBQVMsR0FBVCxTQUFTLENBT2hCO1FBQ08sZ0JBQVUsR0FBVixVQUFVLENBQTJCO1FBQ3hDLFdBQUssR0FBTCxLQUFLLENBQVE7UUFDVixrQkFBWSxHQUFaLFlBQVksQ0FBZTtRQW5FaEMsZ0JBQVUsR0FBWSxJQUFJLENBQUM7UUF1RWhDLEtBQUksQ0FBQyxRQUFRLEdBQUcsd0JBQWUsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xFLEtBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdDLEtBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdDLEtBQUksQ0FBQyxZQUFZLEdBQUcsVUFBVSxZQUFZLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDNUUsS0FBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDakIsS0FBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsS0FBSSxDQUFDLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQztRQUV6QyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQUMsRUFBcUIsRUFBRSxLQUFLO2dCQUEzQixNQUFNLFlBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxLQUFLLFdBQUE7WUFDckMsSUFBTSxPQUFPLEdBQUcsd0JBQWUsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTNFLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSTtnQkFDN0IsS0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQ3RELEtBQUksQ0FBQyxjQUFjLElBQUksa0JBQWdCLElBQUksQ0FBQyxjQUFjLFlBQU8sSUFBSSxDQUFDLElBQUksVUFBSyxLQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBSyxDQUFDO2dCQUNySCxLQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRztvQkFDckMsSUFBSSxNQUFBLEVBQUUsS0FBSyxPQUFBO29CQUNYLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztpQkFDOUYsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1lBRUgsS0FBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUM7WUFDaEMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUM7WUFFL0IsS0FBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUM7UUFFSCxLQUFJLENBQUMsY0FBYyxJQUFJLFFBQVEsQ0FBQzs7SUFDbEMsQ0FBQztJQTlFRCxzQkFBSSw2QkFBTzthQUFYO1lBQ0UsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksK0JBQVM7YUFBYjtZQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN6QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDhCQUFRO2FBQVo7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDeEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxtQ0FBYTthQUFqQjtZQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN4QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLGlDQUFXO2FBQWY7WUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxnQ0FBVTthQUFkO1lBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3JCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksbUNBQWE7YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDN0IsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxpQ0FBVzthQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQzNCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksNEJBQU07YUFBVjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDOzs7T0FBQTtJQThDTSxtQ0FBZ0IsR0FBdkI7UUFDUSxJQUFBLEtBQTRDLElBQUksRUFBL0MsTUFBTSxZQUFBLEVBQUUsWUFBWSxrQkFBQSxFQUFFLFVBQVUsZ0JBQUEsRUFBRSxLQUFLLFdBQVEsQ0FBQztRQUV2RCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsT0FBTztTQUNSO1FBRUQsSUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNqQyxJQUFNLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFaEQsSUFBSSxXQUFxQyxDQUFDO1FBQzFDLElBQUksV0FBcUMsQ0FBQztRQUMxQyxJQUFNLFlBQVksR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDeEMsSUFBSSxZQUFZLEVBQUU7WUFDaEIsV0FBVyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNoRCxXQUFXLEdBQUcsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBTSxlQUFlLEdBQUcsSUFBSSxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDckQsSUFBSSxHQUFpQixDQUFDO1FBQ3RCLElBQUksR0FBaUIsQ0FBQztRQUN0QixJQUFJLEdBQWlCLENBQUM7UUFDdEIsSUFBSSxNQUFjLENBQUM7UUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQzNELEdBQUcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQWlCLENBQUM7WUFDNUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQy9ELEdBQUcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQWlCLENBQUM7WUFDNUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQy9ELEdBQUcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQWlCLENBQUM7WUFFNUUsSUFBSSxZQUFZLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDakQsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNqRCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDbEQ7WUFFRCxnQkFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3hCLGdCQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDeEIsZ0JBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUUxQixLQUFLLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hDLElBQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBRWpDLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUMxQixJQUFNLE9BQU8sR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNoRSxnQkFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUNyRCxnQkFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO29CQUNoQyxnQkFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM1RDtxQkFBTTtvQkFDTCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQzFCO2dCQUVELGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDN0I7U0FDRjtRQUdELE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLE1BQUEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFDbEUsSUFBSSxZQUFZLEVBQUU7WUFDaEIsSUFBSSxDQUFDLFlBQVksR0FBRztnQkFDbEIsS0FBSyxFQUFFLFdBQVc7Z0JBQ2xCLE1BQU0sRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBeEIsQ0FBd0IsQ0FBNkI7Z0JBQ3ZGLElBQUksRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxPQUFBLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQWxCLENBQWtCLENBQTZCO2FBQ2hGLENBQUM7U0FDSDtJQUNILENBQUM7SUFFTSw0QkFBUyxHQUFoQixVQUFpQixJQUFZO1FBQzNCLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJO1lBQzNCLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDO1NBQzdDLENBQUM7SUFDSixDQUFDO0lBRVMsK0JBQVksR0FBdEIsVUFBdUIsR0FBYSxFQUFFLEdBQWEsRUFBRSxDQUFvQjtRQUN2RSxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDekMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUM3QztJQUNILENBQUM7SUFFUyxpQ0FBYyxHQUF4QixVQUF5QixDQUFrQjtRQUN6QyxRQUFRLENBQUMsRUFBRTtZQUNULEtBQUssU0FBUztnQkFDWixPQUFPLEtBQUssQ0FBQztZQUNmLEtBQUssV0FBVztnQkFDZCxPQUFPLFdBQVcsQ0FBQztZQUNyQixLQUFLLFdBQVc7Z0JBQ2QsT0FBTyxXQUFXLENBQUM7WUFDckIsS0FBSyxXQUFXO2dCQUNkLE9BQU8sV0FBVyxDQUFDO1lBQ3JCLEtBQUssUUFBUTtnQkFDWCxPQUFPLEtBQUssQ0FBQztZQUNmLEtBQUssVUFBVTtnQkFDYixPQUFPLFdBQVcsQ0FBQztZQUNyQixLQUFLLFVBQVU7Z0JBQ2IsT0FBTyxXQUFXLENBQUM7WUFDckIsS0FBSyxVQUFVO2dCQUNiLE9BQU8sV0FBVyxDQUFDO1NBQ3RCO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBc0IsQ0FBQyxNQUFHLENBQUMsQ0FBQTtJQUM3QyxDQUFDO0lBRVMsNkJBQVUsR0FBcEIsVUFBcUIsQ0FBa0I7UUFDckMsUUFBUSxDQUFDLEVBQUU7WUFDVCxLQUFLLFNBQVMsQ0FBQztZQUNmLEtBQUssUUFBUTtnQkFDWCxPQUFPLENBQUMsQ0FBQztZQUNYLEtBQUssV0FBVyxDQUFDO1lBQ2pCLEtBQUssVUFBVTtnQkFDYixPQUFPLENBQUMsQ0FBQztZQUNYLEtBQUssV0FBVyxDQUFDO1lBQ2pCLEtBQUssVUFBVTtnQkFDYixPQUFPLENBQUMsQ0FBQztZQUNYLEtBQUssV0FBVyxDQUFDO1lBQ2pCLEtBQUssVUFBVTtnQkFDYixPQUFPLENBQUMsQ0FBQztTQUNaO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBc0IsQ0FBQyxNQUFHLENBQUMsQ0FBQTtJQUM3QyxDQUFDO0lBRU0saUNBQWMsR0FBckI7UUFDRSxPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVNLGdDQUFhLEdBQXBCO1FBQ0UsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUF2T2EsbUJBQVUsR0FBVyxVQUFVLENBQUM7SUF3T2hELGVBQUM7Q0FBQSxBQXpPRCxDQUFzQyxpQkFBTyxHQXlPNUM7a0JBek9vQixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBGaWxlICAgOiBHZW9tZXRyeS50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiAyMDIxLzYvNuS4i+WNiDg6NTY6NDlcbiAqL1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgSE9iamVjdCBmcm9tICcuL0hPYmplY3QnO1xuaW1wb3J0IHtjcmVhdGVHUFVCdWZmZXIsIFRUeXBlZEFycmF5fSBmcm9tICcuL3NoYXJlZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJvdW5kaW5nQm94IHtcbiAgc3RhcnQ6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY2VudGVyOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHNpemU6IFtudW1iZXIsIG51bWJlciwgIG51bWJlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlb21ldHJ5IGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0dlb21ldHJ5JztcbiAgcHVibGljIGlzR2VvbWV0cnk6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByb3RlY3RlZCBfdkxheW91dHM6IHtcbiAgICBhdHRyaWJ1dGVzOiAoR1BVVmVydGV4QXR0cmlidXRlICYge25hbWU6IHN0cmluZ30pW10sXG4gICAgYXJyYXlTdHJpZGU6IG51bWJlclxuICB9W107XG4gIHByb3RlY3RlZCBfdkluZm86IHtcbiAgICBbbmFtZTogc3RyaW5nXToge1xuICAgICAgZGF0YTogVFR5cGVkQXJyYXksIGluZGV4OiBudW1iZXIsXG4gICAgICAvLyBvZmZzZXQgYW5kIHN0cmlkZSBpcyBiYXNlZCA0LWJ5dGVzXG4gICAgICBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyXG4gICAgfVxuICB9O1xuICBwcm90ZWN0ZWQgX3ZCdWZmZXJzOiBHUFVCdWZmZXJbXTtcbiAgcHJvdGVjdGVkIF9pQnVmZmVyOiBHUFVCdWZmZXI7XG4gIHByb3RlY3RlZCBfaW5kZXhGb3JtYXQ6IEdQVUluZGV4Rm9ybWF0O1xuICBwcm90ZWN0ZWQgX3ZlcnRleENvdW50OiBudW1iZXI7XG4gIHByb3RlY3RlZCBfbWFyY29zOiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn07XG4gIHByb3RlY3RlZCBfYXR0cmlidXRlc0RlZjogc3RyaW5nO1xuXG4gIGdldCBpbmRleGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9pQnVmZmVyO1xuICB9XG5cbiAgZ2V0IGluZGV4RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhEYXRhO1xuICB9XG5cbiAgZ2V0IHZlcnRleGVzKCkge1xuICAgIHJldHVybiB0aGlzLl92QnVmZmVycztcbiAgfVxuXG4gIGdldCB2ZXJ0ZXhMYXlvdXRzKCkge1xuICAgIHJldHVybiB0aGlzLl92TGF5b3V0cztcbiAgfVxuXG4gIGdldCB2ZXJ0ZXhDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVydGV4Q291bnQ7XG4gIH1cblxuICBnZXQgdmVydGV4SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdkluZm87XG4gIH1cblxuICBnZXQgYXR0cmlidXRlc0RlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlc0RlZjtcbiAgfVxuXG4gIGdldCBpbmRleEZvcm1hdCgpOiBHUFVJbmRleEZvcm1hdCB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4Rm9ybWF0O1xuICB9XG5cbiAgZ2V0IG1hcmNvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyY29zO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF92ZXJ0ZXhlczoge1xuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IChHUFVWZXJ0ZXhBdHRyaWJ1dGUgJiB7bmFtZTogc3RyaW5nfSlbXSxcbiAgICAgICAgYXJyYXlTdHJpZGU6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhdGE6IFRUeXBlZEFycmF5LFxuICAgICAgdXNhZ2U/OiBudW1iZXJcbiAgICB9W10sXG4gICAgcHJvdGVjdGVkIF9pbmRleERhdGE6IFVpbnQxNkFycmF5IHwgVWludDMyQXJyYXksXG4gICAgcHVibGljIGNvdW50OiBudW1iZXIsXG4gICAgcHJvdGVjdGVkIF9ib3VuZGluZ0JveD86IElCb3VuZGluZ0JveFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faUJ1ZmZlciA9IGNyZWF0ZUdQVUJ1ZmZlcihfaW5kZXhEYXRhLCBHUFVCdWZmZXJVc2FnZS5JTkRFWCk7XG4gICAgdGhpcy5fdkJ1ZmZlcnMgPSBuZXcgQXJyYXkoX3ZlcnRleGVzLmxlbmd0aCk7XG4gICAgdGhpcy5fdkxheW91dHMgPSBuZXcgQXJyYXkoX3ZlcnRleGVzLmxlbmd0aCk7XG4gICAgdGhpcy5faW5kZXhGb3JtYXQgPSBfaW5kZXhEYXRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkgPyAndWludDE2JyA6ICd1aW50MzInO1xuICAgIHRoaXMuX3ZJbmZvID0ge307XG4gICAgdGhpcy5fbWFyY29zID0ge307XG4gICAgdGhpcy5fYXR0cmlidXRlc0RlZiA9ICdzdHJ1Y3QgQXR0cnMge1xcbic7XG5cbiAgICBfdmVydGV4ZXMuZm9yRWFjaCgoe2xheW91dCwgZGF0YSwgdXNhZ2V9LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdkJ1ZmZlciA9IGNyZWF0ZUdQVUJ1ZmZlcihkYXRhLCBHUFVCdWZmZXJVc2FnZS5WRVJURVggfCAodXNhZ2UgfCAwKSk7XG5cbiAgICAgIGxheW91dC5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgdGhpcy5fbWFyY29zW2BVU0VfJHthdHRyLm5hbWUudG9VcHBlckNhc2UoKX1gXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNEZWYgKz0gYCAgW1tsb2NhdGlvbigke2F0dHIuc2hhZGVyTG9jYXRpb259KV1dICR7YXR0ci5uYW1lfTogJHt0aGlzLl9jb252ZXJ0Rm9ybWF0KGF0dHIuZm9ybWF0KX07XFxuYDtcbiAgICAgICAgdGhpcy5fdkluZm9bYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICAgIGRhdGEsIGluZGV4LFxuICAgICAgICAgIG9mZnNldDogYXR0ci5vZmZzZXQgLyA0LCBzdHJpZGU6IGxheW91dC5hcnJheVN0cmlkZSAvIDQsIGxlbmd0aDogdGhpcy5fZ2V0TGVuZ3RoKGF0dHIuZm9ybWF0KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3ZCdWZmZXJzW2luZGV4XSA9IHZCdWZmZXI7XG4gICAgICB0aGlzLl92TGF5b3V0c1tpbmRleF0gPSBsYXlvdXQ7XG5cbiAgICAgIHRoaXMuX3ZlcnRleENvdW50ID0gZGF0YS5ieXRlTGVuZ3RoIC8gbGF5b3V0LmFycmF5U3RyaWRlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlc0RlZiArPSAnfTtcXG5cXG4nO1xuICB9XG5cbiAgcHVibGljIGNhbGN1bGF0ZU5vcm1hbHMoKSB7XG4gICAgY29uc3Qge192SW5mbywgX3ZlcnRleENvdW50LCBfaW5kZXhEYXRhLCBjb3VudH0gPSB0aGlzO1xuXG4gICAgaWYgKF92SW5mby5ub3JtYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IF92SW5mby5wb3NpdGlvbjtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShfdmVydGV4Q291bnQgKiAzKTtcblxuICAgIGxldCBib3VuZGluZ01pbjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBib3VuZGluZ01heDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGNvbnN0IGNhbGNCb3VuZGluZyA9ICF0aGlzLl9ib3VuZGluZ0JveDtcbiAgICBpZiAoY2FsY0JvdW5kaW5nKSB7XG4gICAgICBib3VuZGluZ01heCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgIGJvdW5kaW5nTWluID0gW0luZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIH1cblxuICAgIGNvbnN0IHZNdWx0aUZhY2VDb3VudCA9IG5ldyBVaW50OEFycmF5KF92ZXJ0ZXhDb3VudCk7XG4gICAgbGV0IHYzMTogRmxvYXQzMkFycmF5O1xuICAgIGxldCB2MzI6IEZsb2F0MzJBcnJheTtcbiAgICBsZXQgdjMzOiBGbG9hdDMyQXJyYXk7XG4gICAgbGV0IG9mZnNldDogbnVtYmVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgb2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0ICsgX2luZGV4RGF0YVtpXSAqIHBvc2l0aW9uLnN0cmlkZTtcbiAgICAgIHYzMSA9IHBvc2l0aW9uLmRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBwb3NpdGlvbi5sZW5ndGgpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIG9mZnNldCA9IHBvc2l0aW9uLm9mZnNldCArIF9pbmRleERhdGFbaSArIDFdICogcG9zaXRpb24uc3RyaWRlO1xuICAgICAgdjMyID0gcG9zaXRpb24uZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHBvc2l0aW9uLmxlbmd0aCkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgb2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0ICsgX2luZGV4RGF0YVtpICsgMl0gKiBwb3NpdGlvbi5zdHJpZGU7XG4gICAgICB2MzMgPSBwb3NpdGlvbi5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcG9zaXRpb24ubGVuZ3RoKSBhcyBGbG9hdDMyQXJyYXk7XG5cbiAgICAgIGlmIChjYWxjQm91bmRpbmcpIHtcbiAgICAgICAgdGhpcy5fY2FsY0JvbmRpbmcoYm91bmRpbmdNYXgsIGJvdW5kaW5nTWluLCB2MzEpO1xuICAgICAgICB0aGlzLl9jYWxjQm9uZGluZyhib3VuZGluZ01heCwgYm91bmRpbmdNaW4sIHYzMik7XG4gICAgICAgIHRoaXMuX2NhbGNCb25kaW5nKGJvdW5kaW5nTWF4LCBib3VuZGluZ01pbiwgdjMzKTtcbiAgICAgIH1cblxuICAgICAgdmVjMy5zdWIodjMyLCB2MzIsIHYzMSk7XG4gICAgICB2ZWMzLnN1Yih2MzMsIHYzMywgdjMxKTtcbiAgICAgIHZlYzMuY3Jvc3ModjMyLCB2MzIsIHYzMyk7XG5cbiAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCAzOyB2aSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gX2luZGV4RGF0YVtpICsgdmldO1xuXG4gICAgICAgIGlmICh2TXVsdGlGYWNlQ291bnRbaW5kZXhdKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGluZGV4ICogMyAqIDQsIDMpO1xuICAgICAgICAgIHZlYzMuc2NhbGUob2xkRGF0YSwgb2xkRGF0YSwgdk11bHRpRmFjZUNvdW50W2luZGV4XSk7XG4gICAgICAgICAgdmVjMy5hZGQob2xkRGF0YSwgb2xkRGF0YSwgdjMyKTtcbiAgICAgICAgICB2ZWMzLnNjYWxlKG9sZERhdGEsIG9sZERhdGEsIDEgLyAodk11bHRpRmFjZUNvdW50W2ldICsgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuc2V0KHYzMiwgaW5kZXggKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZNdWx0aUZhY2VDb3VudFtpbmRleF0gKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0b2RvOiBpbmRleFxuICAgIF92SW5mby5ub3JtYWwgPSB7b2Zmc2V0OiAwLCBsZW5ndGg6IDMsIHN0cmlkZTogMywgZGF0YSwgaW5kZXg6IDB9O1xuICAgIGlmIChjYWxjQm91bmRpbmcpIHtcbiAgICAgIHRoaXMuX2JvdW5kaW5nQm94ID0ge1xuICAgICAgICBzdGFydDogYm91bmRpbmdNaW4sXG4gICAgICAgIGNlbnRlcjogYm91bmRpbmdNYXgubWFwKCh2LCBpKSA9PiAodiArIGJvdW5kaW5nTWluW2ldKSAvIDIpIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgc2l6ZTogYm91bmRpbmdNYXgubWFwKCh2LCBpKSA9PiB2IC0gYm91bmRpbmdNaW5baV0pIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0VmFsdWVzKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBjcHU6IHRoaXMuX3ZJbmZvW25hbWVdLmRhdGEsXG4gICAgICBncHU6IHRoaXMuX3ZCdWZmZXJzW3RoaXMuX3ZJbmZvW25hbWVdLmluZGV4XVxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NhbGNCb25kaW5nKG1heDogbnVtYmVyW10sIG1pbjogbnVtYmVyW10sIHA6IEFycmF5TGlrZTxudW1iZXI+KSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDM7IGluZGV4ICs9IDEpIHtcbiAgICAgIG1heFtpbmRleF0gPSBNYXRoLm1heChtYXhbaW5kZXhdLCBwW2luZGV4XSk7XG4gICAgICBtaW5baW5kZXhdID0gTWF0aC5taW4obWluW2luZGV4XSwgcFtpbmRleF0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29udmVydEZvcm1hdChmOiBHUFVWZXJ0ZXhGb3JtYXQpIHtcbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gJ2YzMic7XG4gICAgICBjYXNlICdmbG9hdDMyeDInOlxuICAgICAgICByZXR1cm4gJ3ZlYzI8ZjMyPic7XG4gICAgICBjYXNlICdmbG9hdDMyeDMnOlxuICAgICAgICByZXR1cm4gJ3ZlYzM8ZjMyPic7XG4gICAgICBjYXNlICdmbG9hdDMyeDQnOlxuICAgICAgICByZXR1cm4gJ3ZlYzQ8ZjMyPic7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gJ3UzMic7XG4gICAgICBjYXNlICd1aW50MzJ4Mic6XG4gICAgICAgIHJldHVybiAndmVjMjx1MzI+JztcbiAgICAgIGNhc2UgJ3VpbnQzMngzJzpcbiAgICAgICAgcmV0dXJuICd2ZWMzPHUzMj4nO1xuICAgICAgY2FzZSAndWludDMyeDQnOlxuICAgICAgICByZXR1cm4gJ3ZlYzQ8dTMyPic7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydCBmb3JtYXQgJHtmfSFgKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRMZW5ndGgoZjogR1BVVmVydGV4Rm9ybWF0KSB7XG4gICAgc3dpdGNoIChmKSB7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSAnZmxvYXQzMngyJzpcbiAgICAgIGNhc2UgJ3VpbnQzMngyJzpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlICdmbG9hdDMyeDMnOlxuICAgICAgY2FzZSAndWludDMyeDMnOlxuICAgICAgICByZXR1cm4gMztcbiAgICAgIGNhc2UgJ2Zsb2F0MzJ4NCc6XG4gICAgICBjYXNlICd1aW50MzJ4NCc6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnQgZm9ybWF0ICR7Zn0hYClcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVWZXJ0ZXhlcygpIHtcbiAgICBjb25zb2xlLndhcm4oJ05vdCBpbXBsZW1lbnRlZCEnKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVJbmRleGVzKCkge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkIScpO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/core/HObject.ts":
/*!*****************************!*\
  !*** ./src/core/HObject.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject = (function () {
    function HObject() {
        this.isHObject = true;
        var className = this.constructor.CLASS_NAME;
        if (typeof className !== 'string') {
            throw new Error('Class must has a static member "CLASS_NAME" !');
        }
        HObject.IDS[className] = HObject.IDS[className] || 0;
        this._id = ++HObject.IDS[className];
        this._hash = className + "_" + this._id;
    }
    Object.defineProperty(HObject.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HObject.prototype, "hash", {
        get: function () {
            return this._hash;
        },
        enumerable: false,
        configurable: true
    });
    HObject.IDS = {};
    HObject.CLASS_NAME = 'HObject';
    return HObject;
}());
exports["default"] = HObject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSE9iamVjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkhPYmplY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFPQTtJQWtCRTtRQWRPLGNBQVMsR0FBWSxJQUFJLENBQUM7UUFlL0IsSUFBTSxTQUFTLEdBQUksSUFBSSxDQUFDLFdBQThCLENBQUMsVUFBVSxDQUFDO1FBRWxFLElBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztTQUNsRTtRQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckQsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLEtBQUssR0FBTSxTQUFTLFNBQUksSUFBSSxDQUFDLEdBQUssQ0FBQztJQUMxQyxDQUFDO0lBbkJELHNCQUFJLHVCQUFFO2FBQU47WUFDRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSx5QkFBSTthQUFSO1lBQ0UsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7OztPQUFBO0lBZmEsV0FBRyxHQUFrQyxFQUFFLENBQUM7SUFDeEMsa0JBQVUsR0FBVyxTQUFTLENBQUM7SUE0Qi9DLGNBQUM7Q0FBQSxBQTlCRCxJQThCQztrQkE5Qm9CLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQEZpbGUgICA6IEhPYmplY3QudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzbkuIvljYgxMToxNDoyMlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIT2JqZWN0IHtcbiAgcHVibGljIHN0YXRpYyBJRFM6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0hPYmplY3QnO1xuICBcbiAgcHVibGljIGlzSE9iamVjdDogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBuYW1lOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIF9pZDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX2hhc2g6IHN0cmluZztcblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG4gIFxuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9ICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBIT2JqZWN0KS5DTEFTU19OQU1FO1xuXG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIG11c3QgaGFzIGEgc3RhdGljIG1lbWJlciBcIkNMQVNTX05BTUVcIiAhJyk7XG4gICAgfVxuXG4gICAgSE9iamVjdC5JRFNbY2xhc3NOYW1lXSA9IEhPYmplY3QuSURTW2NsYXNzTmFtZV0gfHwgMDtcblxuICAgIHRoaXMuX2lkID0gKytIT2JqZWN0LklEU1tjbGFzc05hbWVdO1xuICAgIHRoaXMuX2hhc2ggPSBgJHtjbGFzc05hbWV9XyR7dGhpcy5faWR9YDtcbiAgfVxufVxuIl19

/***/ }),

/***/ "./src/core/ImageMesh.ts":
/*!*******************************!*\
  !*** ./src/core/ImageMesh.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var ImageMesh = (function (_super) {
    __extends(ImageMesh, _super);
    function ImageMesh(_material) {
        var _this = _super.call(this) || this;
        _this._material = _material;
        _this.isImageMesh = true;
        return _this;
    }
    Object.defineProperty(ImageMesh.prototype, "material", {
        get: function () {
            return this._material;
        },
        set: function (value) {
            this._material = value;
            this._pipeline = null;
        },
        enumerable: false,
        configurable: true
    });
    ImageMesh.prototype.render = function (pass) {
        var _material = this._material;
        !this._pipeline && this._createPipeline();
        pass.setBindGroup(1, _material.bindingGroup);
        pass.setPipeline(this._pipeline);
        pass.draw(6, 1, 0, 0);
    };
    ImageMesh.prototype._createPipeline = function () {
        var device = renderEnv_1.default.device, swapChainFormat = renderEnv_1.default.swapChainFormat;
        var _material = this._material;
        var _a = _material.effect.getShader(_material.marcos, '', renderEnv_1.default.shaderPrefix, ''), vs = _a.vs, fs = _a.fs;
        this._pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [
                    renderEnv_1.default.uniformLayout,
                    _material.effect.uniformLayout
                ] }),
            vertex: {
                module: vs,
                entryPoint: "main"
            },
            fragment: {
                module: fs,
                targets: [
                    { format: swapChainFormat }
                ],
                entryPoint: "main"
            },
            primitive: {
                topology: 'triangle-list'
            }
        });
    };
    ImageMesh.CLASS_NAME = 'ImageMesh';
    return ImageMesh;
}(HObject_1.default));
exports["default"] = ImageMesh;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VNZXNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiSW1hZ2VNZXNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQU9BLHFDQUFnQztBQUdoQyx5Q0FBb0M7QUFFcEM7SUFBdUMsNkJBQU87SUFlNUMsbUJBQXNCLFNBQW1CO1FBQXpDLFlBQ0UsaUJBQU8sU0FDUjtRQUZxQixlQUFTLEdBQVQsU0FBUyxDQUFVO1FBYmxDLGlCQUFXLEdBQVksSUFBSSxDQUFDOztJQWVuQyxDQUFDO0lBWEQsc0JBQUksK0JBQVE7YUFBWjtZQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN4QixDQUFDO2FBRUQsVUFBYSxLQUFlO1lBQzFCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLENBQUM7OztPQUxBO0lBV00sMEJBQU0sR0FBYixVQUFjLElBQTBCO1FBQy9CLElBQUEsU0FBUyxHQUFJLElBQUksVUFBUixDQUFTO1FBRXpCLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFMUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVTLG1DQUFlLEdBQXpCO1FBQ1MsSUFBQSxNQUFNLEdBQXFCLG1CQUFTLE9BQTlCLEVBQUUsZUFBZSxHQUFJLG1CQUFTLGdCQUFiLENBQWM7UUFDckMsSUFBQSxTQUFTLEdBQUksSUFBSSxVQUFSLENBQVM7UUFDbkIsSUFBQSxLQUFXLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLG1CQUFTLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUF0RixFQUFFLFFBQUEsRUFBRSxFQUFFLFFBQWdGLENBQUM7UUFFOUYsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUM7WUFDM0MsTUFBTSxFQUFFLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFDLGdCQUFnQixFQUFFO29CQUNyRCxtQkFBUyxDQUFDLGFBQWE7b0JBQ3ZCLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYTtpQkFDL0IsRUFBQyxDQUFDO1lBRUgsTUFBTSxFQUFFO2dCQUNOLE1BQU0sRUFBRSxFQUFFO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25CO1lBRUQsUUFBUSxFQUFFO2dCQUNSLE1BQU0sRUFBRSxFQUFFO2dCQUNWLE9BQU8sRUFBRTtvQkFDUCxFQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUM7aUJBQzFCO2dCQUNELFVBQVUsRUFBRSxNQUFNO2FBQ25CO1lBRUQsU0FBUyxFQUFFO2dCQUNULFFBQVEsRUFBRSxlQUFlO2FBQzFCO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQXhEYSxvQkFBVSxHQUFXLFdBQVcsQ0FBQztJQXlEakQsZ0JBQUM7Q0FBQSxBQTFERCxDQUF1QyxpQkFBTyxHQTBEN0M7a0JBMURvQixTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogSW1hZ2VNZXNoLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2IODo1Njo0OVxuICovXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCBIT2JqZWN0IGZyb20gJy4vSE9iamVjdCc7XG5pbXBvcnQgTGlnaHQgZnJvbSAnLi9MaWdodCc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi9NYXRlcmlhbCc7XG5pbXBvcnQgcmVuZGVyRW52IGZyb20gJy4vcmVuZGVyRW52JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VNZXNoIGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0ltYWdlTWVzaCc7XG4gIHB1YmxpYyBpc0ltYWdlTWVzaDogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9waXBlbGluZTogR1BVUmVuZGVyUGlwZWxpbmU7XG5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbDtcbiAgfVxuXG4gIHNldCBtYXRlcmlhbCh2YWx1ZTogTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IHZhbHVlO1xuICAgIHRoaXMuX3BpcGVsaW5lID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfbWF0ZXJpYWw6IE1hdGVyaWFsKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIocGFzczogR1BVUmVuZGVyUGFzc0VuY29kZXIpIHtcbiAgICBjb25zdCB7X21hdGVyaWFsfSA9IHRoaXM7XG5cbiAgICAhdGhpcy5fcGlwZWxpbmUgJiYgdGhpcy5fY3JlYXRlUGlwZWxpbmUoKTtcblxuICAgIHBhc3Muc2V0QmluZEdyb3VwKDEsIF9tYXRlcmlhbC5iaW5kaW5nR3JvdXApO1xuICAgIHBhc3Muc2V0UGlwZWxpbmUodGhpcy5fcGlwZWxpbmUpO1xuICAgIHBhc3MuZHJhdyg2LCAxLCAwLCAwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlUGlwZWxpbmUoKSB7XG4gICAgY29uc3Qge2RldmljZSwgc3dhcENoYWluRm9ybWF0fSA9IHJlbmRlckVudjtcbiAgICBjb25zdCB7X21hdGVyaWFsfSA9IHRoaXM7XG4gICAgY29uc3Qge3ZzLCBmc30gPSBfbWF0ZXJpYWwuZWZmZWN0LmdldFNoYWRlcihfbWF0ZXJpYWwubWFyY29zLCAnJywgcmVuZGVyRW52LnNoYWRlclByZWZpeCwgJycpO1xuXG4gICAgdGhpcy5fcGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgbGF5b3V0OiBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe2JpbmRHcm91cExheW91dHM6IFtcbiAgICAgICAgcmVuZGVyRW52LnVuaWZvcm1MYXlvdXQsXG4gICAgICAgIF9tYXRlcmlhbC5lZmZlY3QudW5pZm9ybUxheW91dFxuICAgICAgXX0pLFxuICBcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBtb2R1bGU6IHZzLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5cIlxuICAgICAgfSxcbiAgXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBtb2R1bGU6IGZzLFxuICAgICAgICB0YXJnZXRzOiBbXG4gICAgICAgICAge2Zvcm1hdDogc3dhcENoYWluRm9ybWF0fVxuICAgICAgICBdLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5cIlxuICAgICAgfSxcbiAgXG4gICAgICBwcmltaXRpdmU6IHtcbiAgICAgICAgdG9wb2xvZ3k6ICd0cmlhbmdsZS1saXN0J1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/core/Light.ts":
/*!***************************!*\
  !*** ./src/core/Light.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EAreaLightMode = exports.ELightType = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var geometries_1 = __webpack_require__(/*! ../buildin/geometries */ "./src/buildin/geometries.ts");
var Mesh_1 = __webpack_require__(/*! ./Mesh */ "./src/core/Mesh.ts");
var Node_1 = __webpack_require__(/*! ./Node */ "./src/core/Node.ts");
var ELightType;
(function (ELightType) {
    ELightType[ELightType["INVALID"] = 0] = "INVALID";
    ELightType[ELightType["Area"] = 1] = "Area";
    ELightType[ELightType["Directional"] = 2] = "Directional";
    ELightType[ELightType["Point"] = 3] = "Point";
    ELightType[ELightType["Spot"] = 4] = "Spot";
})(ELightType = exports.ELightType || (exports.ELightType = {}));
var EAreaLightMode;
(function (EAreaLightMode) {
    EAreaLightMode[EAreaLightMode["Rect"] = 0] = "Rect";
    EAreaLightMode[EAreaLightMode["Disc"] = 1] = "Disc";
})(EAreaLightMode = exports.EAreaLightMode || (exports.EAreaLightMode = {}));
var Light = (function (_super) {
    __extends(Light, _super);
    function Light(_type, color, otherOptions) {
        var _this = _super.call(this) || this;
        _this._type = _type;
        _this.isLight = true;
        _this._worldPos = new Float32Array(3);
        _this._worldDir = new Float32Array(3);
        _this._color = new Float32Array(color);
        _this._ubInfo = new Float32Array(40);
        var u32View = new Uint32Array(_this._ubInfo.buffer);
        u32View[0] = _type;
        if (_type === ELightType.Area) {
            _this._areaMode = otherOptions.mode;
            _this._areaSize = new Float32Array(otherOptions.size);
            u32View[1] = _this._areaMode;
            _this._ubInfo.set(_this._areaSize, 2);
        }
        return _this;
    }
    Light.IS = function (value) {
        return !!value.isLight;
    };
    Object.defineProperty(Light.prototype, "ubInfo", {
        get: function () {
            return this._ubInfo;
        },
        enumerable: false,
        configurable: true
    });
    Light.prototype.setColor = function (r, g, b) {
        this._color.set(new Float32Array([r, g, b]));
    };
    Light.prototype.requireLightMesh = function (material) {
        if (this._type !== ELightType.Area) {
            throw new Error('Light mesh only support area!');
        }
        if (!this._mesh) {
            this._mesh = new Mesh_1.default(this._areaMode === EAreaLightMode.Rect ? geometries_1.default.rectLight : geometries_1.default.discLight, material);
        }
        return this._mesh;
    };
    Light.prototype.updateMatrix = function () {
        _super.prototype.updateMatrix.call(this);
        gl_matrix_1.mat4.getTranslation(this._worldPos, this._worldMat);
        gl_matrix_1.vec3.transformMat4(this._worldDir, [0, 0, 1], this._worldMat);
        if (this._mesh) {
            this._mesh.scale.set(this._areaMode === EAreaLightMode.Disc
                ? [this._areaSize[0], this._areaSize[0], 0]
                : [this._areaSize[0], this._areaSize[1], 0]);
            this._mesh.updateWorldMatrix(this);
            this._mesh.material.setUniform('u_lightColor', this._color);
        }
        this._ubInfo.set(this._color, 4);
        this._ubInfo.set(this._worldMat, 8);
        this._ubInfo.set(gl_matrix_1.mat4.invert(new Float32Array(16), this._worldMat), 24);
    };
    Light.CLASS_NAME = 'Light';
    return Light;
}(Node_1.default));
exports["default"] = Light;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJMaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsdUNBQXVDO0FBQ3ZDLG9EQUErQztBQUUvQywrQkFBMEI7QUFDMUIsK0JBQTBCO0FBRTFCLElBQVksVUFNWDtBQU5ELFdBQVksVUFBVTtJQUNwQixpREFBVyxDQUFBO0lBQ1gsMkNBQUksQ0FBQTtJQUNKLHlEQUFXLENBQUE7SUFDWCw2Q0FBSyxDQUFBO0lBQ0wsMkNBQUksQ0FBQTtBQUNOLENBQUMsRUFOVyxVQUFVLEdBQVYsa0JBQVUsS0FBVixrQkFBVSxRQU1yQjtBQUVELElBQVksY0FHWDtBQUhELFdBQVksY0FBYztJQUN4QixtREFBSSxDQUFBO0lBQ0osbURBQUksQ0FBQTtBQUNOLENBQUMsRUFIVyxjQUFjLEdBQWQsc0JBQWMsS0FBZCxzQkFBYyxRQUd6QjtBQVNEO0lBQW1DLHlCQUFJO0lBcUJyQyxlQUNZLEtBQWlCLEVBQzNCLEtBQStCLEVBQy9CLFlBQTBEO1FBSDVELFlBS0UsaUJBQU8sU0FjUjtRQWxCVyxXQUFLLEdBQUwsS0FBSyxDQUFZO1FBZnRCLGFBQU8sR0FBWSxJQUFJLENBQUM7UUFLckIsZUFBUyxHQUFpQixJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QyxlQUFTLEdBQWlCLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBZXRELEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEMsS0FBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwQyxJQUFNLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JELE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7UUFFbkIsSUFBSSxLQUFLLEtB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Q0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFJLENBQUMsTUFBTSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBOUVhLGdCQUFVLEdBQVcsT0FBTyxDQUFDO0lBK0U3QyxZQUFDO0NBQUEsQUFoRkQsQ0FBbUMsY0FBSSxHQWdGdEM7a0JBaEZvQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWdodC50c1xuICogXG4gKiBAQXV0aG9yICA6ZHR5c2t5KGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBEYXRlICAgIDogNi8xMS8yMDIxLCA5OjU3OjUyIFBNXG4qL1xuaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgZ2VvbWV0cmllcyBmcm9tICcuLi9idWlsZGluL2dlb21ldHJpZXMnO1xuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4vTWF0ZXJpYWwnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi9NZXNoJztcbmltcG9ydCBOb2RlIGZyb20gJy4vTm9kZSc7XG5cbmV4cG9ydCBlbnVtIEVMaWdodFR5cGUge1xuICBJTlZBTElEID0gMCxcbiAgQXJlYSxcbiAgRGlyZWN0aW9uYWwsXG4gIFBvaW50LFxuICBTcG90XG59XG5cbmV4cG9ydCBlbnVtIEVBcmVhTGlnaHRNb2RlIHtcbiAgUmVjdCxcbiAgRGlzY1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEaXJlY3Rpb25hbExpZ2h0T3B0aW9ucyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIElBcmVhTGlnaHRPcHRpb25zIHtcbiAgbW9kZTogRUFyZWFMaWdodE1vZGU7XG4gIHNpemU6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0IGV4dGVuZHMgTm9kZSB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ0xpZ2h0JztcblxuICBwdWJsaWMgc3RhdGljIElTKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBMaWdodHtcbiAgICByZXR1cm4gISEodmFsdWUgYXMgTGlnaHQpLmlzTGlnaHQ7XG4gIH1cblxuICBwdWJsaWMgaXNMaWdodDogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9hcmVhTW9kZTogRUFyZWFMaWdodE1vZGU7XG4gIHByb3RlY3RlZCBfYXJlYVNpemU6IEZsb2F0MzJBcnJheTtcbiAgcHJvdGVjdGVkIF9jb2xvcjogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX3dvcmxkUG9zOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICBwcm90ZWN0ZWQgX3dvcmxkRGlyOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICBwcm90ZWN0ZWQgX3ViSW5mbzogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX21lc2g6IE1lc2g7XG5cbiAgZ2V0IHViSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdWJJbmZvO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF90eXBlOiBFTGlnaHRUeXBlLFxuICAgIGNvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgb3RoZXJPcHRpb25zOiBJQXJlYUxpZ2h0T3B0aW9ucyB8IElEaXJlY3Rpb25hbExpZ2h0T3B0aW9uc1xuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KGNvbG9yKTtcbiAgICB0aGlzLl91YkluZm8gPSBuZXcgRmxvYXQzMkFycmF5KDQwKTtcbiAgICBjb25zdCB1MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX3ViSW5mby5idWZmZXIpO1xuICAgIHUzMlZpZXdbMF0gPSBfdHlwZTtcbiAgICBcbiAgICBpZiAoX3R5cGUgPT09IEVMaWdodFR5cGUuQXJlYSkge1xuICAgICAgdGhpcy5fYXJlYU1vZGUgPSAob3RoZXJPcHRpb25zIGFzIElBcmVhTGlnaHRPcHRpb25zKS5tb2RlO1xuICAgICAgdGhpcy5fYXJlYVNpemUgPSBuZXcgRmxvYXQzMkFycmF5KChvdGhlck9wdGlvbnMgYXMgSUFyZWFMaWdodE9wdGlvbnMpLnNpemUpO1xuXG4gICAgICB1MzJWaWV3WzFdID0gdGhpcy5fYXJlYU1vZGU7XG4gICAgICB0aGlzLl91YkluZm8uc2V0KHRoaXMuX2FyZWFTaXplLCAyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0Q29sb3IocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgIHRoaXMuX2NvbG9yLnNldChuZXcgRmxvYXQzMkFycmF5KFtyLCBnLCBiXSkpO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVMaWdodE1lc2gobWF0ZXJpYWw6IE1hdGVyaWFsKSB7XG4gICAgaWYgKHRoaXMuX3R5cGUgIT09IEVMaWdodFR5cGUuQXJlYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWdodCBtZXNoIG9ubHkgc3VwcG9ydCBhcmVhIScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5fbWVzaCA9IG5ldyBNZXNoKFxuICAgICAgICB0aGlzLl9hcmVhTW9kZSA9PT0gRUFyZWFMaWdodE1vZGUuUmVjdCA/IGdlb21ldHJpZXMucmVjdExpZ2h0IDogZ2VvbWV0cmllcy5kaXNjTGlnaHQsXG4gICAgICAgIG1hdGVyaWFsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9tZXNoO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICBzdXBlci51cGRhdGVNYXRyaXgoKTtcbiAgICBcbiAgICBtYXQ0LmdldFRyYW5zbGF0aW9uKHRoaXMuX3dvcmxkUG9zLCB0aGlzLl93b3JsZE1hdCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHRoaXMuX3dvcmxkRGlyLCBbMCwgMCwgMV0sIHRoaXMuX3dvcmxkTWF0KTtcblxuICAgIGlmICh0aGlzLl9tZXNoKSB7XG4gICAgICB0aGlzLl9tZXNoLnNjYWxlLnNldCh0aGlzLl9hcmVhTW9kZSA9PT0gRUFyZWFMaWdodE1vZGUuRGlzY1xuICAgICAgICA/IFt0aGlzLl9hcmVhU2l6ZVswXSwgdGhpcy5fYXJlYVNpemVbMF0sIDBdXG4gICAgICAgIDogW3RoaXMuX2FyZWFTaXplWzBdLCB0aGlzLl9hcmVhU2l6ZVsxXSwgMF1cbiAgICAgICk7XG4gICAgICB0aGlzLl9tZXNoLnVwZGF0ZVdvcmxkTWF0cml4KHRoaXMpO1xuICAgICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5zZXRVbmlmb3JtKCd1X2xpZ2h0Q29sb3InLCB0aGlzLl9jb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5fdWJJbmZvLnNldCh0aGlzLl9jb2xvciwgNCk7XG4gICAgdGhpcy5fdWJJbmZvLnNldCh0aGlzLl93b3JsZE1hdCwgOCk7XG4gICAgdGhpcy5fdWJJbmZvLnNldChtYXQ0LmludmVydChuZXcgRmxvYXQzMkFycmF5KDE2KSwgdGhpcy5fd29ybGRNYXQpLCAyNCk7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./src/core/Material.ts":
/*!******************************!*\
  !*** ./src/core/Material.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var Material = (function (_super) {
    __extends(Material, _super);
    function Material(_effect, values, marcos, renderStates) {
        var _this = _super.call(this) || this;
        _this._effect = _effect;
        _this.isMaterial = true;
        _this._version = 0;
        _this._isBufferDirty = false;
        _this._isDirty = true;
        _this._uniformBlock = _effect.createDefaultUniformBlock();
        if (values) {
            Object.keys(values).forEach(function (name) { return _this.setUniform(name, values[name]); });
        }
        _this._marcos = marcos || {};
        _this._renderStates = renderStates || {};
        return _this;
    }
    Object.defineProperty(Material.prototype, "effect", {
        get: function () {
            return this._effect;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "marcos", {
        get: function () {
            return this._marcos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "bindingGroup", {
        get: function () {
            this._bindingGroup = this._effect.ubTemplate.getBindingGroup(this._uniformBlock, this._bindingGroup);
            return this._bindingGroup;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "primitiveType", {
        get: function () {
            return this._renderStates.primitiveType || this._effect.renderStates.primitiveType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "cullMode", {
        get: function () {
            return this._renderStates.cullMode || this._effect.renderStates.cullMode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthCompare", {
        get: function () {
            return this._renderStates.depthCompare || this._effect.renderStates.depthCompare;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendColor", {
        get: function () {
            return this._renderStates.blendColor || this._effect.renderStates.blendColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendAlpha", {
        get: function () {
            return this._renderStates.blendAlpha || this._effect.renderStates.blendAlpha;
        },
        enumerable: false,
        configurable: true
    });
    Material.prototype.setUniform = function (name, value, rtSubNameOrGPUBuffer) {
        this._effect.ubTemplate.setUniform(this._uniformBlock, name, value, rtSubNameOrGPUBuffer);
    };
    Material.prototype.getUniform = function (name) {
        return this._effect.ubTemplate.getUniform(this._uniformBlock, name);
    };
    Material.prototype.setMarcos = function (marcos) {
        Object.assign(this._marcos, marcos);
        this._version += 1;
    };
    Material.CLASS_NAME = 'Material';
    return Material;
}(HObject_1.default));
exports["default"] = Material;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWF0ZXJpYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJNYXRlcmlhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFNQSxxQ0FBZ0M7QUFJaEM7SUFBc0MsNEJBQU87SUFpRDNDLGtCQUNZLE9BQWUsRUFDekIsTUFBd0MsRUFDeEMsTUFBMEMsRUFDMUMsWUFBNEI7UUFKOUIsWUFNRSxpQkFBTyxTQVVSO1FBZlcsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQWhEcEIsZ0JBQVUsR0FBWSxJQUFJLENBQUM7UUFFeEIsY0FBUSxHQUFXLENBQUMsQ0FBQztRQUNyQixvQkFBYyxHQUFZLEtBQUssQ0FBQztRQUNoQyxjQUFRLEdBQVksSUFBSSxDQUFDO1FBbURqQyxLQUFJLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1FBRXpELElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxLQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBbkMsQ0FBbUMsQ0FBQyxDQUFDO1NBQzFFO1FBRUQsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQzVCLEtBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxJQUFJLEVBQUUsQ0FBQzs7SUFDMUMsQ0FBQztJQXJERCxzQkFBSSw0QkFBTTthQUFWO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksNEJBQU07YUFBVjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDZCQUFPO2FBQVg7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxrQ0FBWTthQUFoQjtZQUNFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3JHLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM1QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLG1DQUFhO2FBQWpCO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUM7UUFDckYsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSw4QkFBUTthQUFaO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7UUFDM0UsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxrQ0FBWTthQUFoQjtZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDO1FBQ25GLENBQUM7OztPQUFBO0lBRUQsc0JBQUksZ0NBQVU7YUFBZDtZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO1FBQy9FLENBQUM7OztPQUFBO0lBRUQsc0JBQUksZ0NBQVU7YUFBZDtZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO1FBQy9FLENBQUM7OztPQUFBO0lBb0JNLDZCQUFVLEdBQWpCLFVBQWtCLElBQVksRUFBRSxLQUFvQixFQUFFLG9CQUF5QztRQUM3RixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDNUYsQ0FBQztJQUVNLDZCQUFVLEdBQWpCLFVBQWtCLElBQVk7UUFDNUIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRU0sNEJBQVMsR0FBaEIsVUFBaUIsTUFBeUM7UUFDeEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUE3RWMsbUJBQVUsR0FBVyxVQUFVLENBQUM7SUE4RWpELGVBQUM7Q0FBQSxBQS9FRCxDQUFzQyxpQkFBTyxHQStFNUM7a0JBL0VvQixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogTWF0ZXJpYWwudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzbkuIvljYg3OjI2OjMzXG4gKi9cbmltcG9ydCBIT2JqZWN0IGZyb20gXCIuL0hPYmplY3RcIjtcbmltcG9ydCBFZmZlY3QsIHtJUmVuZGVyU3RhdGVzfSBmcm9tIFwiLi9FZmZlY3RcIjtcbmltcG9ydCBVQlRlbXBsYXRlLCB7SVVuaWZvcm1CbG9jaywgVFVuaWZvcm1WYWx1ZX0gZnJvbSBcIi4vVUJUZW1wbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRlcmlhbCBleHRlbmRzIEhPYmplY3Qge1xuICBwdWJsaWMgc3RhdGljICBDTEFTU19OQU1FOiBzdHJpbmcgPSAnTWF0ZXJpYWwnO1xuICBwdWJsaWMgaXNNYXRlcmlhbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF92ZXJzaW9uOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgX2lzQnVmZmVyRGlydHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIF9pc0RpcnR5OiBib29sZWFuID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIF91bmlmb3JtQmxvY2s6IElVbmlmb3JtQmxvY2s7XG4gIHByb3RlY3RlZCBfYmluZGluZ0dyb3VwOiBHUFVCaW5kR3JvdXA7XG4gIHByb3RlY3RlZCBfbWFyY29zOiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn07XG4gIHByb3RlY3RlZCBfcmVuZGVyU3RhdGVzOiBJUmVuZGVyU3RhdGVzO1xuXG4gIGdldCBlZmZlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VmZmVjdDtcbiAgfVxuXG4gIGdldCBtYXJjb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmNvcztcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICB9XG5cbiAgZ2V0IGJpbmRpbmdHcm91cCgpIHtcbiAgICB0aGlzLl9iaW5kaW5nR3JvdXAgPSB0aGlzLl9lZmZlY3QudWJUZW1wbGF0ZS5nZXRCaW5kaW5nR3JvdXAodGhpcy5fdW5pZm9ybUJsb2NrLCB0aGlzLl9iaW5kaW5nR3JvdXApO1xuICAgIHJldHVybiB0aGlzLl9iaW5kaW5nR3JvdXA7XG4gIH1cblxuICBnZXQgcHJpbWl0aXZlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyU3RhdGVzLnByaW1pdGl2ZVR5cGUgfHwgdGhpcy5fZWZmZWN0LnJlbmRlclN0YXRlcy5wcmltaXRpdmVUeXBlO1xuICB9XG5cbiAgZ2V0IGN1bGxNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJTdGF0ZXMuY3VsbE1vZGUgfHwgdGhpcy5fZWZmZWN0LnJlbmRlclN0YXRlcy5jdWxsTW9kZTtcbiAgfVxuXG4gIGdldCBkZXB0aENvbXBhcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlcy5kZXB0aENvbXBhcmUgfHwgdGhpcy5fZWZmZWN0LnJlbmRlclN0YXRlcy5kZXB0aENvbXBhcmU7XG4gIH1cblxuICBnZXQgYmxlbmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyU3RhdGVzLmJsZW5kQ29sb3IgfHwgdGhpcy5fZWZmZWN0LnJlbmRlclN0YXRlcy5ibGVuZENvbG9yO1xuICB9XG5cbiAgZ2V0IGJsZW5kQWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlcy5ibGVuZEFscGhhIHx8IHRoaXMuX2VmZmVjdC5yZW5kZXJTdGF0ZXMuYmxlbmRBbHBoYTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBfZWZmZWN0OiBFZmZlY3QsXG4gICAgdmFsdWVzPzoge1tuYW1lOiBzdHJpbmddOiBUVW5pZm9ybVZhbHVlfSxcbiAgICBtYXJjb3M/OiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgYm9vbGVhbn0sXG4gICAgcmVuZGVyU3RhdGVzPzogSVJlbmRlclN0YXRlc1xuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fdW5pZm9ybUJsb2NrID0gX2VmZmVjdC5jcmVhdGVEZWZhdWx0VW5pZm9ybUJsb2NrKCk7XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2gobmFtZSA9PiB0aGlzLnNldFVuaWZvcm0obmFtZSwgdmFsdWVzW25hbWVdKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFyY29zID0gbWFyY29zIHx8IHt9O1xuICAgIHRoaXMuX3JlbmRlclN0YXRlcyA9IHJlbmRlclN0YXRlcyB8fCB7fTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRVbmlmb3JtKG5hbWU6IHN0cmluZywgdmFsdWU6IFRVbmlmb3JtVmFsdWUsIHJ0U3ViTmFtZU9yR1BVQnVmZmVyPzogc3RyaW5nIHwgR1BVQnVmZmVyKSB7XG4gICAgdGhpcy5fZWZmZWN0LnViVGVtcGxhdGUuc2V0VW5pZm9ybSh0aGlzLl91bmlmb3JtQmxvY2ssIG5hbWUsIHZhbHVlLCBydFN1Yk5hbWVPckdQVUJ1ZmZlcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0VW5pZm9ybShuYW1lOiBzdHJpbmcpOiBUVW5pZm9ybVZhbHVlIHtcbiAgICByZXR1cm4gdGhpcy5fZWZmZWN0LnViVGVtcGxhdGUuZ2V0VW5pZm9ybSh0aGlzLl91bmlmb3JtQmxvY2ssIG5hbWUpO1xuICB9XG5cbiAgcHVibGljIHNldE1hcmNvcyhtYXJjb3M6IHtba2V5OiBzdHJpbmddOiBudW1iZXIgfCBib29sZWFufSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbWFyY29zLCBtYXJjb3MpO1xuICAgIHRoaXMuX3ZlcnNpb24gKz0gMTtcbiAgfVxufVxuIl19

/***/ }),

/***/ "./src/core/Mesh.ts":
/*!**************************!*\
  !*** ./src/core/Mesh.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Node_1 = __webpack_require__(/*! ./Node */ "./src/core/Node.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var Mesh = (function (_super) {
    __extends(Mesh, _super);
    function Mesh(_geometry, _material) {
        var _this = _super.call(this) || this;
        _this._geometry = _geometry;
        _this._material = _material;
        _this.isMesh = true;
        _this.sortZ = 0;
        _this._pipelines = {};
        _this._matVersion = -1;
        _this._ubTemplate = buildin_1.buildinUBTemplates.staticMesh;
        _this._uniformBlock = _this._ubTemplate.createUniformBlock();
        return _this;
    }
    Mesh.IS = function (value) {
        return !!value.isMesh;
    };
    Object.defineProperty(Mesh.prototype, "geometry", {
        get: function () {
            return this._geometry;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "material", {
        get: function () {
            return this._material;
        },
        set: function (value) {
            this._material = value;
            this._pipelines = {};
        },
        enumerable: false,
        configurable: true
    });
    Mesh.prototype.clone = function () {
        var mesh = new Mesh(this._geometry, this._material);
        mesh.pos.set(this.pos);
        mesh.quat.set(this.quat);
        mesh.scale.set(this.scale);
        return mesh;
    };
    Mesh.prototype.render = function (pass, rt) {
        var _a = this, _geometry = _a._geometry, _material = _a._material;
        if (_material.version !== this._matVersion || !this._pipelines[rt.pipelineHash]) {
            this._createPipeline(rt);
            this._matVersion = _material.version;
        }
        this.setUniform('u_world', this._worldMat);
        this._bindingGroup = this._ubTemplate.getBindingGroup(this._uniformBlock, this._bindingGroup);
        _geometry.vertexes.forEach(function (vertex, index) {
            pass.setVertexBuffer(index, vertex);
        });
        pass.setIndexBuffer(_geometry.indexes, _geometry.indexFormat);
        pass.setBindGroup(1, _material.bindingGroup);
        pass.setBindGroup(2, this._bindingGroup);
        pass.setPipeline(this._pipelines[rt.pipelineHash]);
        pass.drawIndexed(_geometry.count, 1, 0, 0, 0);
    };
    Mesh.prototype.setUniform = function (name, value, rtSubNameOrGPUBuffer) {
        this._ubTemplate.setUniform(this._uniformBlock, name, value, rtSubNameOrGPUBuffer);
    };
    Mesh.prototype.getUniform = function (name) {
        return this._ubTemplate.getUniform(this._uniformBlock, name);
    };
    Mesh.prototype._createPipeline = function (rt) {
        var device = renderEnv_1.default.device;
        var _a = this, _geometry = _a._geometry, _material = _a._material, _ubTemplate = _a._ubTemplate;
        this._bindingGroup = this._ubTemplate.getBindingGroup(this._uniformBlock, this._bindingGroup);
        var marcos = Object.assign({}, _geometry.marcos, _material.marcos);
        var _b = _material.effect.getShader(marcos, _geometry.attributesDef, renderEnv_1.default.shaderPrefix, _ubTemplate.shaderPrefix), vs = _b.vs, fs = _b.fs;
        this._pipelines[rt.pipelineHash] = device.createRenderPipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [
                    renderEnv_1.default.uniformLayout,
                    _material.effect.uniformLayout,
                    _ubTemplate.uniformLayout
                ] }),
            vertex: {
                module: vs,
                entryPoint: "main",
                buffers: _geometry.vertexLayouts
            },
            fragment: {
                module: fs,
                targets: rt.colorFormats.map(function (format) { return ({
                    format: format,
                    blend: _material.blendColor ? {
                        color: _material.blendColor,
                        alpha: _material.blendAlpha
                    } : undefined
                }); }),
                entryPoint: "main"
            },
            primitive: {
                topology: _material.primitiveType,
                cullMode: _material.cullMode
            },
            depthStencil: rt.depthStencilFormat && {
                format: rt.depthStencilFormat,
                depthWriteEnabled: true,
                depthCompare: _material.depthCompare
            }
        });
    };
    Mesh.CLASS_NAME = 'Mesh';
    return Mesh;
}(Node_1.default));
exports["default"] = Mesh;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIk1lc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsK0JBQTBCO0FBRzFCLHlDQUFvQztBQUlwQyxzQ0FBZ0Q7QUFJaEQ7SUFBa0Msd0JBQUk7SUE2QnBDLGNBQ1ksU0FBbUIsRUFDbkIsU0FBbUI7UUFGL0IsWUFJRSxpQkFBTyxTQUlSO1FBUFcsZUFBUyxHQUFULFNBQVMsQ0FBVTtRQUNuQixlQUFTLEdBQVQsU0FBUyxDQUFVO1FBeEJ4QixZQUFNLEdBQVksSUFBSSxDQUFDO1FBQ3ZCLFdBQUssR0FBVyxDQUFDLENBQUM7UUFFZixnQkFBVSxHQUF3QyxFQUFFLENBQUM7UUFDckQsaUJBQVcsR0FBVyxDQUFDLENBQUMsQ0FBQztRQXdCakMsS0FBSSxDQUFDLFdBQVcsR0FBRyw0QkFBa0IsQ0FBQyxVQUFVLENBQUM7UUFDakQsS0FBSSxDQUFDLGFBQWEsR0FBRyxLQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLENBQUM7O0lBQzdELENBQUM7SUFsQ2EsT0FBRSxHQUFoQixVQUFpQixLQUFVO1FBQ3pCLE9BQU8sQ0FBQyxDQUFFLEtBQWMsQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQVdELHNCQUFJLDBCQUFRO2FBQVo7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDeEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSwwQkFBUTthQUFaO1lBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ3hCLENBQUM7YUFFRCxVQUFhLEtBQWU7WUFDMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDdkIsQ0FBQzs7O09BTEE7SUFpQk0sb0JBQUssR0FBWjtRQUNFLElBQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFD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LE1BQU0sRUFBRSxFQUFFLENBQUMsa0JBQWtCO2dCQUM3QixpQkFBaUIsRUFBRSxJQUFJO2dCQUN2QixZQUFZLEVBQUUsU0FBUyxDQUFDLFlBQVk7YUFDckM7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDO0lBM0hjLGVBQVUsR0FBVyxNQUFNLENBQUM7SUE0SDdDLFdBQUM7Q0FBQSxBQTdIRCxDQUFrQyxjQUFJLEdBNkhyQztrQkE3SG9CLElBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBNZXNoLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2INzoyNTowNVxuICovXG5pbXBvcnQgTm9kZSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnknO1xuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4vTWF0ZXJpYWwnO1xuaW1wb3J0IHJlbmRlckVudiBmcm9tICcuL3JlbmRlckVudic7XG5pbXBvcnQgUmVuZGVyVGV4dHVyZSBmcm9tICcuL1JlbmRlclRleHR1cmUnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4vTGlnaHQnO1xuaW1wb3J0IFVCVGVtcGxhdGUsIHsgSVVuaWZvcm1CbG9jaywgVFVuaWZvcm1WYWx1ZSB9IGZyb20gJy4vVUJUZW1wbGF0ZSc7XG5pbXBvcnQgeyBidWlsZGluVUJUZW1wbGF0ZXMgfSBmcm9tICcuLi9idWlsZGluJztcblxuZGVjbGFyZSB0eXBlIENhbWVyYSA9IGltcG9ydCgnLi9DYW1lcmEnKS5kZWZhdWx0O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXNoIGV4dGVuZHMgTm9kZSB7XG4gIHB1YmxpYyBzdGF0aWMgIENMQVNTX05BTUU6IHN0cmluZyA9ICdNZXNoJztcblxuICBwdWJsaWMgc3RhdGljIElTKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBNZXNoe1xuICAgIHJldHVybiAhISh2YWx1ZSBhcyBNZXNoKS5pc01lc2g7XG4gIH1cblxuICBwdWJsaWMgaXNNZXNoOiBib29sZWFuID0gdHJ1ZTtcbiAgcHVibGljIHNvcnRaOiBudW1iZXIgPSAwO1xuXG4gIHByb3RlY3RlZCBfcGlwZWxpbmVzOiB7W2hhc2g6IG51bWJlcl06IEdQVVJlbmRlclBpcGVsaW5lfSA9IHt9O1xuICBwcm90ZWN0ZWQgX21hdFZlcnNpb246IG51bWJlciA9IC0xO1xuICBwcm90ZWN0ZWQgX3ViVGVtcGxhdGU6IFVCVGVtcGxhdGU7XG4gIHByb3RlY3RlZCBfdW5pZm9ybUJsb2NrOiBJVW5pZm9ybUJsb2NrO1xuICBwcm90ZWN0ZWQgX2JpbmRpbmdHcm91cDogR1BVQmluZEdyb3VwO1xuXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cblxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsO1xuICB9XG5cbiAgc2V0IG1hdGVyaWFsKHZhbHVlOiBNYXRlcmlhbCkge1xuICAgIHRoaXMuX21hdGVyaWFsID0gdmFsdWU7XG4gICAgdGhpcy5fcGlwZWxpbmVzID0ge307XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX2dlb21ldHJ5OiBHZW9tZXRyeSxcbiAgICBwcm90ZWN0ZWQgX21hdGVyaWFsOiBNYXRlcmlhbFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fdWJUZW1wbGF0ZSA9IGJ1aWxkaW5VQlRlbXBsYXRlcy5zdGF0aWNNZXNoO1xuICAgIHRoaXMuX3VuaWZvcm1CbG9jayA9IHRoaXMuX3ViVGVtcGxhdGUuY3JlYXRlVW5pZm9ybUJsb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogTWVzaCB7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgbWVzaC5wb3Muc2V0KHRoaXMucG9zKTtcbiAgICBtZXNoLnF1YXQuc2V0KHRoaXMucXVhdCk7XG4gICAgbWVzaC5zY2FsZS5zZXQodGhpcy5zY2FsZSk7XG5cbiAgICByZXR1cm4gbWVzaDtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoXG4gICAgcGFzczogR1BVUmVuZGVyUGFzc0VuY29kZXIsXG4gICAgcnQ6IFJlbmRlclRleHR1cmVcbiAgKSB7XG4gICAgY29uc3Qge19nZW9tZXRyeSwgX21hdGVyaWFsfSA9IHRoaXM7XG5cbiAgICBpZiAoX21hdGVyaWFsLnZlcnNpb24gIT09IHRoaXMuX21hdFZlcnNpb24gfHwgIXRoaXMuX3BpcGVsaW5lc1tydC5waXBlbGluZUhhc2hdKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQaXBlbGluZShydCk7XG4gICAgICB0aGlzLl9tYXRWZXJzaW9uID0gX21hdGVyaWFsLnZlcnNpb247XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3JtKCd1X3dvcmxkJywgdGhpcy5fd29ybGRNYXQpO1xuICAgIHRoaXMuX2JpbmRpbmdHcm91cCA9IHRoaXMuX3ViVGVtcGxhdGUuZ2V0QmluZGluZ0dyb3VwKHRoaXMuX3VuaWZvcm1CbG9jaywgdGhpcy5fYmluZGluZ0dyb3VwKTtcblxuICAgIF9nZW9tZXRyeS52ZXJ0ZXhlcy5mb3JFYWNoKCh2ZXJ0ZXgsIGluZGV4KSA9PiB7XG4gICAgICBwYXNzLnNldFZlcnRleEJ1ZmZlcihpbmRleCwgdmVydGV4KTtcbiAgICB9KTtcbiAgICBwYXNzLnNldEluZGV4QnVmZmVyKF9nZW9tZXRyeS5pbmRleGVzLCBfZ2VvbWV0cnkuaW5kZXhGb3JtYXQpO1xuICAgIHBhc3Muc2V0QmluZEdyb3VwKDEsIF9tYXRlcmlhbC5iaW5kaW5nR3JvdXApO1xuICAgIHBhc3Muc2V0QmluZEdyb3VwKDIsIHRoaXMuX2JpbmRpbmdHcm91cCk7XG4gICAgcGFzcy5zZXRQaXBlbGluZSh0aGlzLl9waXBlbGluZXNbcnQucGlwZWxpbmVIYXNoXSk7XG4gICAgcGFzcy5kcmF3SW5kZXhlZChfZ2VvbWV0cnkuY291bnQsIDEsIDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIHNldFVuaWZvcm0obmFtZTogc3RyaW5nLCB2YWx1ZTogVFVuaWZvcm1WYWx1ZSwgcnRTdWJOYW1lT3JHUFVCdWZmZXI/OiBzdHJpbmcgfCBHUFVCdWZmZXIpIHtcbiAgICB0aGlzLl91YlRlbXBsYXRlLnNldFVuaWZvcm0odGhpcy5fdW5pZm9ybUJsb2NrLCBuYW1lLCB2YWx1ZSwgcnRTdWJOYW1lT3JHUFVCdWZmZXIpO1xuICB9XG5cbiAgcHVibGljIGdldFVuaWZvcm0obmFtZTogc3RyaW5nKTogVFVuaWZvcm1WYWx1ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3ViVGVtcGxhdGUuZ2V0VW5pZm9ybSh0aGlzLl91bmlmb3JtQmxvY2ssIG5hbWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVQaXBlbGluZShydDogUmVuZGVyVGV4dHVyZSkge1xuICAgIGNvbnN0IHtkZXZpY2V9ID0gcmVuZGVyRW52O1xuICAgIGNvbnN0IHtfZ2VvbWV0cnksIF9tYXRlcmlhbCwgX3ViVGVtcGxhdGV9ID0gdGhpcztcbiAgICBcbiAgICB0aGlzLl9iaW5kaW5nR3JvdXAgPSB0aGlzLl91YlRlbXBsYXRlLmdldEJpbmRpbmdHcm91cCh0aGlzLl91bmlmb3JtQmxvY2ssIHRoaXMuX2JpbmRpbmdHcm91cCk7XG4gICAgY29uc3QgbWFyY29zID0gT2JqZWN0LmFzc2lnbih7fSwgX2dlb21ldHJ5Lm1hcmNvcywgX21hdGVyaWFsLm1hcmNvcyk7XG4gICAgY29uc3Qge3ZzLCBmc30gPSBfbWF0ZXJpYWwuZWZmZWN0LmdldFNoYWRlcihtYXJjb3MsIF9nZW9tZXRyeS5hdHRyaWJ1dGVzRGVmLCByZW5kZXJFbnYuc2hhZGVyUHJlZml4LCBfdWJUZW1wbGF0ZS5zaGFkZXJQcmVmaXgpO1xuXG4gICAgdGhpcy5fcGlwZWxpbmVzW3J0LnBpcGVsaW5lSGFzaF0gPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgbGF5b3V0OiBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe2JpbmRHcm91cExheW91dHM6IFtcbiAgICAgICAgcmVuZGVyRW52LnVuaWZvcm1MYXlvdXQsXG4gICAgICAgIF9tYXRlcmlhbC5lZmZlY3QudW5pZm9ybUxheW91dCxcbiAgICAgICAgX3ViVGVtcGxhdGUudW5pZm9ybUxheW91dFxuICAgICAgXX0pLFxuICBcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBtb2R1bGU6IHZzLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5cIixcbiAgICAgICAgYnVmZmVyczogX2dlb21ldHJ5LnZlcnRleExheW91dHNcbiAgICAgIH0sXG4gIFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgbW9kdWxlOiBmcyxcbiAgICAgICAgdGFyZ2V0czogcnQuY29sb3JGb3JtYXRzLm1hcChmb3JtYXQgPT4gKHtcbiAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgYmxlbmQ6IF9tYXRlcmlhbC5ibGVuZENvbG9yID8ge1xuICAgICAgICAgICAgY29sb3I6IF9tYXRlcmlhbC5ibGVuZENvbG9yLFxuICAgICAgICAgICAgYWxwaGE6IF9tYXRlcmlhbC5ibGVuZEFscGhhXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9KSksXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblwiXG4gICAgICB9LFxuICBcbiAgICAgIHByaW1pdGl2ZToge1xuICAgICAgICB0b3BvbG9neTogX21hdGVyaWFsLnByaW1pdGl2ZVR5cGUsXG4gICAgICAgIGN1bGxNb2RlOiBfbWF0ZXJpYWwuY3VsbE1vZGVcbiAgICAgIH0sXG5cbiAgICAgIGRlcHRoU3RlbmNpbDogcnQuZGVwdGhTdGVuY2lsRm9ybWF0ICYmIHtcbiAgICAgICAgZm9ybWF0OiBydC5kZXB0aFN0ZW5jaWxGb3JtYXQsXG4gICAgICAgIGRlcHRoV3JpdGVFbmFibGVkOiB0cnVlLFxuICAgICAgICBkZXB0aENvbXBhcmU6IF9tYXRlcmlhbC5kZXB0aENvbXBhcmVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIl19

/***/ }),

/***/ "./src/core/Node.ts":
/*!**************************!*\
  !*** ./src/core/Node.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var VEC3_ONES = new Float32Array([1, 1, 1]);
var Node = (function (_super) {
    __extends(Node, _super);
    function Node() {
        var _this = _super.call(this) || this;
        _this.isNode = true;
        _this.active = true;
        _this._children = [];
        _this._mem = new ArrayBuffer((3 + 3 + 4 + 16) * 4 * 4);
        _this._pos = new Float32Array(_this._mem, 0, 3);
        (_this._scale = new Float32Array(_this._mem, 3 * 4, 3)).set(VEC3_ONES);
        _this._quat = gl_matrix_1.quat.identity(new Float32Array(_this._mem, 6 * 4, 4));
        _this._worldMat = gl_matrix_1.mat4.identity(new Float32Array(_this._mem, 10 * 4, 16));
        return _this;
    }
    Object.defineProperty(Node.prototype, "pos", {
        get: function () {
            return this._pos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "scale", {
        get: function () {
            return this._scale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "quat", {
        get: function () {
            return this._quat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "worldMat", {
        get: function () {
            return this._worldMat;
        },
        enumerable: false,
        configurable: true
    });
    Node.prototype.addChild = function (node) {
        this._children.push(node);
        node._parent = this;
    };
    Node.prototype.removeChild = function (node) {
        var idx = this._children.indexOf(node);
        if (idx >= 0) {
            this._children.splice(idx, 1);
            node._parent = null;
        }
    };
    Node.prototype.setLocalMat = function (value) {
        this._updateTRSFromMat(value);
    };
    Node.prototype.updateMatrix = function () {
        this.updateWorldMatrix();
    };
    Node.prototype.updateWorldMatrix = function (parent) {
        gl_matrix_1.mat4.fromRotationTranslationScale(this._worldMat, this._quat, this._pos, this._scale);
        parent = parent || this._parent;
        if (parent) {
            gl_matrix_1.mat4.mul(this._worldMat, parent.worldMat, this._worldMat);
        }
    };
    Node.prototype.dfs = function (callback, defaultParams) {
        var params = callback(this, defaultParams);
        var children = this._children;
        for (var index = 0; index < children.length; index += 1) {
            var node = children[index];
            node.active && node.dfs(callback, params);
        }
    };
    Node.prototype.updateSubTree = function (callback) {
        if (!this.active) {
            return;
        }
        this.dfs(function (node) {
            node.updateMatrix();
            callback && callback(node);
        });
    };
    Node.prototype._updateTRSFromMat = function (mat) {
        gl_matrix_1.mat4.getTranslation(this._pos, mat);
        gl_matrix_1.mat4.getRotation(this._quat, mat);
        gl_matrix_1.mat4.getScaling(this._scale, mat);
    };
    Node.CLASS_NAME = 'Node';
    return Node;
}(HObject_1.default));
exports["default"] = Node;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIk5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBTUEscUNBQWdDO0FBQ2hDLHVDQUEyQztBQUUzQyxJQUFNLFNBQVMsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU5QztJQUFrQyx3QkFBTztJQThCdkM7UUFBQSxZQUNFLGlCQUFPLFNBT1I7UUFwQ00sWUFBTSxHQUFZLElBQUksQ0FBQztRQUV2QixZQUFNLEdBQVksSUFBSSxDQUFDO1FBUXBCLGVBQVMsR0FBVyxFQUFFLENBQUM7UUFxQi9CLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEQsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxLQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM5QyxDQUFDLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3JFLEtBQUksQ0FBQyxLQUFLLEdBQUcsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFpQixDQUFDO1FBQ2xGLEtBQUksQ0FBQyxTQUFTLEdBQUcsZ0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFpQixDQUFDOztJQUMxRixDQUFDO0lBeEJELHNCQUFJLHFCQUFHO2FBQVA7WUFDRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSx1QkFBSzthQUFUO1lBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3JCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksc0JBQUk7YUFBUjtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNwQixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDBCQUFRO2FBQVo7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDeEIsQ0FBQzs7O09BQUE7SUFZTSx1QkFBUSxHQUFmLFVBQWdCLElBQVU7UUFDeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFDdEIsQ0FBQztJQUVNLDBCQUFXLEdBQWxCLFVBQW1CLElBQVU7UUFDM0IsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFekMsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFO1lBQ1osSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztJQUVNLDBCQUFXLEdBQWxCLFVBQW1CLEtBQW1CO1FBQ3BDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU0sMkJBQVksR0FBbkI7UUFDRSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRU0sZ0NBQWlCLEdBQXhCLFVBQXlCLE1BQWE7UUFDcEMsZ0JBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEYsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRWhDLElBQUksTUFBTSxFQUFFO1lBQ1YsZ0JBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzRDtJQUNILENBQUM7SUFFTSxrQkFBRyxHQUFWLFVBQTBCLFFBQXVDLEVBQUUsYUFBaUI7UUFDbEYsSUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQztRQUM3QyxJQUFNLFFBQVEsR0FBVyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBRXhDLEtBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDdkQsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDM0M7SUFDSCxDQUFDO0lBRU0sNEJBQWEsR0FBcEIsVUFBcUIsUUFBK0I7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDaEIsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBTyxVQUFDLElBQVU7WUFDeEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBRXBCLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sZ0NBQWlCLEdBQXpCLFVBQTBCLEdBQWlCO1FBQ3pDLGdCQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDcEMsZ0JBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNsQyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFoR2EsZUFBVSxHQUFXLE1BQU0sQ0FBQztJQWlHNUMsV0FBQztDQUFBLEFBbEdELENBQWtDLGlCQUFPLEdBa0d4QztrQkFsR29CLElBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBOb2RlLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2INzoyNDoyNlxuICovXG5pbXBvcnQgSE9iamVjdCBmcm9tICcuL0hPYmplY3QnO1xuaW1wb3J0IHttYXQ0LCBxdWF0LCB2ZWMzfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBWRUMzX09ORVMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vZGUgZXh0ZW5kcyBIT2JqZWN0IHtcbiAgcHVibGljIHN0YXRpYyBDTEFTU19OQU1FOiBzdHJpbmcgPSAnTm9kZSc7XG4gIHB1YmxpYyBpc05vZGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByb3RlY3RlZCBfbWVtOiBBcnJheUJ1ZmZlcjtcbiAgcHJvdGVjdGVkIF9wb3M6IEZsb2F0MzJBcnJheTtcbiAgcHJvdGVjdGVkIF9zY2FsZTogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX3F1YXQ6IEZsb2F0MzJBcnJheTtcbiAgcHJvdGVjdGVkIF93b3JsZE1hdDogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX3BhcmVudDogTm9kZTtcbiAgcHJvdGVjdGVkIF9jaGlsZHJlbjogTm9kZVtdID0gW107XG5cbiAgZ2V0IHBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zO1xuICB9XG5cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgfVxuXG4gIGdldCBxdWF0KCkge1xuICAgIHJldHVybiB0aGlzLl9xdWF0O1xuICB9XG5cbiAgZ2V0IHdvcmxkTWF0KCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZE1hdDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9tZW0gPSBuZXcgQXJyYXlCdWZmZXIoKDMgKyAzICsgNCArIDE2KSAqIDQgKiA0KTtcbiAgICB0aGlzLl9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21lbSwgMCwgMyk7XG4gICAgKHRoaXMuX3NjYWxlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9tZW0sIDMgKiA0LCAzKSkuc2V0KFZFQzNfT05FUyk7XG4gICAgdGhpcy5fcXVhdCA9IHF1YXQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9tZW0sIDYgKiA0LCA0KSkgYXMgRmxvYXQzMkFycmF5O1xuICAgIHRoaXMuX3dvcmxkTWF0ID0gbWF0NC5pZGVudGl0eShuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21lbSwgMTAgKiA0LCAxNikpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChub2RlOiBOb2RlKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICBub2RlLl9wYXJlbnQgPSB0aGlzO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKG5vZGU6IE5vZGUpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIG5vZGUuX3BhcmVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldExvY2FsTWF0KHZhbHVlOiBGbG9hdDMyQXJyYXkpIHtcbiAgICB0aGlzLl91cGRhdGVUUlNGcm9tTWF0KHZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVNYXRyaXgoKSB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KHBhcmVudD86IE5vZGUpIHtcbiAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUodGhpcy5fd29ybGRNYXQsIHRoaXMuX3F1YXQsIHRoaXMuX3BvcywgdGhpcy5fc2NhbGUpO1xuICAgIHBhcmVudCA9IHBhcmVudCB8fCB0aGlzLl9wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBtYXQ0Lm11bCh0aGlzLl93b3JsZE1hdCwgcGFyZW50LndvcmxkTWF0LCB0aGlzLl93b3JsZE1hdCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRmczxUIGV4dGVuZHMgYW55PihjYWxsYmFjazogKG5vZGU6IE5vZGUsIHBhcmFtcz86IFQpID0+IFQsIGRlZmF1bHRQYXJhbXM/OiBUKSB7XG4gICAgY29uc3QgcGFyYW1zID0gY2FsbGJhY2sodGhpcywgZGVmYXVsdFBhcmFtcyk7XG4gICAgY29uc3QgY2hpbGRyZW46IE5vZGVbXSA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgIG5vZGUuYWN0aXZlICYmIG5vZGUuZGZzKGNhbGxiYWNrLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVTdWJUcmVlKGNhbGxiYWNrPzogKG5vZGU6IE5vZGUpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZnM8dm9pZD4oKG5vZGU6IE5vZGUpID0+IHtcbiAgICAgIG5vZGUudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlVFJTRnJvbU1hdChtYXQ6IEZsb2F0MzJBcnJheSkge1xuICAgIG1hdDQuZ2V0VHJhbnNsYXRpb24odGhpcy5fcG9zLCBtYXQpO1xuICAgIG1hdDQuZ2V0Um90YXRpb24odGhpcy5fcXVhdCwgbWF0KTtcbiAgICBtYXQ0LmdldFNjYWxpbmcodGhpcy5fc2NhbGUsIG1hdCk7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./src/core/RenderTexture.ts":
/*!***********************************!*\
  !*** ./src/core/RenderTexture.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var shared_1 = __webpack_require__(/*! ./shared */ "./src/core/shared.ts");
var RenderTexture = (function (_super) {
    __extends(RenderTexture, _super);
    function RenderTexture(_options) {
        var _this = _super.call(this) || this;
        _this._options = _options;
        _this.isRenderTexture = true;
        var width = _options.width, height = _options.height, colors = _options.colors, depthStencil = _options.depthStencil, forCompute = _options.forCompute;
        _this._width = width;
        _this._height = height;
        if (forCompute && depthStencil) {
            throw new Error('RenderTexture with forCompute flag does not support depth!');
        }
        _this._colorDescs = new Array(colors.length);
        _this._colorViews = new Array(colors.length);
        _this._colorFormats = new Array(colors.length);
        _this._colorNames = {};
        _this._colors = colors.map(function (info, index) {
            var color = renderEnv_1.default.device.createTexture(_this._colorDescs[index] = {
                label: _this.hash + '_color_' + (info.name || index),
                size: { width: width, height: height },
                format: info.format || (forCompute ? 'rgba8unorm' : renderEnv_1.default.swapChainFormat),
                usage: (GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING) | (forCompute ? GPUTextureUsage.STORAGE_BINDING : 0)
            });
            _this._colorViews[index] = color.createView({ label: color.label });
            _this._colorFormats[index] = _this._colorDescs[index].format;
            if (info.name) {
                _this._colorNames[info.name] = index;
            }
            return color;
        });
        if (depthStencil) {
            _this._depthStencil = renderEnv_1.default.device.createTexture(_this._depthDesc = {
                label: _this.hash + '_depth',
                size: { width: width, height: height },
                format: depthStencil.format || (!depthStencil.needStencil ? 'depth24plus' : 'depth24plus-stencil8'),
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
            });
            _this._depthStencilView = _this._depthStencil.createView({ label: _this.hash + '_depth' });
        }
        _this._pipelineHash = shared_1.hashCode(_this._colorDescs.map(function (c) { return c.format; }).join('') + (_this._depthDesc ? _this._depthDesc.format : ''));
        return _this;
    }
    RenderTexture.IS = function (value) {
        return !!value.isRenderTexture;
    };
    Object.defineProperty(RenderTexture.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "pipelineHash", {
        get: function () {
            return this._pipelineHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "colorView", {
        get: function () {
            return this._colorViews[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "depthStencilView", {
        get: function () {
            return this._depthStencilView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "colorFormat", {
        get: function () {
            return this._colorDescs[0].format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "depthStencilFormat", {
        get: function () {
            var _a;
            return (_a = this._depthDesc) === null || _a === void 0 ? void 0 : _a.format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "colorViews", {
        get: function () {
            return this._colorViews;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTexture.prototype, "colorFormats", {
        get: function () {
            return this._colorFormats;
        },
        enumerable: false,
        configurable: true
    });
    RenderTexture.prototype.getColorViewByName = function (name) {
        return this._colorViews[this._colorNames[name]];
    };
    RenderTexture.CLASS_NAME = 'RenderTexture';
    return RenderTexture;
}(HObject_1.default));
exports["default"] = RenderTexture;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVuZGVyVGV4dHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlJlbmRlclRleHR1cmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBT0EscUNBQWdDO0FBQ2hDLHlDQUFvQztBQUNwQyxtQ0FBa0M7QUFnQmxDO0lBQTJDLGlDQUFPO0lBeURoRCx1QkFBc0IsUUFBK0I7UUFBckQsWUFDRSxpQkFBTyxTQWtEUjtRQW5EcUIsY0FBUSxHQUFSLFFBQVEsQ0FBdUI7UUFuRDlDLHFCQUFlLEdBQVksSUFBSSxDQUFDO1FBc0Q5QixJQUFBLEtBQUssR0FBOEMsUUFBUSxNQUF0RCxFQUFFLE1BQU0sR0FBc0MsUUFBUSxPQUE5QyxFQUFFLE1BQU0sR0FBOEIsUUFBUSxPQUF0QyxFQUFFLFlBQVksR0FBZ0IsUUFBUSxhQUF4QixFQUFFLFVBQVUsR0FBSSxRQUFRLFdBQVosQ0FBYTtRQUVuRSxLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUV0QixJQUFJLFVBQVUsSUFBSSxZQUFZLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO1NBQy9FO1FBRUQsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsS0FBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsS0FBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFFdEIsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUs7WUFDcEMsSUFBTSxLQUFLLEdBQUcsbUJB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QUM1QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLG9DQUFTO2FBQWI7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSwyQ0FBZ0I7YUFBcEI7WUFDRSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztRQUNoQyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHNDQUFXO2FBQWY7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3BDLENBQUM7OztPQUFBO0lBRUQsc0JBQUksNkNBQWtCO2FBQXRCOztZQUNFLGFBQU8sSUFBSSxDQUFDLFVBQVUsMENBQUUsTUFBTSxDQUFDO1FBQ2pDLENBQUM7OztPQUFBO0lBRUQsc0JBQUkscUNBQVU7YUFBZDtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHVDQUFZO2FBQWhCO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBdURNLDBDQUFrQixHQUF6QixVQUEwQixJQUFZO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQTNHYSx3QkFBVSxHQUFXLGVBQWUsQ0FBQztJQTRHckQsb0JBQUM7Q0FBQSxBQWpIRCxDQUEyQyxpQkFBTyxHQWlIakQ7a0JBakhvQixhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBGaWxlICAgOiBSZW5kZXJUZXh0dXJlLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2IMTE6MTQ6MjJcbiAqL1xuaW1wb3J0IEhPYmplY3QgZnJvbSAnLi9IT2JqZWN0JztcbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9yZW5kZXJFbnYnO1xuaW1wb3J0IHtoYXNoQ29kZX0gZnJvbSAnLi9zaGFyZWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElSZW5kZXJUZXh0dXJlT3B0aW9ucyB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBmb3JDb21wdXRlPzogYm9vbGVhbjtcbiAgY29sb3JzOiB7XG4gICAgbmFtZT86IHN0cmluZyxcbiAgICBmb3JtYXQ/OiBHUFVUZXh0dXJlRm9ybWF0XG4gIH1bXTtcbiAgZGVwdGhTdGVuY2lsPzoge1xuICAgIGZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQ7XG4gICAgbmVlZFN0ZW5jaWw/OiBib29sZWFuO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgSVModmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlbmRlclRleHR1cmUge1xuICAgIHJldHVybiAhIXZhbHVlLmlzUmVuZGVyVGV4dHVyZTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ1JlbmRlclRleHR1cmUnO1xuICBwdWJsaWMgaXNSZW5kZXJUZXh0dXJlOiBib29sZWFuID0gdHJ1ZTtcblxuICBwcm90ZWN0ZWQgX3dpZHRoOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfaGVpZ2h0OiBudW1iZXI7XG4gIHByb3RlY3RlZCBfZm9yQ29tcHV0ZTogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIF9jb2xvckRlc2NzOiBHUFVUZXh0dXJlRGVzY3JpcHRvcltdO1xuICBwcm90ZWN0ZWQgX2RlcHRoRGVzYzogR1BVVGV4dHVyZURlc2NyaXB0b3I7XG4gIHByb3RlY3RlZCBfY29sb3JzOiBHUFVUZXh0dXJlW107XG4gIHByb3RlY3RlZCBfY29sb3JWaWV3czogR1BVVGV4dHVyZVZpZXdbXTtcbiAgcHJvdGVjdGVkIF9jb2xvckZvcm1hdHM6IEdQVVRleHR1cmVGb3JtYXRbXTtcbiAgcHJvdGVjdGVkIF9kZXB0aFN0ZW5jaWw6IEdQVVRleHR1cmU7XG4gIHByb3RlY3RlZCBfZGVwdGhTdGVuY2lsVmlldzogR1BVVGV4dHVyZVZpZXc7XG4gIHByb3RlY3RlZCBfcGlwZWxpbmVIYXNoOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfY29sb3JOYW1lczoge1tuYW1lOiBzdHJpbmddOiBudW1iZXJ9O1xuXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICBnZXQgcGlwZWxpbmVIYXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9waXBlbGluZUhhc2g7XG4gIH1cblxuICBnZXQgY29sb3JWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvclZpZXdzWzBdO1xuICB9XG5cbiAgZ2V0IGRlcHRoU3RlbmNpbFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoU3RlbmNpbFZpZXc7XG4gIH1cblxuICBnZXQgY29sb3JGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yRGVzY3NbMF0uZm9ybWF0O1xuICB9XG5cbiAgZ2V0IGRlcHRoU3RlbmNpbEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhEZXNjPy5mb3JtYXQ7XG4gIH1cblxuICBnZXQgY29sb3JWaWV3cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JWaWV3cztcbiAgfVxuXG4gIGdldCBjb2xvckZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yRm9ybWF0cztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfb3B0aW9uczogSVJlbmRlclRleHR1cmVPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBjb2xvcnMsIGRlcHRoU3RlbmNpbCwgZm9yQ29tcHV0ZX0gPSBfb3B0aW9ucztcblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKGZvckNvbXB1dGUgJiYgZGVwdGhTdGVuY2lsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlclRleHR1cmUgd2l0aCBmb3JDb21wdXRlIGZsYWcgZG9lcyBub3Qgc3VwcG9ydCBkZXB0aCEnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xvckRlc2NzID0gbmV3IEFycmF5KGNvbG9ycy5sZW5ndGgpO1xuICAgIHRoaXMuX2NvbG9yVmlld3MgPSBuZXcgQXJyYXkoY29sb3JzLmxlbmd0aCk7XG4gICAgdGhpcy5fY29sb3JGb3JtYXRzID0gbmV3IEFycmF5KGNvbG9ycy5sZW5ndGgpO1xuICAgIHRoaXMuX2NvbG9yTmFtZXMgPSB7fTtcblxuICAgIHRoaXMuX2NvbG9ycyA9IGNvbG9ycy5tYXAoKGluZm8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IHJlbmRlckVudi5kZXZpY2UuY3JlYXRlVGV4dHVyZSh0aGlzLl9jb2xvckRlc2NzW2luZGV4XSA9IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuaGFzaCArICdfY29sb3JfJyArIChpbmZvLm5hbWUgfHwgaW5kZXgpLFxuICAgICAgICBzaXplOiB7d2lkdGgsIGhlaWdodH0sXG4gICAgICAgIGZvcm1hdDogaW5mby5mb3JtYXQgfHwgKGZvckNvbXB1dGUgPyAncmdiYTh1bm9ybScgOiByZW5kZXJFbnYuc3dhcENoYWluRm9ybWF0KSxcbiAgICAgICAgdXNhZ2U6IChcbiAgICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HXG4gICAgICAgICkgfCAoXG4gICAgICAgICAgZm9yQ29tcHV0ZSA/IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcgOiAwXG4gICAgICAgIClcbiAgICAgIH0gYXMgR1BVVGV4dHVyZURlc2NyaXB0b3IpO1xuXG4gICAgICB0aGlzLl9jb2xvclZpZXdzW2luZGV4XSA9IGNvbG9yLmNyZWF0ZVZpZXcoe2xhYmVsOiBjb2xvci5sYWJlbH0pO1xuICAgICAgdGhpcy5fY29sb3JGb3JtYXRzW2luZGV4XSA9IHRoaXMuX2NvbG9yRGVzY3NbaW5kZXhdLmZvcm1hdDtcblxuICAgICAgaWYgKGluZm8ubmFtZSkge1xuICAgICAgICB0aGlzLl9jb2xvck5hbWVzW2luZm8ubmFtZV0gPSBpbmRleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0pXG5cbiAgICBpZiAoZGVwdGhTdGVuY2lsKSB7XG4gICAgICB0aGlzLl9kZXB0aFN0ZW5jaWwgPSByZW5kZXJFbnYuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGhpcy5fZGVwdGhEZXNjID0ge1xuICAgICAgICBsYWJlbDogdGhpcy5oYXNoICsgJ19kZXB0aCcsXG4gICAgICAgIHNpemU6IHt3aWR0aCwgaGVpZ2h0fSxcbiAgICAgICAgZm9ybWF0OiBkZXB0aFN0ZW5jaWwuZm9ybWF0IHx8ICghZGVwdGhTdGVuY2lsLm5lZWRTdGVuY2lsID8gJ2RlcHRoMjRwbHVzJyA6ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCcpLFxuICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICAgICAgXG4gICAgICB9IGFzIEdQVVRleHR1cmVEZXNjcmlwdG9yKTtcbiAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFZpZXcgPSB0aGlzLl9kZXB0aFN0ZW5jaWwuY3JlYXRlVmlldyh7bGFiZWw6IHRoaXMuaGFzaCArICdfZGVwdGgnfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGlwZWxpbmVIYXNoID0gaGFzaENvZGUodGhpcy5fY29sb3JEZXNjcy5tYXAoYyA9PiBjLmZvcm1hdCkuam9pbignJykgKyAodGhpcy5fZGVwdGhEZXNjID8gdGhpcy5fZGVwdGhEZXNjLmZvcm1hdCA6ICcnKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sb3JWaWV3QnlOYW1lKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jb2xvclZpZXdzW3RoaXMuX2NvbG9yTmFtZXNbbmFtZV1dO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/core/Scene.ts":
/*!***************************!*\
  !*** ./src/core/Scene.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var ImageMesh_1 = __webpack_require__(/*! ./ImageMesh */ "./src/core/ImageMesh.ts");
var Light_1 = __webpack_require__(/*! ./Light */ "./src/core/Light.ts");
var Material_1 = __webpack_require__(/*! ./Material */ "./src/core/Material.ts");
var Mesh_1 = __webpack_require__(/*! ./Mesh */ "./src/core/Mesh.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./src/core/RenderTexture.ts");
var Scene = (function (_super) {
    __extends(Scene, _super);
    function Scene() {
        var _this = _super.call(this) || this;
        _this.isScene = true;
        _this._renderTarget = _this._screen = new RenderTexture_1.default({ width: renderEnv_1.default.width, height: renderEnv_1.default.height, colors: [{}], depthStencil: { needStencil: true } });
        _this._blit = new ImageMesh_1.default(new Material_1.default(buildin_1.buildinEffects.iBlit, { u_texture: _this._screen }));
        return _this;
    }
    Object.defineProperty(Scene.prototype, "rootNode", {
        get: function () {
            return this._rootNode;
        },
        set: function (node) {
            this._rootNode = node;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "screen", {
        get: function () {
            return this._screen;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "lights", {
        get: function () {
            return this._lights;
        },
        enumerable: false,
        configurable: true
    });
    Scene.prototype.cullCamera = function (camera) {
        var meshes = [];
        this._meshes.forEach(function (mesh) {
            var distance = camera.cull(mesh);
            if (distance >= 0) {
                mesh.sortZ = distance;
                meshes.push(mesh);
            }
        });
        meshes.sort(function (a, b) { return a.sortZ - b.sortZ; });
        return meshes;
    };
    Scene.prototype.setRenderTarget = function (target) {
        this._renderTarget = target ? target : this._screen;
    };
    Scene.prototype.startFrame = function (dt) {
        var _this = this;
        this._gameTime += dt;
        this._meshes = [];
        this._lights = [];
        this._rootNode.updateSubTree(function (node) {
            if (Mesh_1.default.IS(node)) {
                _this._meshes.push(node);
            }
            else if (Light_1.default.IS(node)) {
                _this._lights.push(node);
            }
        });
        var lightInfos = renderEnv_1.default.getUniform('u_lightInfos');
        if (lightInfos) {
            this._lights.forEach(function (l, i) {
                if (i < 4) {
                    lightInfos.set(l.ubInfo, i * 16);
                }
            });
            renderEnv_1.default.setUniform('u_lightInfos', lightInfos);
        }
        renderEnv_1.default.setUniform('u_gameTime', new Float32Array([this._gameTime / 1000]));
        this._command = renderEnv_1.default.device.createCommandEncoder();
    };
    Scene.prototype.renderCamera = function (camera, meshes, clear) {
        if (clear === void 0) { clear = true; }
        camera.render(this._command, this._renderTarget, meshes, clear);
    };
    Scene.prototype.renderImages = function (meshes, clear) {
        if (clear === void 0) { clear = true; }
        var view = this._renderTarget.colorView;
        var renderPassDescriptor = {
            colorAttachments: [{
                    view: view,
                    loadValue: clear ? { r: 0, g: 0, b: 0, a: 1 } : 'load',
                    storeOp: 'store'
                }]
        };
        var pass = this._command.beginRenderPass(renderPassDescriptor);
        pass.setBindGroup(0, renderEnv_1.default.bindingGroup);
        for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
            var mesh = meshes_1[_i];
            mesh.render(pass);
        }
        pass.endPass();
    };
    Scene.prototype.computeUnits = function (units) {
        var pass = this._command.beginComputePass();
        pass.setBindGroup(0, renderEnv_1.default.bindingGroup);
        for (var _i = 0, units_1 = units; _i < units_1.length; _i++) {
            var unit = units_1[_i];
            unit.compute(pass);
        }
        pass.endPass();
    };
    Scene.prototype.copyBuffer = function (src, dst, size) {
        this._command.copyBufferToBuffer(src, 0, dst, 0, size);
    };
    Scene.prototype.endFrame = function () {
        var view = renderEnv_1.default.currentTexture.createView();
        var renderPassDescriptor = {
            colorAttachments: [{
                    view: view,
                    loadValue: { r: 0, g: 0, b: 0, a: 1 },
                    storeOp: 'store'
                }]
        };
        var pass = this._command.beginRenderPass(renderPassDescriptor);
        pass.setBindGroup(0, renderEnv_1.default.bindingGroup);
        this._blit.render(pass);
        pass.endPass();
        renderEnv_1.default.device.queue.submit([this._command.finish()]);
    };
    Scene.CLASS_NAME = 'Scene';
    return Scene;
}(HObject_1.default));
exports["default"] = Scene;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NlbmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJTY2VuZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFNQSxzQ0FBNEM7QUFHNUMscUNBQWdDO0FBQ2hDLHlDQUFvQztBQUNwQyxpQ0FBNEI7QUFDNUIsdUNBQWtDO0FBQ2xDLCtCQUEwQjtBQUUxQix5Q0FBb0M7QUFDcEMsaURBQTRDO0FBRTVDO0lBQW1DLHlCQUFPO0lBNkJ4QztRQUFBLFlBQ0UsaUJBQU8sU0FJUjtRQWhDTSxhQUFPLEdBQVksSUFBSSxDQUFDO1FBOEI3QixLQUFJLENBQUMsYUFBYSxHQUFHLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSx1QkFBYSxDQUFDLEVBQUMsS0FBSyxFQUFFLG1CQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxtQkFBUyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLEVBQUUsRUFBQyxXQUFXLEVBQUUsSUFBSSxFQUFDLEVBQUMsQ0FBQyxDQUFDO1FBQzNKLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxtQkFBUyxDQUFDLElBQUksa0JBQVEsQ0FBQyx3QkFBYyxDQUFDLEtBQUssRUFBRSxFQUFDLFNBQVMsRUFBRSxLQUFJLENBQUMsT0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDOztJQUM1RixDQUFDO0lBckJELHNCQUFJLDJCQUFRO2FBSVo7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDeEIsQ0FBQzthQU5ELFVBQWEsSUFBVTtZQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUN4QixDQUFDOzs7T0FBQTtJQU1ELHNCQUFJLHlCQUFNO2FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSx5QkFBTTthQUFWO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7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USxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRU0sd0JBQVEsR0FBZjtRQUNFLElBQU0sSUFBSSxHQUFHLG1CQUFTLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ25ELElBQU0sb0JBQW9CLEdBQTRCO1lBQ3BELGdCQUFnQixFQUFFLENBQUM7b0JBQ2pCLElBQUksTUFBQTtvQkFDSixTQUFTLEVBQUUsRUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDO29CQUNuQyxPQUFPLEVBQUUsT0FBcUI7aUJBQy9CLENBQUM7U0FDSCxDQUFDO1FBRUYsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVmLG1CQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBcEphLGdCQUFVLEdBQVcsT0FBTyxDQUFDO0lBcUo3QyxZQUFDO0NBQUEsQUF0SkQsQ0FBbUMsaUJBQU8sR0FzSnpDO2tCQXRKb0IsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IFNjZW5lLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICA6IDIwMjEvNi825LiL5Y2INzoyNToyMlxuICovXG5pbXBvcnQgeyBidWlsZGluRWZmZWN0cyB9IGZyb20gJy4uL2J1aWxkaW4nO1xuaW1wb3J0IENhbWVyYSBmcm9tICcuL0NhbWVyYSc7XG5pbXBvcnQgQ29tcHV0ZVVuaXQgZnJvbSAnLi9Db21wdXRlVW5pdCc7XG5pbXBvcnQgSE9iamVjdCBmcm9tICcuL0hPYmplY3QnO1xuaW1wb3J0IEltYWdlTWVzaCBmcm9tICcuL0ltYWdlTWVzaCc7XG5pbXBvcnQgTGlnaHQgZnJvbSAnLi9MaWdodCc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi9NYXRlcmlhbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlJztcbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9yZW5kZXJFbnYnO1xuaW1wb3J0IFJlbmRlclRleHR1cmUgZnJvbSAnLi9SZW5kZXJUZXh0dXJlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgZXh0ZW5kcyBIT2JqZWN0IHtcbiAgcHVibGljIHN0YXRpYyBDTEFTU19OQU1FOiBzdHJpbmcgPSAnU2NlbmUnO1xuICBwdWJsaWMgaXNTY2VuZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9nYW1lVGltZTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX3Jvb3ROb2RlOiBOb2RlO1xuICBwcm90ZWN0ZWQgX21lc2hlczogTWVzaFtdO1xuICBwcm90ZWN0ZWQgX2xpZ2h0czogTGlnaHRbXTtcbiAgcHJvdGVjdGVkIF9jb21tYW5kOiBHUFVDb21tYW5kRW5jb2RlcjtcbiAgcHJvdGVjdGVkIF9yZW5kZXJUYXJnZXQ6IFJlbmRlclRleHR1cmU7XG4gIHByb3RlY3RlZCBfc2NyZWVuOiBSZW5kZXJUZXh0dXJlO1xuICBwcm90ZWN0ZWQgX2JsaXQ6IEltYWdlTWVzaDtcblxuICBzZXQgcm9vdE5vZGUobm9kZTogTm9kZSkge1xuICAgIHRoaXMuX3Jvb3ROb2RlID0gbm9kZTtcbiAgfVxuXG4gIGdldCByb290Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdE5vZGU7XG4gIH1cblxuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JlZW47XG4gIH1cblxuICBnZXQgbGlnaHRzKCkge1xuICAgIHJldHVybiB0aGlzLl9saWdodHM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gdGhpcy5fc2NyZWVuID0gbmV3IFJlbmRlclRleHR1cmUoe3dpZHRoOiByZW5kZXJFbnYud2lkdGgsIGhlaWdodDogcmVuZGVyRW52LmhlaWdodCwgY29sb3JzOiBbe31dLCBkZXB0aFN0ZW5jaWw6IHtuZWVkU3RlbmNpbDogdHJ1ZX19KTtcbiAgICB0aGlzLl9ibGl0ID0gbmV3IEltYWdlTWVzaChuZXcgTWF0ZXJpYWwoYnVpbGRpbkVmZmVjdHMuaUJsaXQsIHt1X3RleHR1cmU6IHRoaXMuX3NjcmVlbn0pKTtcbiAgfVxuXG4gIHB1YmxpYyBjdWxsQ2FtZXJhKGNhbWVyYTogQ2FtZXJhKTogTWVzaFtdIHtcbiAgICBjb25zdCBtZXNoZXM6IE1lc2hbXSA9IFtdO1xuXG4gICAgdGhpcy5fbWVzaGVzLmZvckVhY2gobWVzaCA9PiB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5jdWxsKG1lc2gpO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPj0gMCkge1xuICAgICAgICBtZXNoLnNvcnRaID0gZGlzdGFuY2U7XG4gICAgICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWVzaGVzLnNvcnQoKGEsIGIpID0+IGEuc29ydFogLSBiLnNvcnRaKTtcblxuICAgIHJldHVybiBtZXNoZXM7XG4gIH1cblxuICBwdWJsaWMgc2V0UmVuZGVyVGFyZ2V0KHRhcmdldDogUmVuZGVyVGV4dHVyZSB8IG51bGwpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSB0YXJnZXQgPyB0YXJnZXQgOiB0aGlzLl9zY3JlZW47XG4gIH1cblxuICBwdWJsaWMgc3RhcnRGcmFtZShkdDogbnVtYmVyKSB7XG4gICAgdGhpcy5fZ2FtZVRpbWUgKz0gZHQ7XG4gICAgdGhpcy5fbWVzaGVzID0gW107XG4gICAgdGhpcy5fbGlnaHRzID0gW107XG5cbiAgICB0aGlzLl9yb290Tm9kZS51cGRhdGVTdWJUcmVlKG5vZGUgPT4ge1xuICAgICAgaWYgKE1lc2guSVMobm9kZSkpIHtcbiAgICAgICAgdGhpcy5fbWVzaGVzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKExpZ2h0LklTKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuX2xpZ2h0cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbGlnaHRJbmZvcyA9IHJlbmRlckVudi5nZXRVbmlmb3JtKCd1X2xpZ2h0SW5mb3MnKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgaWYgKGxpZ2h0SW5mb3MpIHtcbiAgICAgIHRoaXMuX2xpZ2h0cy5mb3JFYWNoKChsLCBpKSA9PiB7XG4gICAgICAgIGlmIChpIDwgNCkge1xuICAgICAgICAgIGxpZ2h0SW5mb3Muc2V0KGwudWJJbmZvLCBpICogMTYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlbmRlckVudi5zZXRVbmlmb3JtKCd1X2xpZ2h0SW5mb3MnLCBsaWdodEluZm9zKTsgXG4gICAgfVxuXG4gICAgcmVuZGVyRW52LnNldFVuaWZvcm0oJ3VfZ2FtZVRpbWUnLCBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLl9nYW1lVGltZSAvIDEwMDBdKSk7XG4gICAgdGhpcy5fY29tbWFuZCA9IHJlbmRlckVudi5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXJDYW1lcmEoY2FtZXJhOiBDYW1lcmEsIG1lc2hlczogTWVzaFtdLCBjbGVhcjogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBjYW1lcmEucmVuZGVyKFxuICAgICAgdGhpcy5fY29tbWFuZCxcbiAgICAgIHRoaXMuX3JlbmRlclRhcmdldCxcbiAgICAgIG1lc2hlcyxcbiAgICAgIGNsZWFyXG4gICAgKTtcbiAgfVxuXG4gIC8vIHB1YmxpYyByZW5kZXJMaWdodCgpIHtcblxuICAvLyB9XG5cbiAgcHVibGljIHJlbmRlckltYWdlcyhtZXNoZXM6IEltYWdlTWVzaFtdLCBjbGVhcjogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5fcmVuZGVyVGFyZ2V0LmNvbG9yVmlldztcblxuICAgIGNvbnN0IHJlbmRlclBhc3NEZXNjcmlwdG9yOiBHUFVSZW5kZXJQYXNzRGVzY3JpcHRvciA9IHtcbiAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgIHZpZXcsXG4gICAgICAgIGxvYWRWYWx1ZTogY2xlYXIgPyB7cjogMCwgZzogMCwgYjogMCwgYTogMX0gOiAnbG9hZCcgYXMgR1BVTG9hZE9wLFxuICAgICAgICBzdG9yZU9wOiAnc3RvcmUnIGFzIEdQVVN0b3JlT3BcbiAgICAgIH1dXG4gICAgfTtcblxuICAgIGNvbnN0IHBhc3MgPSB0aGlzLl9jb21tYW5kLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgcmVuZGVyRW52LmJpbmRpbmdHcm91cCk7XG5cbiAgICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICBtZXNoLnJlbmRlcihwYXNzKTtcbiAgICB9XG5cbiAgICBwYXNzLmVuZFBhc3MoKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wdXRlVW5pdHModW5pdHM6IENvbXB1dGVVbml0W10pIHtcbiAgICBjb25zdCBwYXNzID0gdGhpcy5fY29tbWFuZC5iZWdpbkNvbXB1dGVQYXNzKCk7XG4gICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgcmVuZGVyRW52LmJpbmRpbmdHcm91cCk7XG5cbiAgICBmb3IgKGNvbnN0IHVuaXQgb2YgdW5pdHMpIHtcbiAgICAgIHVuaXQuY29tcHV0ZShwYXNzKTtcbiAgICB9XG5cbiAgICBwYXNzLmVuZFBhc3MoKTtcbiAgfVxuXG4gIHB1YmxpYyBjb3B5QnVmZmVyKHNyYzogR1BVQnVmZmVyLCBkc3Q6IEdQVUJ1ZmZlciwgc2l6ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fY29tbWFuZC5jb3B5QnVmZmVyVG9CdWZmZXIoc3JjLCAwLCBkc3QsIDAsIHNpemUpO1xuICB9XG5cbiAgcHVibGljIGVuZEZyYW1lKCkge1xuICAgIGNvbnN0IHZpZXcgPSByZW5kZXJFbnYuY3VycmVudFRleHR1cmUuY3JlYXRlVmlldygpO1xuICAgIGNvbnN0IHJlbmRlclBhc3NEZXNjcmlwdG9yOiBHUFVSZW5kZXJQYXNzRGVzY3JpcHRvciA9IHtcbiAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgIHZpZXcsXG4gICAgICAgIGxvYWRWYWx1ZToge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9LFxuICAgICAgICBzdG9yZU9wOiAnc3RvcmUnIGFzIEdQVVN0b3JlT3BcbiAgICAgIH1dXG4gICAgfTtcblxuICAgIGNvbnN0IHBhc3MgPSB0aGlzLl9jb21tYW5kLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XG4gICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgcmVuZGVyRW52LmJpbmRpbmdHcm91cCk7XG4gICAgdGhpcy5fYmxpdC5yZW5kZXIocGFzcyk7XG4gICAgcGFzcy5lbmRQYXNzKCk7XG5cbiAgICByZW5kZXJFbnYuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5fY29tbWFuZC5maW5pc2goKV0pO1xuICB9XG59Il19

/***/ }),

/***/ "./src/core/Texture.ts":
/*!*****************************!*\
  !*** ./src/core/Texture.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var shared_1 = __webpack_require__(/*! ./shared */ "./src/core/shared.ts");
var Texture = (function (_super) {
    __extends(Texture, _super);
    function Texture(_width, _height, _src, _format) {
        if (_format === void 0) { _format = 'rgba8unorm'; }
        var _this = _super.call(this) || this;
        _this._width = _width;
        _this._height = _height;
        _this._src = _src;
        _this._format = _format;
        _this.isTexture = true;
        if (shared_1.isTextureSourceArray(_src)) {
            _this._isArray = true;
            _this._arrayCount = _src.length;
        }
        else {
            _this._isArray = false;
            _this._arrayCount = 1;
        }
        _this._gpuTexture = renderEnv_1.default.device.createTexture({
            label: _this.hash,
            size: { width: _this._width, height: _this._height, depthOrArrayLayers: _this._arrayCount },
            format: _format || 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        });
        if (shared_1.isTextureSourceArray(_src)) {
            _src.forEach(function (src, index) { return _this._load(src, index); });
            _this._gpuTextureView = _this._gpuTexture.createView({ dimension: '2d-array', arrayLayerCount: _this._arrayCount });
        }
        else {
            _this._load(_src);
            _this._gpuTextureView = _this._gpuTexture.createView();
        }
        return _this;
    }
    Object.defineProperty(Texture.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "format", {
        get: function () {
            return this._format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "source", {
        get: function () {
            return this._src;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "gpuTexture", {
        get: function () {
            return this._gpuTexture;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "view", {
        get: function () {
            return this._gpuTextureView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Texture.prototype, "isArray", {
        get: function () {
            return this._isArray;
        },
        enumerable: false,
        configurable: true
    });
    Texture.prototype._load = function (src, layer) {
        if (layer === void 0) { layer = 0; }
        if (src instanceof ImageBitmap) {
            this._loadImg(src, layer);
        }
        else {
            this._loadBuffer(src, layer);
        }
    };
    Texture.prototype._loadImg = function (img, layer) {
        renderEnv_1.default.device.queue.copyExternalImageToTexture({ source: img }, { texture: this._gpuTexture, origin: this._isArray ? { x: 0, y: 0, z: layer } : undefined }, { width: this._width, height: this._height, depthOrArrayLayers: 1 });
    };
    Texture.prototype._loadBuffer = function (buffer, layer) {
        renderEnv_1.default.device.queue.writeTexture({ texture: this._gpuTexture, origin: this._isArray ? { x: 0, y: 0, z: layer } : undefined }, buffer, { bytesPerRow: this._width * 4 }, { width: this._width, height: this._height, depthOrArrayLayers: 1 });
    };
    Texture.prototype.updateImg = function (src, layer) {
        if (layer === void 0) { layer = 0; }
        console.warn('Not implemented!');
    };
    Texture.CLASS_NAME = 'Texture';
    return Texture;
}(HObject_1.default));
exports["default"] = Texture;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlRleHR1cmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBTUEscUNBQWdDO0FBQ2hDLHlDQUFvQztBQUNwQyxtQ0FBOEQ7QUFFOUQ7SUFBcUMsMkJBQU87SUFzQzFDLGlCQUNZLE1BQWMsRUFDZCxPQUFlLEVBQ2YsSUFBdUMsRUFDdkMsT0FBd0M7UUFBeEMsd0JBQUEsRUFBQSxzQkFBd0M7UUFKcEQsWUFNRSxpQkFBTyxTQXdCUjtRQTdCVyxZQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUksR0FBSixJQUFJLENBQW1DO1FBQ3ZDLGFBQU8sR0FBUCxPQUFPLENBQWlDO1FBeEM3QyxlQUFTLEdBQVksSUFBSSxDQUFDO1FBNEMvQixJQUFJLDZCQUFvQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlCLEtBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLEtBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNoQzthQUFNO1lBQ0wsS0FBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDdEIsS0FBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7U0FDdEI7UUFFRCxLQUFJLENBQUMsV0FBVyxHQUFHLG1CQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztZQUNoRCxLQUFLLEVBQUUsS0FBSSxDQUFDLElBQUk7WUFDaEIsSUFBSSxFQUFFLEVBQUMsS0FBSyxFQUFFLEtBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUksQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsS0FBSSxDQUFDLFdBQVcsRUFBQztZQUN0RixNQUFNLEVBQUUsT0FBTyxJQUFJLFlBQVk7WUFDL0IsS0FBSyxFQUFFLGVBQWUsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLFFBQVEsR0FBRyxlQUFlLENB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TUFBcUIsRUFDckIsRUFBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUMsRUFDOUIsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxDQUFDLEVBQUMsQ0FDbEUsQ0FBQztJQUNKLENBQUM7SUFFTSwyQkFBUyxHQUFoQixVQUFpQixHQUFnQixFQUFFLEtBQWlCO1FBQWpCLHNCQUFBLEVBQUEsU0FBaUI7UUFDbEQsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFoR2Msa0JBQVUsR0FBVyxTQUFTLENBQUM7SUFpR2hELGNBQUM7Q0FBQSxBQWxHRCxDQUFxQyxpQkFBTyxHQWtHM0M7a0JBbEdvQixPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogVGV4dHVyZS50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiAyMDIxLzYvNuS4i+WNiDk6MTA6NDRcbiAqL1xuaW1wb3J0IEhPYmplY3QgZnJvbSAnLi9IT2JqZWN0JztcbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9yZW5kZXJFbnYnO1xuaW1wb3J0IHtUVGV4dHVyZVNvdXJjZSwgaXNUZXh0dXJlU291cmNlQXJyYXl9IGZyb20gJy4vc2hhcmVkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZSBleHRlbmRzIEhPYmplY3Qge1xuICBwdWJsaWMgc3RhdGljICBDTEFTU19OQU1FOiBzdHJpbmcgPSAnVGV4dHVyZSc7XG4gIHB1YmxpYyBpc1RleHR1cmU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByb3RlY3RlZCBfYml0bWFwOiBJbWFnZUJpdG1hcDtcbiAgcHJvdGVjdGVkIF9pc0FycmF5OiBib29sZWFuO1xuICBwcm90ZWN0ZWQgX2FycmF5Q291bnQ6IG51bWJlcjtcbiAgcHJvdGVjdGVkIF9ncHVUZXh0dXJlOiBHUFVUZXh0dXJlO1xuICBwcm90ZWN0ZWQgX2dwdVRleHR1cmVWaWV3OiBHUFVUZXh0dXJlVmlldztcblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG5cbiAgZ2V0IGZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9ybWF0O1xuICB9XG5cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3JjO1xuICB9XG5cbiAgZ2V0IGdwdVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVRleHR1cmU7XG4gIH1cblxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dHVyZVZpZXc7XG4gIH1cblxuICBnZXQgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNBcnJheTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBfd2lkdGg6IG51bWJlcixcbiAgICBwcm90ZWN0ZWQgX2hlaWdodDogbnVtYmVyLFxuICAgIHByb3RlY3RlZCBfc3JjOiBUVGV4dHVyZVNvdXJjZSB8IFRUZXh0dXJlU291cmNlW10sXG4gICAgcHJvdGVjdGVkIF9mb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQgPSAncmdiYTh1bm9ybSdcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChpc1RleHR1cmVTb3VyY2VBcnJheShfc3JjKSkge1xuICAgICAgdGhpcy5faXNBcnJheSA9IHRydWU7XG4gICAgICB0aGlzLl9hcnJheUNvdW50ID0gX3NyYy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzQXJyYXkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FycmF5Q291bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX2dwdVRleHR1cmUgPSByZW5kZXJFbnYuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgbGFiZWw6IHRoaXMuaGFzaCxcbiAgICAgIHNpemU6IHt3aWR0aDogdGhpcy5fd2lkdGgsIGhlaWdodDogdGhpcy5faGVpZ2h0LCBkZXB0aE9yQXJyYXlMYXllcnM6IHRoaXMuX2FycmF5Q291bnR9LFxuICAgICAgZm9ybWF0OiBfZm9ybWF0IHx8ICdyZ2JhOHVub3JtJyxcbiAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UXG4gICAgfSk7XG5cbiAgICBpZiAoaXNUZXh0dXJlU291cmNlQXJyYXkoX3NyYykpIHtcbiAgICAgIF9zcmMuZm9yRWFjaCgoc3JjLCBpbmRleCkgPT4gdGhpcy5fbG9hZChzcmMsIGluZGV4KSk7XG4gICAgICB0aGlzLl9ncHVUZXh0dXJlVmlldyA9IHRoaXMuX2dwdVRleHR1cmUuY3JlYXRlVmlldyh7ZGltZW5zaW9uOiAnMmQtYXJyYXknLCBhcnJheUxheWVyQ291bnQ6IHRoaXMuX2FycmF5Q291bnR9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9hZChfc3JjKTtcbiAgICAgIHRoaXMuX2dwdVRleHR1cmVWaWV3ID0gdGhpcy5fZ3B1VGV4dHVyZS5jcmVhdGVWaWV3KCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9sb2FkKHNyYzogVFRleHR1cmVTb3VyY2UsIGxheWVyOiBudW1iZXIgPSAwKSB7XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICB0aGlzLl9sb2FkSW1nKHNyYywgbGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb2FkQnVmZmVyKHNyYywgbGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfbG9hZEltZyhpbWc6IEltYWdlQml0bWFwLCBsYXllcjogbnVtYmVyKSB7XG4gICAgcmVuZGVyRW52LmRldmljZS5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZShcbiAgICAgIHtzb3VyY2U6IGltZ30sXG4gICAgICB7dGV4dHVyZTogdGhpcy5fZ3B1VGV4dHVyZSwgb3JpZ2luOiB0aGlzLl9pc0FycmF5ID8ge3g6IDAsIHk6IDAsIHo6IGxheWVyfSA6IHVuZGVmaW5lZH0sXG4gICAgICB7d2lkdGg6IHRoaXMuX3dpZHRoLCBoZWlnaHQ6IHRoaXMuX2hlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiAxfVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2xvYWRCdWZmZXIoYnVmZmVyOiBBcnJheUJ1ZmZlciwgbGF5ZXI6IG51bWJlcikge1xuICAgIHJlbmRlckVudi5kZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxuICAgICAge3RleHR1cmU6IHRoaXMuX2dwdVRleHR1cmUsIG9yaWdpbjogdGhpcy5faXNBcnJheSA/IHt4OiAwLCB5OiAwLCB6OiBsYXllcn0gOiB1bmRlZmluZWR9LFxuICAgICAgYnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgICAge2J5dGVzUGVyUm93OiB0aGlzLl93aWR0aCAqIDR9LFxuICAgICAge3dpZHRoOiB0aGlzLl93aWR0aCwgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMX1cbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUltZyhzcmM6IEltYWdlQml0bWFwLCBsYXllcjogbnVtYmVyID0gMCkge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkIScpO1xuICB9XG59Il19

/***/ }),

/***/ "./src/core/UBTemplate.ts":
/*!********************************!*\
  !*** ./src/core/UBTemplate.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EUBGroup = void 0;
var shared_1 = __webpack_require__(/*! ./shared */ "./src/core/shared.ts");
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
var RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./src/core/RenderTexture.ts");
var HObject_1 = __webpack_require__(/*! ./HObject */ "./src/core/HObject.ts");
var CubeTexture_1 = __webpack_require__(/*! ./CubeTexture */ "./src/core/CubeTexture.ts");
var EUBGroup;
(function (EUBGroup) {
    EUBGroup[EUBGroup["Global"] = 0] = "Global";
    EUBGroup[EUBGroup["Material"] = 1] = "Material";
    EUBGroup[EUBGroup["Mesh"] = 2] = "Mesh";
})(EUBGroup = exports.EUBGroup || (exports.EUBGroup = {}));
var UBTemplate = (function (_super) {
    __extends(UBTemplate, _super);
    function UBTemplate(_uniformDesc, _groupId, _visibility) {
        var _this = _super.call(this) || this;
        _this._uniformDesc = _uniformDesc;
        _this._groupId = _groupId;
        _this._visibility = _visibility;
        _this.isUBTemplate = true;
        var device = renderEnv_1.default.device;
        var visibility = _visibility === undefined ? GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT : _visibility;
        var ubStruct = _groupId === EUBGroup.Global ? 'UniformsGlobal' : _groupId === EUBGroup.Mesh ? 'UniformsObject' : 'UniformsMaterial';
        var ubName = _groupId === EUBGroup.Global ? 'global' : _groupId === EUBGroup.Mesh ? 'mesh' : 'material';
        var index = 0;
        var bindingId = 0;
        _this._shaderPrefix = '';
        _this._uniformsInfo = {};
        var entries = [];
        if (_uniformDesc.uniforms.length) {
            _uniformDesc.uniforms.forEach(function (ud) {
                if (ud.customType) {
                    _this._shaderPrefix += ud.customType.code + '\n';
                }
            });
            _this._shaderPrefix += "[[block]] struct " + ubStruct + " {\n";
            entries.push({
                binding: 0,
                visibility: visibility,
                buffer: { type: 'uniform' }
            });
            var uniforms32Length_1 = 0;
            _uniformDesc.uniforms.forEach(function (ud) {
                var _a = _this._getRealLayoutInfo(ud.type, ud.size || 1, ud.defaultValue, ud.customType), origLen = _a.origLen, realLen = _a.realLen, defaultValue = _a.defaultValue;
                _this._uniformsInfo[ud.name] = { bindingId: 0, index: index, type: 'buffer', offset: uniforms32Length_1, defaultValue: defaultValue, origLen: origLen, realLen: realLen, size: ud.size || 1 };
                uniforms32Length_1 += defaultValue.length;
                var sym = ud.customType ? ud.customType.name : ud.type === 'number' ? "" + (ud.format || 'f32') : ud.type + "<" + (ud.format || 'f32') + ">";
                var pre = origLen !== realLen ? "[[stride(" + realLen * 4 + ")]]" : '';
                if (!ud.size) {
                    _this._shaderPrefix += "  [[align(16)]] " + ud.name + ": " + sym + ";\n";
                }
                else {
                    ud.size > 1 && (_this._shaderPrefix += " [[align(16)]] " + ud.name + ": " + pre + " array<" + sym + ", " + ud.size + ">;\n");
                }
                index += 1;
            });
            _this._uniformsBufferDefault = new Uint32Array(uniforms32Length_1);
            _this._shaderPrefix += "};\n[[group(" + _groupId + "), binding(0)]] var<uniform> " + ubName + ": " + ubStruct + ";\n";
            bindingId += 1;
        }
        _uniformDesc.textures && _uniformDesc.textures.forEach(function (ud) {
            var isCube = CubeTexture_1.default.IS(ud.defaultValue);
            var isArray = ud.defaultValue.isArray;
            var viewDimension = isCube ? (isArray ? 'cube-array' : 'cube') : (isArray ? '2d-array' : '2d');
            entries.push({
                binding: bindingId,
                visibility: visibility,
                texture: !ud.storageAccess ? {
                    sampleType: ud.format || 'float',
                    viewDimension: viewDimension
                } : undefined,
                storageTexture: ud.storageAccess ? {
                    format: ud.storageFormat || 'rgba8unorm',
                    viewDimension: viewDimension,
                    access: ud.storageAccess
                } : undefined
            });
            _this._uniformsInfo[ud.name] = {
                bindingId: bindingId, index: index,
                type: 'texture',
                defaultGpuValue: ud.defaultValue.view
            };
            var texFormat = ud.format === 'depth' ? 'depth' : ud.format === 'uint' ? 'u32' : ud.format === 'sint' ? 'i32' : 'f32';
            if (ud.storageAccess) {
                _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var " + ud.name + ": texture_storage_2d<" + (ud.storageFormat || 'rgba8unorm') + ", " + ud.storageAccess.replace('-only', '') + ">;\n";
            }
            else if (isCube) {
                _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var " + ud.name + ": texture_cube<" + texFormat + ">;\n";
            }
            else if (ud.defaultValue.isArray) {
                _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var " + ud.name + ": texture_2d_array<" + texFormat + ">;\n";
            }
            else {
                _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var " + ud.name + ": texture_2d<" + texFormat + ">;\n";
            }
            bindingId += 1;
            index += 1;
        });
        _uniformDesc.samplers && _uniformDesc.samplers.forEach(function (ud) {
            entries.push({
                binding: bindingId,
                visibility: visibility,
                sampler: { type: 'filtering' }
            });
            _this._uniformsInfo[ud.name] = {
                bindingId: bindingId, index: index,
                type: 'sampler',
                defaultGpuValue: device.createSampler(ud.defaultValue)
            };
            _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var " + ud.name + ": sampler;\n";
            bindingId += 1;
            index += 1;
        });
        _this._shaderPrefix += '\n';
        _uniformDesc.uniforms.forEach(function (ud, index) {
            var info = _this._uniformsInfo[ud.name];
            _this._uniformsBufferDefault.set(new Uint32Array(info.defaultValue.buffer), info.offset);
        });
        if (_uniformDesc.storages) {
            var structCache_1 = {};
            _uniformDesc.storages.forEach(function (ud) {
                entries.push({
                    binding: bindingId,
                    visibility: visibility,
                    buffer: { type: ud.writable ? 'storage' : 'read-only-storage' }
                });
                var hash = "Storage" + ud.type + (ud.format || 'f32');
                if (!ud.customStruct && !structCache_1[hash]) {
                    _this._shaderPrefix += (structCache_1[hash] = structCache_1[hash] || _this._getStorageStruct(hash, ud.type, ud.format || 'f32')) + '\n';
                }
                if (ud.customStruct) {
                    hash = ud.customStruct.name;
                    _this._shaderPrefix += ud.customStruct.code;
                }
                var gpuValue = ud.gpuValue ? ud.gpuValue : shared_1.createGPUBuffer(ud.defaultValue, GPUBufferUsage.STORAGE);
                _this._uniformsInfo[ud.name] = { bindingId: bindingId, index: index, type: 'storage', defaultValue: ud.defaultValue, defaultGpuValue: gpuValue };
                _this._shaderPrefix += "[[group(" + _groupId + "), binding(" + bindingId + ")]] var<storage, " + (ud.writable ? 'read_write' : 'read') + "> " + ud.name + ": " + hash + ";\n";
                index += 1;
                bindingId += 1;
            });
        }
        _this._uniformLayoutDesc = { entries: entries };
        _this._uniformLayout = device.createBindGroupLayout(_this._uniformLayoutDesc);
        return _this;
    }
    Object.defineProperty(UBTemplate.prototype, "groupId", {
        get: function () {
            return this._groupId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UBTemplate.prototype, "shaderPrefix", {
        get: function () {
            return this._shaderPrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UBTemplate.prototype, "uniformLayout", {
        get: function () {
            return this._uniformLayout;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UBTemplate.prototype, "uniformsInfo", {
        get: function () {
            return this._uniformsInfo;
        },
        enumerable: false,
        configurable: true
    });
    UBTemplate.prototype._getRealLayoutInfo = function (type, size, defaultValue, custom) {
        if (custom) {
            return { origLen: custom.len, realLen: custom.len, defaultValue: defaultValue };
        }
        var origLen;
        var realLen;
        switch (type) {
            case 'number':
                origLen = 1;
                realLen = 4;
                break;
            case 'vec2':
                origLen = 2;
                realLen = 4;
                break;
            case 'vec3':
                origLen = 3;
                realLen = 4;
                break;
            case 'vec4':
            case 'mat2x2':
                origLen = 4;
                realLen = 4;
                break;
            case 'mat3x3':
                origLen = 9;
                realLen = 12;
                break;
            case 'mat4x4':
                origLen = 16;
                realLen = 16;
                break;
        }
        var constructor = defaultValue.constructor;
        var value = new constructor(realLen * size);
        for (var index = 0; index < size; index += 1) {
            value.set(defaultValue.slice(index * origLen, (index + 1) * origLen), index * realLen);
        }
        return {
            origLen: origLen,
            realLen: realLen,
            defaultValue: value
        };
    };
    UBTemplate.prototype._getStorageStruct = function (hash, type, format) {
        if (type === 'number') {
            return "[[block]] struct " + hash + " { value: array<" + format + ">; };";
        }
        if (type === 'vec2' || type === 'vec3' || type === 'vec4') {
            return "[[block]] struct " + hash + " { value: array<" + type + "<" + format + ">>; };";
        }
        throw new Error('Not support type!');
    };
    UBTemplate.prototype.createUniformBlock = function () {
        var _this = this;
        var _a = this, _uniformDesc = _a._uniformDesc, _uniformsInfo = _a._uniformsInfo, _uniformsBufferDefault = _a._uniformsBufferDefault;
        var values = {};
        var groupEntries = [];
        var cpuBuffer;
        var gpuBuffer;
        if (_uniformsBufferDefault) {
            gpuBuffer = shared_1.createGPUBuffer(_uniformsBufferDefault, GPUBufferUsage.UNIFORM);
            cpuBuffer = _uniformsBufferDefault.slice();
            groupEntries.push({
                binding: 0,
                resource: { buffer: gpuBuffer }
            });
            _uniformDesc.uniforms.forEach(function (ud) {
                var info = _this._uniformsInfo[ud.name];
                values[ud.name] = {
                    value: new _this._uniformsInfo[ud.name].defaultValue.constructor(cpuBuffer.buffer, info.offset * 4, info.realLen * info.size),
                    gpuValue: gpuBuffer
                };
            });
        }
        _uniformDesc.textures && _uniformDesc.textures.forEach(function (ud) {
            var view = _uniformsInfo[ud.name].defaultGpuValue;
            values[ud.name] = { value: ud.defaultValue, gpuValue: view };
            groupEntries.push({
                binding: _uniformsInfo[ud.name].bindingId,
                resource: view
            });
        });
        _uniformDesc.samplers && _uniformDesc.samplers.forEach(function (ud) {
            var sampler = _uniformsInfo[ud.name].defaultGpuValue;
            values[ud.name] = { value: ud.defaultValue, gpuValue: sampler };
            groupEntries.push({
                binding: _uniformsInfo[ud.name].bindingId,
                resource: sampler
            });
        });
        _uniformDesc.storages && _uniformDesc.storages.forEach(function (ud) {
            var buffer = _uniformsInfo[ud.name].defaultGpuValue;
            values[ud.name] = { value: ud.defaultValue, gpuValue: buffer };
            groupEntries.push({
                binding: _uniformsInfo[ud.name].bindingId,
                resource: { buffer: buffer }
            });
        });
        return { entries: groupEntries, values: values, layout: this._uniformLayout, cpuBuffer: cpuBuffer, gpuBuffer: gpuBuffer, isBufferDirty: false, isDirty: true };
    };
    UBTemplate.prototype.setUniform = function (ub, name, value, rtSubNameOrGPUBuffer) {
        var info = this._uniformsInfo[name];
        if (!info || value === undefined) {
            return;
        }
        var entries = ub.entries;
        var bindingId = info.bindingId, type = info.type, offset = info.offset, realLen = info.realLen, origLen = info.origLen;
        var values = ub.values[name];
        if (type === 'buffer') {
            value = value;
            var cpuValue = values.value;
            value = (typeof value === 'number' ? [value] : value);
            if (origLen !== realLen) {
                var size = value.length / origLen;
                for (var index = 0; index < size; index += 1) {
                    cpuValue.set(value.slice(origLen * index, origLen * (index + 1)), realLen * index);
                }
            }
            else {
                cpuValue.set(value);
            }
            ub.isBufferDirty = true;
        }
        else if (type === 'sampler') {
            values.value = value;
            console.warn('Not implemented!');
        }
        else if (type === 'storage') {
            values.value = value;
            entries[bindingId].resource.buffer = values.gpuValue = rtSubNameOrGPUBuffer
                ? rtSubNameOrGPUBuffer
                : shared_1.createGPUBuffer(value, GPUBufferUsage.STORAGE);
            ub.isDirty = true;
        }
        else if (RenderTexture_1.default.IS(value)) {
            var view = rtSubNameOrGPUBuffer ? value.getColorViewByName(rtSubNameOrGPUBuffer) : value.colorView;
            entries[bindingId].resource = values.gpuValue = view;
            values.value = value;
            ub.isDirty = true;
            return;
        }
        else {
            value = value;
            if (value.isArray !== values.value.isArray) {
                throw new Error('Require texture2d array!');
            }
            entries[bindingId].resource = values.gpuValue = value.view;
            values.value = value;
            ub.isDirty = true;
            return;
        }
    };
    UBTemplate.prototype.getUniform = function (ub, name) {
        var _a;
        return (_a = ub.values[name]) === null || _a === void 0 ? void 0 : _a.value;
    };
    UBTemplate.prototype.getBindingGroup = function (ub, preGroup) {
        if (ub.isBufferDirty) {
            renderEnv_1.default.device.queue.writeBuffer(ub.gpuBuffer, 0, ub.cpuBuffer);
            ub.isBufferDirty = false;
        }
        if (ub.isDirty) {
            preGroup = renderEnv_1.default.device.createBindGroup({
                layout: ub.layout,
                entries: ub.entries
            });
            ub.isDirty = false;
        }
        return preGroup;
    };
    UBTemplate.CLASS_NAME = 'UBTemplate';
    return UBTemplate;
}(HObject_1.default));
exports["default"] = UBTemplate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVUJUZW1wbGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlVCVGVtcGxhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLG1DQUFvRjtBQUNwRix5Q0FBb0M7QUFDcEMsaURBQTRDO0FBRTVDLHFDQUFnQztBQUNoQyw2Q0FBd0M7QUFFeEMsSUFBWSxRQUlYO0FBSkQsV0FBWSxRQUFRO0lBQ2xCLDJDQUFVLENBQUE7SUFDViwrQ0FBWSxDQUFBO0lBQ1osdUNBQVEsQ0FBQTtBQUNWLENBQUMsRUFKVyxRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQUluQjtBQWtERDtJQUF3Qyw4QkFBTztJQXNDN0Msb0JBQ1ksWUFBaUMsRUFDakMsUUFBa0IsRUFDbEIsV0FBb0I7UUFIaEMsWUFLRSxpQkFBTyxTQTBJUjtRQTlJVyxrQkFBWSxHQUFaLFlBQVksQ0FBcUI7UUFDakMsY0FBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixpQkFBVyxHQUFYLFdBQVcsQ0FBUztRQXZDekIsa0JBQVksR0FBWSxJQUFJLENBQUM7UUEyQzNCLElBQUEsTUFBTSxHQUFJLG1CQUFTLE9BQWIsQ0FBYztRQUMzQixJQUFNLFVBQVUsR0FBRyxXQUFXLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBQ3RJLElBQU0sUUFBUSxHQUFHLFFBQVEsS0FBSyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQztRQUN0SSxJQUFNLE1BQU0sR0FBRyxRQUFRLEtBQUssUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFD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LENBQUMsQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBQzNELE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLEVBQUUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLE9BQU87U0FDUjtJQUNILENBQUM7SUFFTSwrQkFBVSxHQUFqQixVQUFrQixFQUFpQixFQUFFLElBQVk7O1FBQy9DLGFBQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMENBQUUsS0FBSyxDQUFDO0lBQ2hDLENBQUM7SUFFTSxvQ0FBZSxHQUF0QixVQUF1QixFQUFpQixFQUFFLFFBQXNCO1FBQzlELElBQUksRUFBRSxDQUFDLGFBQWEsRUFBRTtZQUNwQixtQkFBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUNoQyxFQUFFLENBQUMsU0FBc0IsRUFDekIsQ0FBQyxFQUNELEVBQUUsQ0FBQyxTQUFTLENBQ2IsQ0FBQztZQUVGLEVBQUUsQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1NBQzFCO1FBRUQsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFO1lBQ2QsUUFBUSxHQUFHLG1CQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztnQkFDMUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNO2dCQUNqQixPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU87YUFDcEIsQ0FBQyxDQUFDO1lBQ0gsRUFBRSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDcEI7UUFFRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBcllhLHFCQUFVLEdBQVcsWUFBWSxDQUFDO0lBc1lsRCxpQkFBQztDQUFBLEFBdllELENBQXdDLGlCQUFPLEdBdVk5QztrQkF2WW9CLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBVQlRlbXBsYXRlLnRzXG4gKiBAQXV0aG9yIDogZHR5c2t5IChkdHlza3lAb3V0bG9vay5jb20pXG4gKiBATGluayAgIDogZHR5c2t5Lm1vZVxuICogQERhdGUgICAgOiA2LzI0LzIwMjEsIDIzOjAwOjU1IFBNXG4qL1xuaW1wb3J0IHtjcmVhdGVHUFVCdWZmZXIsIGhhc2hDb2RlLCBUVHlwZWRBcnJheSwgVFVuaWZvcm1UeXBlZEFycmF5fSBmcm9tIFwiLi9zaGFyZWRcIjtcbmltcG9ydCByZW5kZXJFbnYgZnJvbSBcIi4vcmVuZGVyRW52XCI7XG5pbXBvcnQgUmVuZGVyVGV4dHVyZSBmcm9tIFwiLi9SZW5kZXJUZXh0dXJlXCI7XG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi9UZXh0dXJlXCI7XG5pbXBvcnQgSE9iamVjdCBmcm9tIFwiLi9IT2JqZWN0XCI7XG5pbXBvcnQgQ3ViZVRleHR1cmUgZnJvbSBcIi4vQ3ViZVRleHR1cmVcIjtcblxuZXhwb3J0IGVudW0gRVVCR3JvdXAge1xuICBHbG9iYWwgPSAwLFxuICBNYXRlcmlhbCA9IDEsXG4gIE1lc2ggPSAyXG59XG5cbmV4cG9ydCB0eXBlIFRVbmlmb3JtVmFsdWUgPSBUVW5pZm9ybVR5cGVkQXJyYXkgfCBUZXh0dXJlIHwgQ3ViZVRleHR1cmUgfCBHUFVTYW1wbGVyRGVzY3JpcHRvciB8IFJlbmRlclRleHR1cmU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVVuaWZvcm1zRGVzY3JpcHRvciB7XG4gIHVuaWZvcm1zOiB7XG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHR5cGU6ICdudW1iZXInIHwgJ3ZlYzInIHwgJ3ZlYzMnIHwgJ3ZlYzQnIHwgJ21hdDJ4MicgfCAnbWF0M3gzJyB8ICdtYXQ0eDQnLFxuICAgIGZvcm1hdD86ICdmMzInIHwgJ3UzMicgfCAnaTMyJyxcbiAgICBzaXplPzogbnVtYmVyLFxuICAgIGN1c3RvbVR5cGU/OiB7bmFtZTogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIGxlbjogbnVtYmVyfSxcbiAgICBkZWZhdWx0VmFsdWU6IFRVbmlmb3JtVHlwZWRBcnJheVxuICB9W10sXG4gIHRleHR1cmVzPzoge1xuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmb3JtYXQ/OiBHUFVUZXh0dXJlU2FtcGxlVHlwZSxcbiAgICBkZWZhdWx0VmFsdWU6IFRleHR1cmUgfCBDdWJlVGV4dHVyZSxcbiAgICBzdG9yYWdlQWNjZXNzPzogR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MsXG4gICAgc3RvcmFnZUZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXRcbiAgfVtdLFxuICBzYW1wbGVycz86IHtcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiBHUFVTYW1wbGVyRGVzY3JpcHRvclxuICB9W10sXG4gIHN0b3JhZ2VzPzoge1xuICAgIG5hbWU6IHN0cmluZyxcbiAgICB0eXBlOiAnbnVtYmVyJyB8ICd2ZWMyJyB8ICd2ZWMzJyB8ICd2ZWM0JyxcbiAgICBmb3JtYXQ/OiAnZjMyJyB8ICd1MzInIHwgJ2kzMicsXG4gICAgY3VzdG9tU3RydWN0Pzoge25hbWU6IHN0cmluZywgY29kZTogc3RyaW5nfSxcbiAgICB3cml0YWJsZT86IGJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBUVW5pZm9ybVR5cGVkQXJyYXksXG4gICAgZ3B1VmFsdWU/OiBHUFVCdWZmZXJcbiAgfVtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVVuaWZvcm1CbG9jayB7XG4gIGlzQnVmZmVyRGlydHk6IGJvb2xlYW47XG4gIGlzRGlydHk6IGJvb2xlYW47XG4gIGxheW91dDogR1BVQmluZEdyb3VwTGF5b3V0O1xuICBlbnRyaWVzOiBHUFVCaW5kR3JvdXBFbnRyeVtdO1xuICBjcHVCdWZmZXI6IFVpbnQzMkFycmF5O1xuICBncHVCdWZmZXI6IEdQVUJ1ZmZlcjtcbiAgdmFsdWVzOiB7XG4gICAgW25hbWU6IHN0cmluZ106IHtcbiAgICAgIHZhbHVlOiBUVW5pZm9ybVZhbHVlLFxuICAgICAgZ3B1VmFsdWU6IEdQVUJ1ZmZlciB8IEdQVVNhbXBsZXIgfCBHUFVUZXh0dXJlVmlld1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUJUZW1wbGF0ZSBleHRlbmRzIEhPYmplY3Qge1xuICBwdWJsaWMgc3RhdGljIENMQVNTX05BTUU6IHN0cmluZyA9ICdVQlRlbXBsYXRlJztcbiAgcHVibGljIGlzVUJUZW1wbGF0ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJvdGVjdGVkIF9zaGFkZXJQcmVmaXg6IHN0cmluZztcbiAgcHJvdGVjdGVkIF91bmlmb3JtTGF5b3V0RGVzYzogR1BVQmluZEdyb3VwTGF5b3V0RGVzY3JpcHRvcjtcbiAgcHJvdGVjdGVkIF91bmlmb3JtTGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXQ7XG4gIHByb3RlY3RlZCBfdW5pZm9ybUJpbmREZXNjOiBHUFVCaW5kR3JvdXBEZXNjcmlwdG9yO1xuICBwcm90ZWN0ZWQgX3VuaWZvcm1zQnVmZmVyRGVmYXVsdDogVWludDMyQXJyYXk7XG4gIHByb3RlY3RlZCBfdW5pZm9ybXNJbmZvOiB7W25hbWU6IHN0cmluZ106IHtcbiAgICBiaW5kaW5nSWQ6IG51bWJlcixcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHR5cGU6ICd0ZXh0dXJlJyB8ICdidWZmZXInIHwgJ3NhbXBsZXInIHwgJ3N0b3JhZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZT86IFRVbmlmb3JtVHlwZWRBcnJheSB8IFRleHR1cmUgfCBHUFVTYW1wbGVyRGVzY3JpcHRvcixcbiAgICBkZWZhdWx0R3B1VmFsdWU/OiBHUFVTYW1wbGVyIHwgR1BVVGV4dHVyZVZpZXcgfCBHUFVCdWZmZXIsXG4gICAgLyogMzJiaXRzICovXG4gICAgb2Zmc2V0PzogbnVtYmVyLFxuICAgIHJlYWxMZW4/OiBudW1iZXIsXG4gICAgb3JpZ0xlbj86IG51bWJlcixcbiAgICBzaXplPzogbnVtYmVyXG4gIH19O1xuXG4gIGdldCBncm91cElkKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cElkO1xuICB9XG5cbiAgZ2V0IHNoYWRlclByZWZpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhZGVyUHJlZml4O1xuICB9XG5cbiAgZ2V0IHVuaWZvcm1MYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaWZvcm1MYXlvdXQ7XG4gIH1cblxuICBnZXQgdW5pZm9ybXNJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl91bmlmb3Jtc0luZm87XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX3VuaWZvcm1EZXNjOiBJVW5pZm9ybXNEZXNjcmlwdG9yLFxuICAgIHByb3RlY3RlZCBfZ3JvdXBJZDogRVVCR3JvdXAsXG4gICAgcHJvdGVjdGVkIF92aXNpYmlsaXR5PzogbnVtYmVyLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3Qge2RldmljZX0gPSByZW5kZXJFbnY7XG4gICAgY29uc3QgdmlzaWJpbGl0eSA9IF92aXNpYmlsaXR5ID09PSB1bmRlZmluZWQgPyBHUFVTaGFkZXJTdGFnZS5DT01QVVRFIHwgR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgOiBfdmlzaWJpbGl0eTtcbiAgICBjb25zdCB1YlN0cnVjdCA9IF9ncm91cElkID09PSBFVUJHcm91cC5HbG9iYWwgPyAnVW5pZm9ybXNHbG9iYWwnIDogX2dyb3VwSWQgPT09IEVVQkdyb3VwLk1lc2ggPyAnVW5pZm9ybXNPYmplY3QnIDogJ1VuaWZvcm1zTWF0ZXJpYWwnO1xuICAgIGNvbnN0IHViTmFtZSA9IF9ncm91cElkID09PSBFVUJHcm91cC5HbG9iYWwgPyAnZ2xvYmFsJyA6IF9ncm91cElkID09PSBFVUJHcm91cC5NZXNoID8gJ21lc2gnIDogJ21hdGVyaWFsJztcblxuICAgIGxldCBpbmRleDogbnVtYmVyID0gMDtcbiAgICBsZXQgYmluZGluZ0lkOiBudW1iZXIgPSAwO1xuICAgIHRoaXMuX3NoYWRlclByZWZpeCA9ICcnO1xuICAgIHRoaXMuX3VuaWZvcm1zSW5mbyA9IHt9O1xuXG4gICAgY29uc3QgZW50cmllczogR1BVQmluZEdyb3VwTGF5b3V0RW50cnlbXSA9IFtdO1xuICAgIFxuICAgIGlmIChfdW5pZm9ybURlc2MudW5pZm9ybXMubGVuZ3RoKSB7XG4gICAgICBfdW5pZm9ybURlc2MudW5pZm9ybXMuZm9yRWFjaCgodWQpID0+IHtcbiAgICAgICAgaWYgKHVkLmN1c3RvbVR5cGUpIHtcbiAgICAgICAgICB0aGlzLl9zaGFkZXJQcmVmaXggKz0gdWQuY3VzdG9tVHlwZS5jb2RlICsgJ1xcbic7ICAgIFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc2hhZGVyUHJlZml4ICs9IGBbW2Jsb2NrXV0gc3RydWN0ICR7dWJTdHJ1Y3R9IHtcXG5gO1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgdmlzaWJpbGl0eSxcbiAgICAgICAgYnVmZmVyOiB7dHlwZTogJ3VuaWZvcm0nIGFzIEdQVUJ1ZmZlckJpbmRpbmdUeXBlfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCB1bmlmb3JtczMyTGVuZ3RoOiBudW1iZXIgPSAwO1xuICAgICAgX3VuaWZvcm1EZXNjLnVuaWZvcm1zLmZvckVhY2goKHVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHtvcmlnTGVuLCByZWFsTGVuLCBkZWZhdWx0VmFsdWV9ID0gdGhpcy5fZ2V0UmVhbExheW91dEluZm8odWQudHlwZSwgdWQuc2l6ZSB8fCAxLCB1ZC5kZWZhdWx0VmFsdWUsIHVkLmN1c3RvbVR5cGUpO1xuXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXSA9IHtiaW5kaW5nSWQ6IDAsIGluZGV4LCB0eXBlOiAnYnVmZmVyJywgb2Zmc2V0OiB1bmlmb3JtczMyTGVuZ3RoLCBkZWZhdWx0VmFsdWUsIG9yaWdMZW4sIHJlYWxMZW4sIHNpemU6IHVkLnNpemUgfHwgMX07XG4gICAgICAgIHVuaWZvcm1zMzJMZW5ndGggKz0gZGVmYXVsdFZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3ltID0gdWQuY3VzdG9tVHlwZSA/IHVkLmN1c3RvbVR5cGUubmFtZSA6IHVkLnR5cGUgPT09ICdudW1iZXInID8gYCR7dWQuZm9ybWF0IHx8ICdmMzInfWAgOiBgJHt1ZC50eXBlfTwke3VkLmZvcm1hdCB8fCAnZjMyJ30+YDtcbiAgICAgICAgY29uc3QgcHJlID0gb3JpZ0xlbiAhPT0gcmVhbExlbiA/IGBbW3N0cmlkZSgke3JlYWxMZW4gKiA0fSldXWAgOiAnJztcbiAgICAgICAgaWYgKCF1ZC5zaXplKSB7XG4gICAgICAgICAgdGhpcy5fc2hhZGVyUHJlZml4ICs9IGAgIFtbYWxpZ24oMTYpXV0gJHt1ZC5uYW1lfTogJHtzeW19O1xcbmA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdWQuc2l6ZSA+IDEgJiYgKHRoaXMuX3NoYWRlclByZWZpeCArPSBgIFtbYWxpZ24oMTYpXV0gJHt1ZC5uYW1lfTogJHtwcmV9IGFycmF5PCR7c3ltfSwgJHt1ZC5zaXplfT47XFxuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdW5pZm9ybXNCdWZmZXJEZWZhdWx0ID0gbmV3IFVpbnQzMkFycmF5KHVuaWZvcm1zMzJMZW5ndGgpO1xuICAgICAgdGhpcy5fc2hhZGVyUHJlZml4ICs9IGB9O1xcbltbZ3JvdXAoJHtfZ3JvdXBJZH0pLCBiaW5kaW5nKDApXV0gdmFyPHVuaWZvcm0+ICR7dWJOYW1lfTogJHt1YlN0cnVjdH07XFxuYFxuXG4gICAgICBiaW5kaW5nSWQgKz0gMTtcbiAgICB9XG5cbiAgICBfdW5pZm9ybURlc2MudGV4dHVyZXMgJiYgX3VuaWZvcm1EZXNjLnRleHR1cmVzLmZvckVhY2goKHVkKSA9PiB7XG4gICAgICBjb25zdCBpc0N1YmUgPSBDdWJlVGV4dHVyZS5JUyh1ZC5kZWZhdWx0VmFsdWUpO1xuICAgICAgY29uc3QgaXNBcnJheSA9ICh1ZC5kZWZhdWx0VmFsdWUgYXMgVGV4dHVyZSkuaXNBcnJheTtcbiAgICAgIGNvbnN0IHZpZXdEaW1lbnNpb24gPSBpc0N1YmUgPyAoaXNBcnJheSA/ICdjdWJlLWFycmF5JyA6ICdjdWJlJykgOiAoaXNBcnJheSA/ICcyZC1hcnJheScgOiAnMmQnKTtcblxuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgYmluZGluZzogYmluZGluZ0lkLFxuICAgICAgICB2aXNpYmlsaXR5LFxuICAgICAgICB0ZXh0dXJlOiAhdWQuc3RvcmFnZUFjY2VzcyA/IHtcbiAgICAgICAgICBzYW1wbGVUeXBlOiB1ZC5mb3JtYXQgfHwgJ2Zsb2F0JyxcbiAgICAgICAgICB2aWV3RGltZW5zaW9uXG4gICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIHN0b3JhZ2VUZXh0dXJlOiB1ZC5zdG9yYWdlQWNjZXNzID8ge1xuICAgICAgICAgIGZvcm1hdDogdWQuc3RvcmFnZUZvcm1hdCB8fCAncmdiYTh1bm9ybScsXG4gICAgICAgICAgdmlld0RpbWVuc2lvbixcbiAgICAgICAgICBhY2Nlc3M6IHVkLnN0b3JhZ2VBY2Nlc3NcbiAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXSA9IHtcbiAgICAgICAgYmluZGluZ0lkLCBpbmRleCwgdHlwZTogJ3RleHR1cmUnLFxuICAgICAgICBkZWZhdWx0R3B1VmFsdWU6ICh1ZC5kZWZhdWx0VmFsdWUgYXMgVGV4dHVyZSkudmlld1xuICAgICAgfTtcblxuICAgICAgbGV0IHRleEZvcm1hdDogc3RyaW5nID0gdWQuZm9ybWF0ID09PSAnZGVwdGgnID8gJ2RlcHRoJyA6IHVkLmZvcm1hdCA9PT0gJ3VpbnQnID8gJ3UzMicgOiB1ZC5mb3JtYXQgPT09ICdzaW50JyA/ICdpMzInIDogJ2YzMic7XG5cbiAgICAgIGlmICh1ZC5zdG9yYWdlQWNjZXNzKSB7XG4gICAgICAgIHRoaXMuX3NoYWRlclByZWZpeCArPSBgW1tncm91cCgke19ncm91cElkfSksIGJpbmRpbmcoJHtiaW5kaW5nSWR9KV1dIHZhciAke3VkLm5hbWV9OiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8JHt1ZC5zdG9yYWdlRm9ybWF0IHx8ICdyZ2JhOHVub3JtJ30sICR7dWQuc3RvcmFnZUFjY2Vzcy5yZXBsYWNlKCctb25seScsICcnKX0+O1xcbmBcbiAgICAgIH0gZWxzZSBpZiAoaXNDdWJlKSB7XG4gICAgICAgIHRoaXMuX3NoYWRlclByZWZpeCArPSBgW1tncm91cCgke19ncm91cElkfSksIGJpbmRpbmcoJHtiaW5kaW5nSWR9KV1dIHZhciAke3VkLm5hbWV9OiB0ZXh0dXJlX2N1YmU8JHt0ZXhGb3JtYXR9PjtcXG5gXG4gICAgICB9IGVsc2UgaWYgKCh1ZC5kZWZhdWx0VmFsdWUgYXMgVGV4dHVyZSkuaXNBcnJheSkge1xuICAgICAgICB0aGlzLl9zaGFkZXJQcmVmaXggKz0gYFtbZ3JvdXAoJHtfZ3JvdXBJZH0pLCBiaW5kaW5nKCR7YmluZGluZ0lkfSldXSB2YXIgJHt1ZC5uYW1lfTogdGV4dHVyZV8yZF9hcnJheTwke3RleEZvcm1hdH0+O1xcbmBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NoYWRlclByZWZpeCArPSBgW1tncm91cCgke19ncm91cElkfSksIGJpbmRpbmcoJHtiaW5kaW5nSWR9KV1dIHZhciAke3VkLm5hbWV9OiB0ZXh0dXJlXzJkPCR7dGV4Rm9ybWF0fT47XFxuYFxuICAgICAgfVxuICAgICAgYmluZGluZ0lkICs9IDE7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0pO1xuXG4gICAgX3VuaWZvcm1EZXNjLnNhbXBsZXJzICYmIF91bmlmb3JtRGVzYy5zYW1wbGVycy5mb3JFYWNoKCh1ZCkgPT4ge1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgYmluZGluZzogYmluZGluZ0lkLFxuICAgICAgICB2aXNpYmlsaXR5LFxuICAgICAgICBzYW1wbGVyOiB7dHlwZTogJ2ZpbHRlcmluZyd9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXSA9IHtcbiAgICAgICAgYmluZGluZ0lkLCBpbmRleCwgdHlwZTogJ3NhbXBsZXInLFxuICAgICAgICBkZWZhdWx0R3B1VmFsdWU6IGRldmljZS5jcmVhdGVTYW1wbGVyKHVkLmRlZmF1bHRWYWx1ZSBhcyBHUFVTYW1wbGVyRGVzY3JpcHRvcilcbiAgICAgIH07XG4gICAgICB0aGlzLl9zaGFkZXJQcmVmaXggKz0gYFtbZ3JvdXAoJHtfZ3JvdXBJZH0pLCBiaW5kaW5nKCR7YmluZGluZ0lkfSldXSB2YXIgJHt1ZC5uYW1lfTogc2FtcGxlcjtcXG5gXG4gICAgICBiaW5kaW5nSWQgKz0gMTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfSk7XG4gICAgdGhpcy5fc2hhZGVyUHJlZml4ICs9ICdcXG4nO1xuXG4gICAgX3VuaWZvcm1EZXNjLnVuaWZvcm1zLmZvckVhY2goKHVkLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zQnVmZmVyRGVmYXVsdC5zZXQobmV3IFVpbnQzMkFycmF5KChpbmZvLmRlZmF1bHRWYWx1ZSBhcyBUVW5pZm9ybVR5cGVkQXJyYXkpLmJ1ZmZlciksIGluZm8ub2Zmc2V0KTtcbiAgICB9KTtcblxuICAgIGlmIChfdW5pZm9ybURlc2Muc3RvcmFnZXMpIHtcbiAgICAgIGNvbnN0IHN0cnVjdENhY2hlOiB7W2hhc2g6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcblxuICAgICAgX3VuaWZvcm1EZXNjLnN0b3JhZ2VzLmZvckVhY2goKHVkKSA9PiB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgYmluZGluZzogYmluZGluZ0lkLFxuICAgICAgICAgIHZpc2liaWxpdHksXG4gICAgICAgICAgYnVmZmVyOiB7dHlwZTogdWQud3JpdGFibGUgPyAnc3RvcmFnZScgOiAncmVhZC1vbmx5LXN0b3JhZ2UnIGFzIEdQVUJ1ZmZlckJpbmRpbmdUeXBlfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgaGFzaCA9IGBTdG9yYWdlJHt1ZC50eXBlfSR7dWQuZm9ybWF0IHx8ICdmMzInfWA7XG4gICAgICAgIGlmICghdWQuY3VzdG9tU3RydWN0ICYmICFzdHJ1Y3RDYWNoZVtoYXNoXSkge1xuICAgICAgICAgIHRoaXMuX3NoYWRlclByZWZpeCArPSAoc3RydWN0Q2FjaGVbaGFzaF0gPSBzdHJ1Y3RDYWNoZVtoYXNoXSB8fCB0aGlzLl9nZXRTdG9yYWdlU3RydWN0KGhhc2gsIHVkLnR5cGUsIHVkLmZvcm1hdCB8fCAnZjMyJykpICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVkLmN1c3RvbVN0cnVjdCkge1xuICAgICAgICAgIGhhc2ggPSB1ZC5jdXN0b21TdHJ1Y3QubmFtZTtcbiAgICAgICAgICB0aGlzLl9zaGFkZXJQcmVmaXggKz0gdWQuY3VzdG9tU3RydWN0LmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3B1VmFsdWUgPSB1ZC5ncHVWYWx1ZSA/IHVkLmdwdVZhbHVlIDogY3JlYXRlR1BVQnVmZmVyKHVkLmRlZmF1bHRWYWx1ZSwgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXSA9IHtiaW5kaW5nSWQsIGluZGV4LCB0eXBlOiAnc3RvcmFnZScsIGRlZmF1bHRWYWx1ZTogdWQuZGVmYXVsdFZhbHVlLCBkZWZhdWx0R3B1VmFsdWU6IGdwdVZhbHVlfTtcbiAgICAgICAgdGhpcy5fc2hhZGVyUHJlZml4ICs9IGBbW2dyb3VwKCR7X2dyb3VwSWR9KSwgYmluZGluZygke2JpbmRpbmdJZH0pXV0gdmFyPHN0b3JhZ2UsICR7dWQud3JpdGFibGUgPyAncmVhZF93cml0ZScgOiAncmVhZCd9PiAke3VkLm5hbWV9OiAke2hhc2h9O1xcbmBcblxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICBiaW5kaW5nSWQgKz0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VuaWZvcm1MYXlvdXREZXNjID0ge2VudHJpZXN9O1xuICAgIHRoaXMuX3VuaWZvcm1MYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHRoaXMuX3VuaWZvcm1MYXlvdXREZXNjKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0UmVhbExheW91dEluZm8oXG4gICAgdHlwZTogXCJudW1iZXJcIiB8IFwidmVjMlwiIHwgXCJ2ZWMzXCIgfCBcInZlYzRcIiB8IFwibWF0MngyXCIgfCBcIm1hdDN4M1wiIHwgXCJtYXQ0eDRcIiB8ICdjdXN0b20nLFxuICAgIHNpemU6IG51bWJlcixcbiAgICBkZWZhdWx0VmFsdWU6IFRVbmlmb3JtVHlwZWRBcnJheSxcbiAgICBjdXN0b20/OiB7bmFtZTogc3RyaW5nLCBsZW46IG51bWJlcn1cbiAgKSB7XG4gICAgaWYgKGN1c3RvbSkge1xuICAgICAgcmV0dXJuIHtvcmlnTGVuOiBjdXN0b20ubGVuLCByZWFsTGVuOiBjdXN0b20ubGVuLCBkZWZhdWx0VmFsdWV9O1xuICAgIH1cblxuICAgIGxldCBvcmlnTGVuOiBudW1iZXI7XG4gICAgbGV0IHJlYWxMZW46IG51bWJlcjtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgb3JpZ0xlbiA9IDE7XG4gICAgICAgIHJlYWxMZW4gPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZlYzInOlxuICAgICAgICBvcmlnTGVuID0gMjtcbiAgICAgICAgcmVhbExlbiA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmVjMyc6XG4gICAgICAgIG9yaWdMZW4gPSAzO1xuICAgICAgICByZWFsTGVuID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2ZWM0JzpcbiAgICAgIGNhc2UgJ21hdDJ4Mic6XG4gICAgICAgIG9yaWdMZW4gPSA0O1xuICAgICAgICByZWFsTGVuID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXQzeDMnOlxuICAgICAgICBvcmlnTGVuID0gOTtcbiAgICAgICAgcmVhbExlbiA9IDEyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21hdDR4NCc6XG4gICAgICAgIG9yaWdMZW4gPSAxNjtcbiAgICAgICAgcmVhbExlbiA9IDE2O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGRlZmF1bHRWYWx1ZS5jb25zdHJ1Y3RvciBhcyBhbnk7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgY29uc3RydWN0b3IocmVhbExlbiAqIHNpemUpIGFzIHR5cGVvZiBkZWZhdWx0VmFsdWU7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2l6ZTsgaW5kZXggKz0gMSkge1xuICAgICAgdmFsdWUuc2V0KGRlZmF1bHRWYWx1ZS5zbGljZShpbmRleCAqIG9yaWdMZW4sIChpbmRleCArIDEpICogb3JpZ0xlbiksIGluZGV4ICogcmVhbExlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdMZW4sXG4gICAgICByZWFsTGVuLFxuICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFN0b3JhZ2VTdHJ1Y3QoXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHR5cGU6ICdudW1iZXInIHwgJ3ZlYzInIHwgJ3ZlYzMnIHwgJ3ZlYzQnLFxuICAgIGZvcm1hdDogJ2YzMicgfCAndTMyJyB8ICdpMzInXG4gICkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGBbW2Jsb2NrXV0gc3RydWN0ICR7aGFzaH0geyB2YWx1ZTogYXJyYXk8JHtmb3JtYXR9PjsgfTtgXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd2ZWMyJyB8fCB0eXBlID09PSAndmVjMycgfHwgdHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICByZXR1cm4gYFtbYmxvY2tdXSBzdHJ1Y3QgJHtoYXNofSB7IHZhbHVlOiBhcnJheTwke3R5cGV9PCR7Zm9ybWF0fT4+OyB9O2BcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0IHR5cGUhJyk7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlVW5pZm9ybUJsb2NrKCk6IElVbmlmb3JtQmxvY2sge1xuICAgIGNvbnN0IHtfdW5pZm9ybURlc2MsIF91bmlmb3Jtc0luZm8sIF91bmlmb3Jtc0J1ZmZlckRlZmF1bHR9ID0gdGhpcztcbiAgICBjb25zdCB2YWx1ZXM6IElVbmlmb3JtQmxvY2tbJ3ZhbHVlcyddID0ge307XG4gICAgY29uc3QgZ3JvdXBFbnRyaWVzOiBHUFVCaW5kR3JvdXBFbnRyeVtdID0gW107IFxuXG4gICAgbGV0IGNwdUJ1ZmZlcjogVWludDMyQXJyYXk7XG4gICAgbGV0IGdwdUJ1ZmZlcjogR1BVQnVmZmVyO1xuICAgIGlmIChfdW5pZm9ybXNCdWZmZXJEZWZhdWx0KSB7XG4gICAgICBncHVCdWZmZXIgPSBjcmVhdGVHUFVCdWZmZXIoX3VuaWZvcm1zQnVmZmVyRGVmYXVsdCwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7XG4gICAgICBjcHVCdWZmZXIgPSBfdW5pZm9ybXNCdWZmZXJEZWZhdWx0LnNsaWNlKCk7XG4gICAgICBncm91cEVudHJpZXMucHVzaCh7XG4gICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgIHJlc291cmNlOiB7YnVmZmVyOiBncHVCdWZmZXJ9XG4gICAgICB9KTtcbiAgICAgIF91bmlmb3JtRGVzYy51bmlmb3Jtcy5mb3JFYWNoKCh1ZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5fdW5pZm9ybXNJbmZvW3VkLm5hbWVdO1xuICAgICAgICB2YWx1ZXNbdWQubmFtZV0gPSB7XG4gICAgICAgICAgdmFsdWU6IG5ldyAodGhpcy5fdW5pZm9ybXNJbmZvW3VkLm5hbWVdLmRlZmF1bHRWYWx1ZS5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgRmxvYXQzMkFycmF5KShcbiAgICAgICAgICAgIGNwdUJ1ZmZlci5idWZmZXIsIGluZm8ub2Zmc2V0ICogNCwgaW5mby5yZWFsTGVuICogaW5mby5zaXplXG4gICAgICAgICAgKSxcbiAgICAgICAgICBncHVWYWx1ZTogZ3B1QnVmZmVyXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdW5pZm9ybURlc2MudGV4dHVyZXMgJiYgX3VuaWZvcm1EZXNjLnRleHR1cmVzLmZvckVhY2goKHVkKSA9PiB7XG4gICAgICBjb25zdCB2aWV3ID0gX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXS5kZWZhdWx0R3B1VmFsdWU7XG4gICAgICB2YWx1ZXNbdWQubmFtZV0gPSB7dmFsdWU6IHVkLmRlZmF1bHRWYWx1ZSwgZ3B1VmFsdWU6IHZpZXd9O1xuICAgICAgZ3JvdXBFbnRyaWVzLnB1c2goe1xuICAgICAgICBiaW5kaW5nOiBfdW5pZm9ybXNJbmZvW3VkLm5hbWVdLmJpbmRpbmdJZCxcbiAgICAgICAgcmVzb3VyY2U6IHZpZXcgYXMgR1BVVGV4dHVyZVZpZXdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX3VuaWZvcm1EZXNjLnNhbXBsZXJzICYmIF91bmlmb3JtRGVzYy5zYW1wbGVycy5mb3JFYWNoKCh1ZCkgPT4ge1xuICAgICAgY29uc3Qgc2FtcGxlciA9IF91bmlmb3Jtc0luZm9bdWQubmFtZV0uZGVmYXVsdEdwdVZhbHVlO1xuICAgICAgdmFsdWVzW3VkLm5hbWVdID0ge3ZhbHVlOiB1ZC5kZWZhdWx0VmFsdWUsIGdwdVZhbHVlOiBzYW1wbGVyfTtcbiAgICAgIGdyb3VwRW50cmllcy5wdXNoKHtcbiAgICAgICAgYmluZGluZzogX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXS5iaW5kaW5nSWQsXG4gICAgICAgIHJlc291cmNlOiBzYW1wbGVyIGFzIEdQVVNhbXBsZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX3VuaWZvcm1EZXNjLnN0b3JhZ2VzICYmIF91bmlmb3JtRGVzYy5zdG9yYWdlcy5mb3JFYWNoKCh1ZCkgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyID0gX3VuaWZvcm1zSW5mb1t1ZC5uYW1lXS5kZWZhdWx0R3B1VmFsdWUgYXMgR1BVQnVmZmVyO1xuICAgICAgdmFsdWVzW3VkLm5hbWVdID0ge3ZhbHVlOiB1ZC5kZWZhdWx0VmFsdWUsIGdwdVZhbHVlOiBidWZmZXJ9O1xuICAgICAgZ3JvdXBFbnRyaWVzLnB1c2goe1xuICAgICAgICBiaW5kaW5nOiBfdW5pZm9ybXNJbmZvW3VkLm5hbWVdLmJpbmRpbmdJZCxcbiAgICAgICAgcmVzb3VyY2U6IHtidWZmZXJ9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7ZW50cmllczogZ3JvdXBFbnRyaWVzLCB2YWx1ZXMsIGxheW91dDogdGhpcy5fdW5pZm9ybUxheW91dCwgY3B1QnVmZmVyLCBncHVCdWZmZXIsIGlzQnVmZmVyRGlydHk6IGZhbHNlLCBpc0RpcnR5OiB0cnVlfTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRVbmlmb3JtKHViOiBJVW5pZm9ybUJsb2NrLCBuYW1lOiBzdHJpbmcsIHZhbHVlOiBUVW5pZm9ybVZhbHVlLCBydFN1Yk5hbWVPckdQVUJ1ZmZlcj86IHN0cmluZyB8IEdQVUJ1ZmZlcikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLl91bmlmb3Jtc0luZm9bbmFtZV07XG5cbiAgICBpZiAoIWluZm8gfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtlbnRyaWVzfSA9IHViO1xuICAgIGNvbnN0IHtiaW5kaW5nSWQsIHR5cGUsIG9mZnNldCwgcmVhbExlbiwgb3JpZ0xlbn0gPSBpbmZvO1xuICAgIGNvbnN0IHZhbHVlcyA9IHViLnZhbHVlc1tuYW1lXTtcblxuICAgIGlmICh0eXBlID09PSAnYnVmZmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSBhcyBUVW5pZm9ybVR5cGVkQXJyYXk7XG4gICAgICBjb25zdCBjcHVWYWx1ZSA9IHZhbHVlcy52YWx1ZSBhcyBUVW5pZm9ybVR5cGVkQXJyYXk7XG4gICAgICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gW3ZhbHVlXSA6IHZhbHVlKSBhcyBVaW50MzJBcnJheTtcbiAgICAgIGlmIChvcmlnTGVuICE9PSByZWFsTGVuKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5sZW5ndGggLyBvcmlnTGVuO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzaXplOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgY3B1VmFsdWUuc2V0KFxuICAgICAgICAgICAgdmFsdWUuc2xpY2Uob3JpZ0xlbiAqIGluZGV4LCBvcmlnTGVuICogKGluZGV4ICsgMSkpLFxuICAgICAgICAgICAgcmVhbExlbiAqIGluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3B1VmFsdWUuc2V0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHViLmlzQnVmZmVyRGlydHkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3NhbXBsZXInKSB7XG4gICAgICB2YWx1ZXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkIScpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0b3JhZ2UnKSB7XG4gICAgICB2YWx1ZXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIChlbnRyaWVzW2JpbmRpbmdJZF0ucmVzb3VyY2UgYXMge2J1ZmZlcjogR1BVQnVmZmVyfSkuYnVmZmVyID0gdmFsdWVzLmdwdVZhbHVlID0gcnRTdWJOYW1lT3JHUFVCdWZmZXJcbiAgICAgICAgPyBydFN1Yk5hbWVPckdQVUJ1ZmZlciBhcyBHUFVCdWZmZXJcbiAgICAgICAgOiBjcmVhdGVHUFVCdWZmZXIodmFsdWUgYXMgVFVuaWZvcm1UeXBlZEFycmF5LCBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKTtcbiAgICAgICAgdWIuaXNEaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChSZW5kZXJUZXh0dXJlLklTKHZhbHVlKSkge1xuICAgICAgY29uc3QgdmlldyA9IHJ0U3ViTmFtZU9yR1BVQnVmZmVyID8gdmFsdWUuZ2V0Q29sb3JWaWV3QnlOYW1lKHJ0U3ViTmFtZU9yR1BVQnVmZmVyIGFzIHN0cmluZyk6IHZhbHVlLmNvbG9yVmlldztcblxuICAgICAgZW50cmllc1tiaW5kaW5nSWRdLnJlc291cmNlID0gdmFsdWVzLmdwdVZhbHVlID0gdmlldztcbiAgICAgIHZhbHVlcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdWIuaXNEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlICB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIGFzIFRleHR1cmU7XG4gICAgICBpZiAodmFsdWUuaXNBcnJheSAhPT0gKHZhbHVlcy52YWx1ZSBhcyBUZXh0dXJlKS5pc0FycmF5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZSB0ZXh0dXJlMmQgYXJyYXkhJyk7XG4gICAgICB9XG5cbiAgICAgIGVudHJpZXNbYmluZGluZ0lkXS5yZXNvdXJjZSA9IHZhbHVlcy5ncHVWYWx1ZSA9IHZhbHVlLnZpZXc7XG4gICAgICB2YWx1ZXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHViLmlzRGlydHkgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRVbmlmb3JtKHViOiBJVW5pZm9ybUJsb2NrLCBuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdWIudmFsdWVzW25hbWVdPy52YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRCaW5kaW5nR3JvdXAodWI6IElVbmlmb3JtQmxvY2ssIHByZUdyb3VwOiBHUFVCaW5kR3JvdXApIHtcbiAgICBpZiAodWIuaXNCdWZmZXJEaXJ0eSkge1xuICAgICAgcmVuZGVyRW52LmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgdWIuZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdWIuY3B1QnVmZmVyXG4gICAgICApO1xuXG4gICAgICB1Yi5pc0J1ZmZlckRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHViLmlzRGlydHkpIHtcbiAgICAgIHByZUdyb3VwID0gcmVuZGVyRW52LmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYXlvdXQ6IHViLmxheW91dCxcbiAgICAgICAgZW50cmllczogdWIuZW50cmllc1xuICAgICAgfSk7XG4gICAgICB1Yi5pc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZUdyb3VwO1xuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/core/renderEnv.ts":
/*!*******************************!*\
  !*** ./src/core/renderEnv.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderEnv = void 0;
var RenderEnv = (function () {
    function RenderEnv() {
        this.isRenderEnv = true;
        this._swapChainFormat = 'bgra8unorm';
    }
    Object.defineProperty(RenderEnv.prototype, "canvas", {
        get: function () {
            return this._canvas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "ctx", {
        get: function () {
            return this._ctx;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "device", {
        get: function () {
            return this._device;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "bindingGroup", {
        get: function () {
            this._bindingGroup = this._ubTemplate.getBindingGroup(this._uniformBlock, this._bindingGroup);
            return this._bindingGroup;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "shaderPrefix", {
        get: function () {
            return this._ubTemplate.shaderPrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "uniformLayout", {
        get: function () {
            return this._ubTemplate.uniformLayout;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "width", {
        get: function () {
            return this._canvas.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "height", {
        get: function () {
            return this._canvas.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "swapChainFormat", {
        get: function () {
            return this._swapChainFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderEnv.prototype, "currentTexture", {
        get: function () {
            return this._ctx.getCurrentTexture();
        },
        enumerable: false,
        configurable: true
    });
    RenderEnv.prototype.init = function (canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var adapter, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!navigator.gpu) {
                            throw new Error('WebGPU is not supported!');
                        }
                        return [4, navigator.gpu.requestAdapter()];
                    case 1:
                        adapter = _b.sent();
                        if (!adapter) {
                            throw new Error('Require adapter failed!');
                        }
                        _a = this;
                        return [4, adapter.requestDevice()];
                    case 2:
                        _a._device = _b.sent();
                        if (!this._device) {
                            throw new Error('Require device failed!');
                        }
                        this._canvas = canvas;
                        this._ctx = (canvas.getContext('webgpu') || canvas.getContext('gpupresent'));
                        this._ctx.configure({
                            device: this._device,
                            format: this._swapChainFormat,
                        });
                        return [2];
                }
            });
        });
    };
    RenderEnv.prototype.createGlobal = function (ubTemplate) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._ubTemplate = ubTemplate;
                this._uniformBlock = this._ubTemplate.createUniformBlock();
                return [2];
            });
        });
    };
    RenderEnv.prototype.setUniform = function (name, value, rtSubNameOrGPUBuffer) {
        this._ubTemplate.setUniform(this._uniformBlock, name, value, rtSubNameOrGPUBuffer);
    };
    RenderEnv.prototype.getUniform = function (name) {
        return this._ubTemplate.getUniform(this._uniformBlock, name);
    };
    RenderEnv.CLASS_NAME = 'RenderEnv';
    return RenderEnv;
}());
exports.RenderEnv = RenderEnv;
var renderEnv = new RenderEnv();
exports["default"] = renderEnv;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyRW52LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmVuZGVyRW52LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVVBO0lBQUE7UUFFUyxnQkFBVyxHQUFZLElBQUksQ0FBQztRQUszQixxQkFBZ0IsR0FBcUIsWUFBWSxDQUFDO0lBb0Y1RCxDQUFDO0lBL0VDLHNCQUFJLDZCQUFNO2FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSwwQkFBRzthQUFQO1lBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ25CLENBQUM7OztPQUFBO0lBRUQsc0JBQUksNkJBQU07YUFBVjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLG1DQUFZO2FBQWhCO1lBQ0UsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUM5RixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7UUFDNUIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxtQ0FBWTthQUFoQjtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUM7UUFDdkMsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxvQ0FBYTthQUFqQjtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7UUFDeEMsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSw0QkFBSzthQUFUO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUM1QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDZCQUFNO2FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQzdCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksc0NBQWU7YUFBbkI7WUFDRSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztRQUMvQixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHFDQUFjO2FBQWxCO1lBQ0UsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDdkMsQ0FBQzs7O09BQUE7SUFFWSx3QkFBSSxHQUFqQixVQUFrQixNQUF5Qjs7Ozs7O3dCQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTs0QkFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO3lCQUM3Qzt3QkFFZSxXQUFNLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLEVBQUE7O3dCQUE5QyxPQUFPLEdBQUcsU0FBb0M7d0JBRXBELElBQUksQ0FBQyxPQUFPLEVBQUU7NEJBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO3lCQUM1Qzt3QkFFRCxLQUFBLElBQUksQ0FBQTt3QkFBVyxXQUFNLE9BQU8sQ0FBQyxhQUFhLEVBQUUsRUFBQTs7d0JBQTVDLEdBQUssT0FBTyxHQUFHLFNBQTZCLENBQUM7d0JBRTdDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFOzRCQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7eUJBQzNDO3dCQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO3dCQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQVEsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFxQixDQUFDO3dCQUV4RyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQzs0QkFDbEIsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPOzRCQUNwQixNQUFNLEVBQUUsSUFBSSxDQUFDLGdCQUFnQjt5QkFDOUIsQ0FBQyxDQUFDOzs7OztLQUNKO0lBRVksZ0NBQVksR0FBekIsVUFBMEIsVUFBc0I7OztnQkFDOUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDOzs7O0tBQzVEO0lBRU0sOEJBQVUsR0FBakIsVUFBa0IsSUFBWSxFQUFFLEtBQW9CLEVBQUUsb0JBQXlDO1FBQzdGLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFTSw4QkFBVSxHQUFqQixVQUFrQixJQUFZO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBekZjLG9CQUFVLEdBQVcsV0FBVyxDQUFDO0lBMEZsRCxnQkFBQztDQUFBLEFBM0ZELElBMkZDO0FBM0ZZLDhCQUFTO0FBNkZ0QixJQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDO0FBQ2xDLGtCQUFlLFNBQVMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IHJlbmRlckVudi50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiAyMDIxLzYvNuS4i+WNiDg6NTk6MDVcbiAqL1xuZGVjbGFyZSB0eXBlIFVCVGVtcGxhdGUgPSBpbXBvcnQoJy4vVUJUZW1wbGF0ZScpLmRlZmF1bHQ7XG5kZWNsYXJlIHR5cGUgSVVuaWZvcm1CbG9jayA9IGltcG9ydCgnLi9VQlRlbXBsYXRlJykuSVVuaWZvcm1CbG9jaztcbmRlY2xhcmUgdHlwZSBUVW5pZm9ybVZhbHVlID0gaW1wb3J0KCcuL1VCVGVtcGxhdGUnKS5UVW5pZm9ybVZhbHVlO1xuXG5leHBvcnQgY2xhc3MgUmVuZGVyRW52IHtcbiAgcHVibGljIHN0YXRpYyAgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ1JlbmRlckVudic7XG4gIHB1YmxpYyBpc1JlbmRlckVudjogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfZGV2aWNlOiBHUFVEZXZpY2U7XG4gIHByaXZhdGUgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIHByaXZhdGUgX2N0eDogR1BVQ2FudmFzQ29udGV4dDtcbiAgcHJpdmF0ZSBfc3dhcENoYWluRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0ID0gJ2JncmE4dW5vcm0nO1xuICBwcml2YXRlIF91YlRlbXBsYXRlOiBVQlRlbXBsYXRlO1xuICBwcml2YXRlIF91bmlmb3JtQmxvY2s6IElVbmlmb3JtQmxvY2s7XG4gIHByaXZhdGUgX2JpbmRpbmdHcm91cDogR1BVQmluZEdyb3VwO1xuXG4gIGdldCBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfVxuXG4gIGdldCBjdHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgfVxuXG4gIGdldCBkZXZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldmljZTtcbiAgfVxuXG4gIGdldCBiaW5kaW5nR3JvdXAoKSB7XG4gICAgdGhpcy5fYmluZGluZ0dyb3VwID0gdGhpcy5fdWJUZW1wbGF0ZS5nZXRCaW5kaW5nR3JvdXAodGhpcy5fdW5pZm9ybUJsb2NrLCB0aGlzLl9iaW5kaW5nR3JvdXApO1xuICAgIHJldHVybiB0aGlzLl9iaW5kaW5nR3JvdXA7XG4gIH1cblxuICBnZXQgc2hhZGVyUHJlZml4KCkge1xuICAgIHJldHVybiB0aGlzLl91YlRlbXBsYXRlLnNoYWRlclByZWZpeDtcbiAgfVxuXG4gIGdldCB1bmlmb3JtTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl91YlRlbXBsYXRlLnVuaWZvcm1MYXlvdXQ7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG4gIH1cblxuICBnZXQgc3dhcENoYWluRm9ybWF0KCk6IEdQVVRleHR1cmVGb3JtYXQge1xuICAgIHJldHVybiB0aGlzLl9zd2FwQ2hhaW5Gb3JtYXQ7XG4gIH1cblxuICBnZXQgY3VycmVudFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eC5nZXRDdXJyZW50VGV4dHVyZSgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgIGlmICghbmF2aWdhdG9yLmdwdSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO1xuXG4gICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmUgYWRhcHRlciBmYWlsZWQhJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCk7XG5cbiAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlIGRldmljZSBmYWlsZWQhJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuX2N0eCA9IChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ3B1JykgYXMgYW55IHx8IGNhbnZhcy5nZXRDb250ZXh0KCdncHVwcmVzZW50JykpIGFzIEdQVUNhbnZhc0NvbnRleHQ7XG5cbiAgICB0aGlzLl9jdHguY29uZmlndXJlKHtcbiAgICAgIGRldmljZTogdGhpcy5fZGV2aWNlLFxuICAgICAgZm9ybWF0OiB0aGlzLl9zd2FwQ2hhaW5Gb3JtYXQsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlR2xvYmFsKHViVGVtcGxhdGU6IFVCVGVtcGxhdGUpIHtcbiAgICB0aGlzLl91YlRlbXBsYXRlID0gdWJUZW1wbGF0ZTtcbiAgICB0aGlzLl91bmlmb3JtQmxvY2sgPSB0aGlzLl91YlRlbXBsYXRlLmNyZWF0ZVVuaWZvcm1CbG9jaygpO1xuICB9XG5cbiAgcHVibGljIHNldFVuaWZvcm0obmFtZTogc3RyaW5nLCB2YWx1ZTogVFVuaWZvcm1WYWx1ZSwgcnRTdWJOYW1lT3JHUFVCdWZmZXI/OiBzdHJpbmcgfCBHUFVCdWZmZXIpIHtcbiAgICB0aGlzLl91YlRlbXBsYXRlLnNldFVuaWZvcm0odGhpcy5fdW5pZm9ybUJsb2NrLCBuYW1lLCB2YWx1ZSwgcnRTdWJOYW1lT3JHUFVCdWZmZXIpO1xuICB9XG5cbiAgcHVibGljIGdldFVuaWZvcm0obmFtZTogc3RyaW5nKTogVFVuaWZvcm1WYWx1ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3ViVGVtcGxhdGUuZ2V0VW5pZm9ybSh0aGlzLl91bmlmb3JtQmxvY2ssIG5hbWUpO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlckVudiA9IG5ldyBSZW5kZXJFbnYoKTtcbmV4cG9ydCBkZWZhdWx0IHJlbmRlckVudjtcbiJdfQ==

/***/ }),

/***/ "./src/core/shared.ts":
/*!****************************!*\
  !*** ./src/core/shared.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.genGaussianParams = exports.nthElement = exports.partition = exports.logCanvas = exports.hashCode = exports.createGPUBufferBySize = exports.createGPUBuffer = exports.copyTypedArray = exports.callWithProfile = exports.isArray = exports.isTextureSourceArray = void 0;
var renderEnv_1 = __webpack_require__(/*! ./renderEnv */ "./src/core/renderEnv.ts");
function isTextureSourceArray(value) {
    return !!value.push;
}
exports.isTextureSourceArray = isTextureSourceArray;
function isArray(value) {
    return !!value.push;
}
exports.isArray = isArray;
function callWithProfile(name, fn, args) {
    var t = performance.now();
    fn.apply(void 0, args);
    console.log("Ray Tracing, " + name + ": " + (performance.now() - t) / 1000 + "(s)");
}
exports.callWithProfile = callWithProfile;
function copyTypedArray(size, dst, dstOffset, src, srcOffset) {
    for (var index = 0; index < size; index += 1) {
        dst[dstOffset + index] = src[srcOffset + index];
    }
}
exports.copyTypedArray = copyTypedArray;
function createGPUBuffer(array, usage) {
    var size = array.byteLength + (4 - array.byteLength % 4);
    var buffer = renderEnv_1.default.device.createBuffer({
        size: size,
        usage: usage | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
    });
    var view = new array.constructor(buffer.getMappedRange(0, size));
    view.set(array, 0);
    buffer.unmap();
    return buffer;
}
exports.createGPUBuffer = createGPUBuffer;
function createGPUBufferBySize(size, usage) {
    var buffer = renderEnv_1.default.device.createBuffer({
        size: size,
        usage: usage | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
    });
    buffer.unmap();
    return buffer;
}
exports.createGPUBufferBySize = createGPUBufferBySize;
exports.hashCode = function (s) { return s.split('').reduce(function (a, b) { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0); };
function logCanvas(canvas, width) {
    var height = width * canvas.height / canvas.width;
    var url = canvas.toDataURL();
    console.log('%c+', "font-size: 1px; padding: " + height / 2 + "px " + width / 2 + "px; line-height: " + height + "px; background: url(" + url + "); background-size: " + width + "px " + height + "px; background-repeat: no-repeat; color: transparent;");
}
exports.logCanvas = logCanvas;
function partition(array, compare, left, right) {
    if (left === void 0) { left = 0; }
    if (right === void 0) { right = array.length; }
    while (left !== right) {
        while (compare(array[left])) {
            left += 1;
            if (left === right) {
                return left;
            }
        }
        do {
            right -= 1;
            if (left === right) {
                return left;
            }
        } while (!compare(array[right]));
        swap(array, left, right);
        left += 1;
    }
    return left;
}
exports.partition = partition;
function nthElement(array, compare, left, right, k) {
    if (left === void 0) { left = 0; }
    if (right === void 0) { right = array.length; }
    if (k === void 0) { k = Math.floor((left + right) / 2); }
    for (var i = left; i <= k; i += 1) {
        var minIndex = i;
        var minValue = array[i];
        for (var j = i + 1; j < right; j += 1) {
            if (!compare(minValue, array[j])) {
                minIndex = j;
                minValue = array[j];
                swap(array, i, minIndex);
            }
        }
    }
}
exports.nthElement = nthElement;
function swap(array, a, b) {
    var x = array[b];
    array[b] = array[a];
    array[a] = x;
}
function genGaussianParams(sigmas, dims) {
    var res = new Float32Array(sigmas.length * 2);
    for (var i = 0; i < sigmas.length; i += 1) {
        var s = sigmas[i];
        res[i * 2] = Math.pow(1 / (Math.sqrt(2 * Math.PI) * s), dims[i]);
        res[i * 2 + 1] = -1 / (2 * s * s);
    }
    return res;
}
exports.genGaussianParams = genGaussianParams;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2hhcmVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQU1BLHlDQUFvQztBQVFwQyxTQUFnQixvQkFBb0IsQ0FBQyxLQUF3QztJQUMzRSxPQUFPLENBQUMsQ0FBRSxLQUEwQixDQUFDLElBQUksQ0FBQztBQUM1QyxDQUFDO0FBRkQsb0RBRUM7QUFFRCxTQUFnQixPQUFPLENBQUksS0FBYztJQUN2QyxPQUFPLENBQUMsQ0FBRSxLQUFhLENBQUMsSUFBSSxDQUFDO0FBQy9CLENBQUM7QUFGRCwwQkFFQztBQUVELFNBQWdCLGVBQWUsQ0FBbUMsSUFBWSxFQUFFLEVBQU0sRUFBRSxJQUFvQjtJQUMxRyxJQUFNLENBQUMsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDNUIsRUFBRSxlQUFJLElBQUksRUFBRTtJQUNaLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWdCLElBQUksVUFBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLFFBQUssQ0FBQyxDQUFDO0FBQzVFLENBQUM7QUFKRCwwQ0FJQztBQUVELFNBQWdCLGNBQWMsQ0FDNUIsSUFBWSxFQUNaLEdBQWdCLEVBQUUsU0FBaUIsRUFDbkMsR0FBMkIsRUFBRSxTQUFpQjtJQUU5QyxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUU7UUFDNUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDO0tBQ2pEO0FBQ0gsQ0FBQztBQVJELHdDQVFDO0FBRUQsU0FBZ0IsZUFBZSxDQUFDLEtBQWtCLEVBQUUsS0FBMEI7SUFDNUUsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsVUFB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QUFpQixDQUFDLE1BQW9CLEVBQUUsSUFBYztJQUNwRSxJQUFNLEdBQUcsR0FBRyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRWhELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDakQsSUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ25DO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBVkQsOENBVUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBzaGFyZWQudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzbkuIvljYg4OjQwOjQ2XG4gKi9cbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9yZW5kZXJFbnYnO1xuXG5leHBvcnQgdHlwZSBUVHlwZWRBcnJheSA9IEZsb2F0MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50OEFycmF5IHwgSW50MzJBcnJheSB8IEludDE2QXJyYXk7XG5cbmV4cG9ydCB0eXBlIFRVbmlmb3JtVHlwZWRBcnJheSA9IEZsb2F0MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50MzJBcnJheTtcblxuZXhwb3J0IHR5cGUgVFRleHR1cmVTb3VyY2UgPSBJbWFnZUJpdG1hcCB8IEFycmF5QnVmZmVyO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0dXJlU291cmNlQXJyYXkodmFsdWU6IFRUZXh0dXJlU291cmNlIHwgVFRleHR1cmVTb3VyY2VbXSk6IHZhbHVlIGlzIFRUZXh0dXJlU291cmNlW10ge1xuICByZXR1cm4gISEodmFsdWUgYXMgVFRleHR1cmVTb3VyY2VbXSkucHVzaDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXk8VD4odmFsdWU6IFQgfCBUW10pOiB2YWx1ZSBpcyBBcnJheTxUPiB7XG4gIHJldHVybiAhISh2YWx1ZSBhcyBUW10pLnB1c2g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsV2l0aFByb2ZpbGU8Rk4gZXh0ZW5kcyAoLi4uYXJnczogYW55KSA9PiBhbnk+KG5hbWU6IHN0cmluZywgZm46IEZOLCBhcmdzOiBQYXJhbWV0ZXJzPEZOPikge1xuICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGZuKC4uLmFyZ3MpO1xuICBjb25zb2xlLmxvZyhgUmF5IFRyYWNpbmcsICR7bmFtZX06ICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gdCkgLyAxMDAwfShzKWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weVR5cGVkQXJyYXkoXG4gIHNpemU6IG51bWJlcixcbiAgZHN0OiBUVHlwZWRBcnJheSwgZHN0T2Zmc2V0OiBudW1iZXIsXG4gIHNyYzogVFR5cGVkQXJyYXkgfCBudW1iZXJbXSwgc3JjT2Zmc2V0OiBudW1iZXJcbikge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2l6ZTsgaW5kZXggKz0gMSkge1xuICAgIGRzdFtkc3RPZmZzZXQgKyBpbmRleF0gPSBzcmNbc3JjT2Zmc2V0ICsgaW5kZXhdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHUFVCdWZmZXIoYXJyYXk6IFRUeXBlZEFycmF5LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2VGbGFncykge1xuICBjb25zdCBzaXplID0gYXJyYXkuYnl0ZUxlbmd0aCArICg0IC0gYXJyYXkuYnl0ZUxlbmd0aCAlIDQpO1xuICBjb25zdCBidWZmZXIgPSByZW5kZXJFbnYuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgc2l6ZSxcbiAgICB1c2FnZTogdXNhZ2UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICBtYXBwZWRBdENyZWF0aW9uOiB0cnVlXG4gIH0pO1xuXG4gIGNvbnN0IHZpZXcgPSBuZXcgKGFycmF5LmNvbnN0cnVjdG9yIGFzIHtuZXcoYnVmZmVyOiBBcnJheUJ1ZmZlcik6IFRUeXBlZEFycmF5fSkoYnVmZmVyLmdldE1hcHBlZFJhbmdlKDAsIHNpemUpKTtcbiAgdmlldy5zZXQoYXJyYXksIDApO1xuXG4gIGJ1ZmZlci51bm1hcCgpO1xuXG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHUFVCdWZmZXJCeVNpemUoc2l6ZTogbnVtYmVyLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2VGbGFncykge1xuICBjb25zdCBidWZmZXIgPSByZW5kZXJFbnYuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICB1c2FnZTogdXNhZ2UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICBtYXBwZWRBdENyZWF0aW9uOiB0cnVlXG4gIH0pO1xuXG4gIGJ1ZmZlci51bm1hcCgpO1xuXG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNoQ29kZSA9IChzOiBzdHJpbmcpID0+IHMuc3BsaXQoJycpLnJlZHVjZSgoYSxiKT0+e2E9KChhPDw1KS1hKStiLmNoYXJDb2RlQXQoMCk7cmV0dXJuIGEmYX0sMClcblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGhlaWdodCA9IHdpZHRoICogY2FudmFzLmhlaWdodCAvIGNhbnZhcy53aWR0aDtcbiAgY29uc3QgdXJsID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuXG4gIC8qdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gIGNvbnNvbGUubG9nKCclYysnLCBgZm9udC1zaXplOiAxcHg7IHBhZGRpbmc6ICR7aGVpZ2h0IC8gMn1weCAke3dpZHRoIC8gMn1weDsgbGluZS1oZWlnaHQ6ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kOiB1cmwoJHt1cmx9KTsgYmFja2dyb3VuZC1zaXplOiAke3dpZHRofXB4ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyBjb2xvcjogdHJhbnNwYXJlbnQ7YCk7XG59XG5cbi8vIFJlb3JkZXJzIHRoZSBlbGVtZW50cyBpbiB0aGUgcmFuZ2UgW2ZpcnN0LCBsYXN0KSBpbiBzdWNoIGEgd2F5IHRoYXRcbi8vIGFsbCBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIGNvbXBhcmF0b3IgYyByZXR1cm5zIHRydWVcbi8vIHByZWNlZGUgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBjb21wYXJhdG9yIGMgcmV0dXJucyBmYWxzZS5cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aXRpb248VD4oXG4gIGFycmF5OiBBcnJheTxUPiwgY29tcGFyZTogKGl0ZW06IFQpID0+IGJvb2xlYW4sXG4gIGxlZnQ6IG51bWJlciA9IDAsIHJpZ2h0OiBudW1iZXIgPSBhcnJheS5sZW5ndGhcbikge1xuICB3aGlsZSAobGVmdCAhPT0gcmlnaHQpIHtcbiAgICB3aGlsZSAoY29tcGFyZShhcnJheVtsZWZ0XSkpIHtcbiAgICAgIGxlZnQgKz0gMTtcbiAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICByaWdodCAtPSAxO1xuICAgICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCFjb21wYXJlKGFycmF5W3JpZ2h0XSkpO1xuXG4gICAgc3dhcChhcnJheSwgbGVmdCwgcmlnaHQpO1xuICAgIGxlZnQgKz0gMTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0O1xufVxuXG4vLyBudGhfZWxlbWVudCBpcyBhIHBhcnRpYWwgc29ydGluZyBhbGdvcml0aG0gdGhhdCByZWFycmFuZ2VzIGVsZW1lbnRzIGluIFtmaXJzdCwgbGFzdCkgc3VjaCB0aGF0OlxuLy8gVGhlIGVsZW1lbnQgcG9pbnRlZCBhdCBieSBudGggaXMgY2hhbmdlZCB0byB3aGF0ZXZlciBlbGVtZW50IHdvdWxkIG9jY3VyIGluIHRoYXQgcG9zaXRpb24gaWYgW2ZpcnN0LCBsYXN0KSB3ZXJlIHNvcnRlZC5cbi8vIEFsbCBvZiB0aGUgZWxlbWVudHMgYmVmb3JlIHRoaXMgbmV3IG50aCBlbGVtZW50IGNvbXBhcmUgdG8gdHJ1ZSB3aXRoIGVsZW1lbnRzIGFmdGVyIHRoZSBudGggZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIG50aEVsZW1lbnQ8VD4oXG4gIGFycmF5OiBBcnJheTxUPiwgY29tcGFyZTogKGE6IFQsIGI6IFQpID0+IGJvb2xlYW4sXG4gIGxlZnQ6IG51bWJlciA9IDAsIHJpZ2h0OiBudW1iZXIgPSBhcnJheS5sZW5ndGgsXG4gIGs6IG51bWJlciA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKVxuKSB7XG4gIGZvciAobGV0IGkgPSBsZWZ0OyBpIDw9IGs7IGkgKz0gMSkge1xuICAgIGxldCBtaW5JbmRleCA9IGk7XG4gICAgbGV0IG1pblZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCByaWdodDsgaiArPSAxKSB7XG4gICAgICBpZiAoIWNvbXBhcmUobWluVmFsdWUsIGFycmF5W2pdKSkge1xuICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICAgIG1pblZhbHVlID0gYXJyYXlbal07XG4gICAgICAgIHN3YXAoYXJyYXksIGksIG1pbkluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3dhcDxUPihhcnJheTogQXJyYXk8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIGNvbnN0IHggPSBhcnJheVtiXTtcbiAgYXJyYXlbYl0gPSBhcnJheVthXTtcbiAgYXJyYXlbYV0gPSB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuR2F1c3NpYW5QYXJhbXMoc2lnbWFzOiBGbG9hdDMyQXJyYXksIGRpbXM6IG51bWJlcltdKTogRmxvYXQzMkFycmF5IHtcbiAgY29uc3QgcmVzID0gbmV3IEZsb2F0MzJBcnJheShzaWdtYXMubGVuZ3RoICogMik7XG5cbiAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHNpZ21hcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHMgPSBzaWdtYXNbaV07XG4gICAgcmVzW2kgKiAyXSA9IE1hdGgucG93KDEgLyAoTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAqIHMpLCBkaW1zW2ldKTtcbiAgICByZXNbaSAqIDIgKyAxXSA9IC0xIC8gKDIgKiBzICogcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuIl19

/***/ }),

/***/ "./src/extension/BVH.ts":
/*!******************************!*\
  !*** ./src/extension/BVH.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bounds = void 0;
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var Geometry_1 = __webpack_require__(/*! ../core/Geometry */ "./src/core/Geometry.ts");
var HObject_1 = __webpack_require__(/*! ../core/HObject */ "./src/core/HObject.ts");
var Material_1 = __webpack_require__(/*! ../core/Material */ "./src/core/Material.ts");
var Mesh_1 = __webpack_require__(/*! ../core/Mesh */ "./src/core/Mesh.ts");
var shared_1 = __webpack_require__(/*! ../core/shared */ "./src/core/shared.ts");
var EAxis;
(function (EAxis) {
    EAxis[EAxis["X"] = 0] = "X";
    EAxis[EAxis["Y"] = 1] = "Y";
    EAxis[EAxis["Z"] = 2] = "Z";
})(EAxis || (EAxis = {}));
;
var Bounds = (function () {
    function Bounds() {
        this._isDirty = false;
    }
    Object.defineProperty(Bounds.prototype, "center", {
        get: function () {
            if (!this._center || this._isDirty) {
                this._updateCenterSize();
            }
            return this._center;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Bounds.prototype, "size", {
        get: function () {
            if (!this._size || this._isDirty) {
                this._updateCenterSize();
            }
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Bounds.prototype, "maxExtends", {
        get: function () {
            var size = this.size;
            if (size[0] > size[2]) {
                return size[0] > size[1] ? EAxis.X : EAxis.Y;
            }
            else {
                return size[1] > size[2] ? EAxis.Z : EAxis.Y;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Bounds.prototype, "surfaceArea", {
        get: function () {
            var size = this.size;
            return 2 * (size[0] * size[2] + size[0] * size[1] + size[2] * size[1]);
        },
        enumerable: false,
        configurable: true
    });
    Bounds.prototype.initEmpty = function () {
        this.max = new Float32Array([-Infinity, -Infinity, -Infinity]);
        this.min = new Float32Array([Infinity, Infinity, Infinity]);
        return this;
    };
    Bounds.prototype.fromVertexes = function (v1, v2, v3) {
        this.max = v1.slice();
        this.min = v1.slice();
        this.update(v2).update(v3);
        return this;
    };
    Bounds.prototype.update = function (v) {
        for (var index = 0; index < 3; index += 1) {
            this.max[index] = Math.max(this.max[index], v[index]);
            this.min[index] = Math.min(this.min[index], v[index]);
        }
        this._isDirty = true;
        return this;
    };
    Bounds.prototype.mergeBounds = function (bounds) {
        var max = bounds.max, min = bounds.min;
        for (var index = 0; index < 3; index += 1) {
            this.max[index] = Math.max(this.max[index], max[index]);
            this.min[index] = Math.min(this.min[index], min[index]);
        }
        this._isDirty = true;
        return this;
    };
    Bounds.prototype.pointIn = function (p) {
        var _a = this, max = _a.max, min = _a.min;
        return p[0] > min[0] && p[0] < max[0]
            && p[1] > min[1] && p[1] < max[1]
            && p[2] > min[2] && p[2] < max[2];
    };
    Bounds.prototype.getOffset = function (axis, v) {
        var offset = v[axis] - this.min[axis];
        if (this.max[axis] > this.min[axis]) {
            offset /= (this.max[axis] - this.min[axis]);
        }
        return offset;
    };
    Bounds.prototype.buildBox = function (mode) {
        var _a = this, max = _a.max, min = _a.min;
        var positions = [];
        Bounds.BUILD_BOX_MAX_MIN_ORDER.forEach(function (order) {
            for (var i = 0; i < 3; i += 1) {
                positions.push(order[i] ? max[i] : min[i]);
            }
        });
        var indexes;
        if (mode === 'lines') {
            indexes = [
                0, 1, 1, 2, 2, 3, 3, 0,
                4, 5, 5, 6, 6, 7, 7, 4,
                0, 4, 1, 5, 2, 6, 3, 7
            ];
        }
        else {
            indexes = [
                0, 1, 2, 2, 3, 0,
                4, 5, 6, 6, 7, 4,
                0, 4, 5, 5, 1, 0,
                1, 5, 6, 6, 2, 1,
                3, 2, 6, 6, 7, 3,
                0, 3, 7, 7, 4, 0
            ];
        }
        return { positions: positions, indexes: indexes };
    };
    Bounds.prototype._updateCenterSize = function () {
        var _this = this;
        if (this._isDirty) {
            this._center = this.max.map(function (m, i) { return (m + _this.min[i]) / 2; });
            this._size = this.max.map(function (m, i) { return m - _this.min[i]; });
            this._isDirty = false;
        }
    };
    Bounds.BUILD_BOX_MAX_MIN_ORDER = [
        [1, 1, 1],
        [1, 1, 0],
        [0, 1, 0],
        [0, 1, 1],
        [1, 0, 1],
        [1, 0, 0],
        [0, 0, 0],
        [0, 0, 1]
    ];
    return Bounds;
}());
exports.Bounds = Bounds;
function isBVHLeaf(value) {
    return value.infoEnd !== undefined;
}
var tmpV1 = new Float32Array(3);
var tmpV2 = new Float32Array(3);
var tmpV3 = new Float32Array(3);
var BVH = (function (_super) {
    __extends(BVH, _super);
    function BVH(_maxPrimitivesPerLeaf) {
        var _this = _super.call(this) || this;
        _this._maxPrimitivesPerLeaf = _maxPrimitivesPerLeaf;
        _this.isBVH = true;
        _this.process = function (worldPositions, indexes) {
            shared_1.callWithProfile('BVH setup bounds info', _this._setupBoundsInfo, [worldPositions, indexes]);
            shared_1.callWithProfile('BVH build tree', _this._buildTree, []);
            shared_1.callWithProfile('BVH flatten', _this._flatten, []);
            _this._debugMesh = null;
        };
        _this._setupBoundsInfo = function (worldPositions, indexes) {
            _this._boundsInfos = [];
            for (var i = 0; i < indexes.length; i += 3) {
                var idxes = indexes.slice(i, i + 3);
                shared_1.copyTypedArray(3, tmpV1, 0, worldPositions, idxes[0] * 4);
                shared_1.copyTypedArray(3, tmpV2, 0, worldPositions, idxes[1] * 4);
                shared_1.copyTypedArray(3, tmpV3, 0, worldPositions, idxes[2] * 4);
                var bounds = new Bounds().fromVertexes(tmpV1, tmpV2, tmpV3);
                _this._boundsInfos.push({ indexes: idxes, bounds: bounds });
            }
        };
        _this._buildTree = function () {
            _this._rootNode = _this._buildRecursive(0, _this._boundsInfos.length, 0);
        };
        _this._flatten = function () {
            _this._bvhLeaves = [];
            _this._bvhNodes = [];
            var flatInfo = { maxDepth: 1, nodes: [], leaves: [] };
            _this._traverseNode(_this._rootNode, flatInfo);
            var maxDepth = flatInfo.maxDepth, nodes = flatInfo.nodes, leaves = flatInfo.leaves;
            var buffer = new ArrayBuffer(4 * (nodes.length + leaves.length));
            var f32View = new Float32Array(buffer);
            var u32View = new Uint32Array(buffer);
            var nodesLen = nodes.length;
            _this._bvhMaxDepth = maxDepth;
            f32View.set(nodes);
            u32View.set(leaves, nodesLen);
            for (var i = 0; i < nodesLen; i += 8) {
                for (var ci = 0; ci < 8; ci += 4) {
                    var offset = i + ci;
                    if (nodes[offset] & 0x80000000) {
                        u32View[offset] = nodes[offset] + nodesLen / 4;
                    }
                    else {
                        u32View[offset] = nodes[offset];
                    }
                }
            }
            _this._bvhMaxDepth = flatInfo.maxDepth;
            _this._bvhBuffer = f32View;
        };
        _this._traverseNode = function (node, info, depth, parentOffset, childIndex) {
            if (depth === void 0) { depth = 1; }
            if (parentOffset === void 0) { parentOffset = -1; }
            if (childIndex === void 0) { childIndex = 0; }
            info.maxDepth = Math.max(depth, info.maxDepth);
            var nodes = info.nodes, leaves = info.leaves;
            var _a = _this, _boundsInfos = _a._boundsInfos, _bvhNodes = _a._bvhNodes, _bvhLeaves = _a._bvhLeaves;
            if (isBVHLeaf(node)) {
                _bvhLeaves.push(node);
                if (parentOffset >= 0) {
                    nodes[parentOffset * 8 + childIndex] = (1 << 31) | (leaves.length / 4);
                }
                var count = node.infoEnd - node.infoStart;
                for (var i = node.infoStart; i < node.infoEnd; i += 1) {
                    var idxes = _boundsInfos[i].indexes;
                    leaves.push(count, idxes[0], idxes[1], idxes[2]);
                }
            }
            else {
                _bvhNodes.push(node);
                var bounds = node.bounds;
                var nodeOffset = nodes.length / 8;
                if (parentOffset >= 0) {
                    nodes[parentOffset * 8 + childIndex] = nodeOffset * 2;
                }
                nodes.push(0, bounds.min[0], bounds.min[1], bounds.min[2], 0, bounds.max[0], bounds.max[1], bounds.max[2]);
                _this._traverseNode(node.child0, info, depth + 1, nodeOffset, 0);
                _this._traverseNode(node.child1, info, depth + 1, nodeOffset, 4);
            }
        };
        return _this;
    }
    Object.defineProperty(BVH.prototype, "maxDepth", {
        get: function () {
            return this._bvhMaxDepth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BVH.prototype, "buffer", {
        get: function () {
            return this._bvhBuffer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BVH.prototype, "debugMesh", {
        get: function () {
            if (!this._debugMesh) {
                this._buildDebugMesh();
            }
            return this._debugMesh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BVH.prototype, "nodesCount", {
        get: function () {
            return this._bvhNodes.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BVH.prototype, "leavesCount", {
        get: function () {
            return this._bvhLeaves.length;
        },
        enumerable: false,
        configurable: true
    });
    BVH.prototype._buildRecursive = function (start, end, depth) {
        var _boundsInfos = this._boundsInfos;
        var bounds = new Bounds().initEmpty();
        for (var i = start; i < end; i += 1) {
            bounds.mergeBounds(_boundsInfos[i].bounds);
        }
        var nPrimitives = end - start;
        if (nPrimitives <= this._maxPrimitivesPerLeaf) {
            return { infoStart: start, infoEnd: end, bounds: bounds };
        }
        else {
            var centroidBounds_1 = new Bounds().initEmpty();
            for (var i = start; i < end; i += 1) {
                centroidBounds_1.update(_boundsInfos[i].bounds.center);
            }
            var dim_1 = centroidBounds_1.maxExtends;
            var mid = Math.floor((start + end) / 2);
            if (nPrimitives <= 4) {
                shared_1.nthElement(_boundsInfos, function (a, b) { return a.bounds.center[dim_1] < b.bounds.center[dim_1]; }, start, end, mid);
            }
            else if (centroidBounds_1.max[dim_1] === centroidBounds_1.min[dim_1]) {
                return { infoStart: start, infoEnd: end, bounds: bounds };
            }
            else {
                var buckets_1 = [];
                for (var i = 0; i < 12; i += 1) {
                    buckets_1.push({ bounds: new Bounds().initEmpty(), count: 0 });
                }
                for (var i = start; i < end; i += 1) {
                    var b = Math.floor(buckets_1.length * centroidBounds_1.getOffset(dim_1, _boundsInfos[i].bounds.center));
                    if (b === buckets_1.length) {
                        b = buckets_1.length - 1;
                    }
                    buckets_1[b].count += 1;
                    buckets_1[b].bounds.mergeBounds(_boundsInfos[i].bounds);
                }
                var cost = [];
                for (var i = 0; i < buckets_1.length - 1; i += 1) {
                    var b0 = new Bounds().initEmpty();
                    var b1 = new Bounds().initEmpty();
                    var count0 = 0;
                    var count1 = 0;
                    for (var j = 0; j <= i; j += 1) {
                        b0.mergeBounds(buckets_1[j].bounds);
                        count0 += buckets_1[j].count;
                    }
                    for (var j = i + 1; j < buckets_1.length; j += 1) {
                        b1.mergeBounds(buckets_1[j].bounds);
                        count1 += buckets_1[j].count;
                    }
                    cost.push(0.1 + (count0 * b0.surfaceArea + count1 * b1.surfaceArea) / bounds.surfaceArea);
                }
                var minCost = cost[0];
                var minCostSplitBucket_1 = 0;
                for (var i = 1; i < cost.length; i += 1) {
                    if (cost[i] < minCost) {
                        minCost = cost[i];
                        minCostSplitBucket_1 = i;
                    }
                }
                mid = shared_1.partition(_boundsInfos, function (p) {
                    var b = Math.floor(buckets_1.length * centroidBounds_1.getOffset(dim_1, p.bounds.center));
                    if (b === buckets_1.length) {
                        b = buckets_1.length - 1;
                    }
                    return b <= minCostSplitBucket_1;
                }, start, end);
            }
            var child0 = this._buildRecursive(start, mid, depth + 1);
            var child1 = this._buildRecursive(mid, end, depth + 1);
            return {
                axis: dim_1,
                bounds: new Bounds().initEmpty().mergeBounds(child0.bounds).mergeBounds(child1.bounds),
                child0: child0,
                child1: child1,
                depth: depth
            };
        }
    };
    BVH.prototype._buildDebugMesh = function () {
        var _a = this, _bvhNodes = _a._bvhNodes, _bvhMaxDepth = _a._bvhMaxDepth;
        var mode = 'lines';
        var nodesLen = _bvhNodes.length;
        var positions = new Float32Array(nodesLen * 8 * 3);
        var colors = new Float32Array(nodesLen * 8 * 3);
        var indexes;
        if (mode === 'lines') {
            indexes = new Uint32Array(nodesLen * 24);
        }
        else {
            indexes = new Uint32Array(nodesLen * 36);
        }
        var toteLDepthCount = new Array(_bvhMaxDepth).fill(0);
        var depthCount = new Array(_bvhMaxDepth).fill(0);
        _bvhNodes.forEach(function (node) {
            toteLDepthCount[node.depth] += 1;
        });
        var index = 0;
        _bvhNodes.forEach(function (node) {
            var box = node.bounds.buildBox(mode);
            var offset = index * 8;
            var pOffset = index * 8 * 3;
            var cOffset = index * 8 * 3;
            var iOffset = index * box.indexes.length;
            var color = hslToRgb(node.depth / _bvhMaxDepth, (depthCount[node.depth] / toteLDepthCount[node.depth]) * 0.7 + 0.3, 0.5);
            for (var ci = 0; ci < 24; ci += 3) {
                colors.set(color, cOffset + ci);
            }
            indexes.set(box.indexes.map(function (v) { return v + offset; }), iOffset);
            positions.set(box.positions, pOffset);
            index += 1;
            depthCount[node.depth] += 1;
        });
        this._debugMesh = new Mesh_1.default(new Geometry_1.default([
            {
                layout: {
                    attributes: [{
                            name: 'position',
                            shaderLocation: 0,
                            format: 'float32x3',
                            offset: 0
                        }],
                    arrayStride: 12
                },
                data: positions
            },
            {
                layout: {
                    attributes: [{
                            name: 'color_0',
                            shaderLocation: 1,
                            format: 'float32x3',
                            offset: 0
                        }],
                    arrayStride: 12
                },
                data: colors
            }
        ], indexes, indexes.length), new Material_1.default(buildin_1.buildinEffects.rColor, { u_color: new Float32Array([1, 1, 1, .4]) }, undefined, {
            primitiveType: mode === 'lines' ? 'line-list' : 'triangle-list',
            cullMode: 'none',
            blendColor: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha'
            },
            blendAlpha: {
                srcFactor: 'zero',
                dstFactor: 'one'
            }
        }));
    };
    BVH.CLASS_NAME = 'BVH';
    return BVH;
}(HObject_1.default));
exports["default"] = BVH;
function hue2rgb(p, q, t) {
    if (t < 0)
        t += 1;
    if (t > 1)
        t -= 1;
    if (t < 1 / 6)
        return p + (q - p) * 6 * t;
    if (t < 1 / 2)
        return q;
    if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}
function hslToRgb(h, s, l) {
    var r, g, b;
    if (s == 0) {
        r = g = b = l;
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return [r, g, b];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQlZILmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQlZILnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSxzQ0FBNEM7QUFDNUMsNkNBQXdDO0FBQ3hDLDJDQUFzQztBQUN0Qyw2Q0FBd0M7QUFDeEMscUNBQWdDO0FBQ2hDLHlDQUF3RjtBQUV4RixJQUFLLEtBSUo7QUFKRCxXQUFLLEtBQUs7SUFDUiwyQkFBQyxDQUFBO0lBQ0QsMkJBQUMsQ0FBQTtJQUNELDJCQUFDLENBQUE7QUFDSCxDQUFDLEVBSkksS0FBSyxLQUFMLEtBQUssUUFJVDtBQUFBLENBQUM7QUFFRjtJQUFBO1FBZ0JVLGFBQVEsR0FBWSxLQUFLLENBQUM7SUFnSXBDLENBQUM7SUE1SEMsc0JBQUksMEJBQU07YUFBVjtZQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2FBQzFCO1lBRUQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksd0JBQUk7YUFBUjtZQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2FBQzFCO1lBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksOEJBQVU7YUFBZDtZQUNFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyQixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMs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Q0FBQyxDQUFDO0lBQ3JCLElBQUcsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDO1FBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvQyxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7SUFDL0MsSUFBSSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsQ0FBQztJQUVwQyxJQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7UUFDUixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDZjtTQUFNO1FBQ0wsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQEZpbGUgICA6IEJWSC50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiA2LzE1LzIwMjEsIDExOjE0OjUxIFBNXG4gKi9cbmltcG9ydCB7IGJ1aWxkaW5FZmZlY3RzIH0gZnJvbSAnLi4vYnVpbGRpbic7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi4vY29yZS9HZW9tZXRyeSc7XG5pbXBvcnQgSE9iamVjdCBmcm9tICcuLi9jb3JlL0hPYmplY3QnO1xuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4uL2NvcmUvTWF0ZXJpYWwnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vY29yZS9NZXNoJztcbmltcG9ydCB7IGNhbGxXaXRoUHJvZmlsZSwgY29weVR5cGVkQXJyYXksIG50aEVsZW1lbnQsIHBhcnRpdGlvbiB9IGZyb20gJy4uL2NvcmUvc2hhcmVkJztcblxuZW51bSBFQXhpcyB7XG4gIFgsXG4gIFksXG4gIFpcbn07XG5cbmV4cG9ydCBjbGFzcyBCb3VuZHMge1xuICBwdWJsaWMgc3RhdGljIEJVSUxEX0JPWF9NQVhfTUlOX09SREVSID0gW1xuICAgIC8vIDAgaXMgbWluLCBpIGlzIG1heFxuICAgIFsxLCAxLCAxXSxcbiAgICBbMSwgMSwgMF0sXG4gICAgWzAsIDEsIDBdLFxuICAgIFswLCAxLCAxXSxcbiAgICBbMSwgMCwgMV0sXG4gICAgWzEsIDAsIDBdLFxuICAgIFswLCAwLCAwXSxcbiAgICBbMCwgMCwgMV1cbiAgXTtcblxuICBwdWJsaWMgbWF4OiBGbG9hdDMyQXJyYXk7XG4gIHB1YmxpYyBtaW46IEZsb2F0MzJBcnJheTtcblxuICBwcml2YXRlIF9pc0RpcnR5OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2NlbnRlcjogRmxvYXQzMkFycmF5O1xuICBwcml2YXRlIF9zaXplOiBGbG9hdDMyQXJyYXk7XG5cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICBpZiAoIXRoaXMuX2NlbnRlciB8fCB0aGlzLl9pc0RpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDZW50ZXJTaXplKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgfVxuXG4gIGdldCBzaXplKCkge1xuICAgIGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9pc0RpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDZW50ZXJTaXplKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBnZXQgbWF4RXh0ZW5kcygpOiBFQXhpcyB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAoc2l6ZVswXSA+IHNpemVbMl0pIHtcbiAgICAgIHJldHVybiBzaXplWzBdID4gc2l6ZVsxXSA/IEVBeGlzLlggOiBFQXhpcy5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2l6ZVsxXSA+IHNpemVbMl0gPyBFQXhpcy5aIDogRUF4aXMuWTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3VyZmFjZUFyZWEoKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIDIgKiAoc2l6ZVswXSAqIHNpemVbMl0gKyBzaXplWzBdICogc2l6ZVsxXSArIHNpemVbMl0gKiBzaXplWzFdKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0RW1wdHkoKSB7XG4gICAgdGhpcy5tYXggPSBuZXcgRmxvYXQzMkFycmF5KFstSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgdGhpcy5taW4gPSBuZXcgRmxvYXQzMkFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBmcm9tVmVydGV4ZXModjE6IEZsb2F0MzJBcnJheSwgdjI6IEZsb2F0MzJBcnJheSwgdjM6IEZsb2F0MzJBcnJheSkge1xuICAgIHRoaXMubWF4ID0gdjEuc2xpY2UoKTtcbiAgICB0aGlzLm1pbiA9IHYxLnNsaWNlKCk7XG5cbiAgICB0aGlzLnVwZGF0ZSh2MikudXBkYXRlKHYzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZSh2OiBGbG9hdDMyQXJyYXkpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMzsgaW5kZXggKz0gMSkge1xuICAgICAgdGhpcy5tYXhbaW5kZXhdID0gTWF0aC5tYXgodGhpcy5tYXhbaW5kZXhdLCB2W2luZGV4XSk7XG4gICAgICB0aGlzLm1pbltpbmRleF0gPSBNYXRoLm1pbih0aGlzLm1pbltpbmRleF0sIHZbaW5kZXhdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBtZXJnZUJvdW5kcyhib3VuZHM6IEJvdW5kcykge1xuICAgIGNvbnN0IHsgbWF4LCBtaW4gfSA9IGJvdW5kcztcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAzOyBpbmRleCArPSAxKSB7XG4gICAgICB0aGlzLm1heFtpbmRleF0gPSBNYXRoLm1heCh0aGlzLm1heFtpbmRleF0sIG1heFtpbmRleF0pO1xuICAgICAgdGhpcy5taW5baW5kZXhdID0gTWF0aC5taW4odGhpcy5taW5baW5kZXhdLCBtaW5baW5kZXhdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBwb2ludEluKHA6IEZsb2F0MzJBcnJheSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHttYXgsIG1pbn0gPSB0aGlzO1xuICAgIHJldHVybiBwWzBdID4gbWluWzBdICYmIHBbMF0gPCBtYXhbMF1cbiAgICAgICYmIHBbMV0gPiBtaW5bMV0gJiYgcFsxXSA8IG1heFsxXVxuICAgICAgJiYgcFsyXSA+IG1pblsyXSAmJiBwWzJdIDwgbWF4WzJdO1xuICB9XG5cbiAgcHVibGljIGdldE9mZnNldChheGlzOiBFQXhpcywgdjogRmxvYXQzMkFycmF5KSB7XG4gICAgbGV0IG9mZnNldCA9IHZbYXhpc10gLSB0aGlzLm1pbltheGlzXTtcblxuICAgIGlmICh0aGlzLm1heFtheGlzXSA+IHRoaXMubWluW2F4aXNdKSB7XG4gICAgICBvZmZzZXQgLz0gKHRoaXMubWF4W2F4aXNdIC0gdGhpcy5taW5bYXhpc10pO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBwdWJsaWMgYnVpbGRCb3gobW9kZTogJ2xpbmVzJyB8ICd0cmlhbmdsZXMnKToge3Bvc2l0aW9uczogbnVtYmVyW10sIGluZGV4ZXM6IG51bWJlcltdfSB7XG4gICAgY29uc3Qge21heCwgbWlufSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgXG4gICAgQm91bmRzLkJVSUxEX0JPWF9NQVhfTUlOX09SREVSLmZvckVhY2gob3JkZXIgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2gob3JkZXJbaV0gPyBtYXhbaV0gOiBtaW5baV0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgbGV0IGluZGV4ZXM6IG51bWJlcltdO1xuICAgIGlmIChtb2RlID09PSAnbGluZXMnKSB7XG4gICAgICBpbmRleGVzID0gW1xuICAgICAgICAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLFxuICAgICAgICA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LFxuICAgICAgICAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3XG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleGVzID0gW1xuICAgICAgICAwLCAxLCAyLCAyLCAzLCAwLFxuICAgICAgICA0LCA1LCA2LCA2LCA3LCA0LFxuICAgICAgICAwLCA0LCA1LCA1LCAxLCAwLFxuICAgICAgICAxLCA1LCA2LCA2LCAyLCAxLFxuICAgICAgICAzLCAyLCA2LCA2LCA3LCAzLFxuICAgICAgICAwLCAzLCA3LCA3LCA0LCAwXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB7cG9zaXRpb25zLCBpbmRleGVzfTtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZUNlbnRlclNpemUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGlydHkpIHtcbiAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMubWF4Lm1hcCgobSwgaSkgPT4gKG0gKyB0aGlzLm1pbltpXSkgLyAyKTtcbiAgICAgIHRoaXMuX3NpemUgPSB0aGlzLm1heC5tYXAoKG0sIGkpID0+IG0gLSB0aGlzLm1pbltpXSk7XG4gICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJWSE5vZGUge1xuICBheGlzOiBFQXhpcztcbiAgYm91bmRzOiBCb3VuZHM7XG4gIGNoaWxkMDogSUJWSE5vZGUgfCBJQlZITGVhZjtcbiAgY2hpbGQxOiBJQlZITm9kZSB8IElCVkhMZWFmO1xuICBkZXB0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElCVkhMZWFmIHtcbiAgLy8gdGhyZWUgcG9pbnRzXG4gIGluZm9TdGFydDogbnVtYmVyO1xuICBpbmZvRW5kOiBudW1iZXI7XG4gIGJvdW5kczogQm91bmRzO1xufVxuXG5pbnRlcmZhY2UgSUJvdW5kc0luZm8ge1xuICBpbmRleGVzOiBVaW50MzJBcnJheTtcbiAgYm91bmRzOiBCb3VuZHM7XG59XG5cbmZ1bmN0aW9uIGlzQlZITGVhZih2YWx1ZTogSUJWSE5vZGUgfCBJQlZITGVhZikgOiB2YWx1ZSBpcyBJQlZITGVhZiB7XG4gIHJldHVybiAodmFsdWUgYXMgSUJWSExlYWYpLmluZm9FbmQgIT09IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgdG1wVjEgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuY29uc3QgdG1wVjIgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuY29uc3QgdG1wVjMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCVkggZXh0ZW5kcyBIT2JqZWN0IHtcbiAgcHVibGljIHN0YXRpYyBDTEFTU19OQU1FOiBzdHJpbmcgPSAnQlZIJztcbiAgcHVibGljIGlzQlZIOiBib29sZWFuID0gdHJ1ZTtcblxuICAvLyBwcm90ZWN0ZWQgX2J2aEdQVUJ1ZmZlcjogR1BVQnVmZmVyO1xuICBwcm90ZWN0ZWQgX3Jvb3ROb2RlOiBJQlZITm9kZTtcbiAgcHJvdGVjdGVkIF9ib3VuZHNJbmZvczogSUJvdW5kc0luZm9bXTtcbiAgcHJvdGVjdGVkIF9idmhNYXhEZXB0aDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX2J2aEJ1ZmZlcjogRmxvYXQzMkFycmF5O1xuICBwcm90ZWN0ZWQgX2J2aE5vZGVzOiBJQlZITm9kZVtdO1xuICBwcm90ZWN0ZWQgX2J2aExlYXZlczogSUJWSExlYWZbXTtcbiAgcHJvdGVjdGVkIF9kZWJ1Z01lc2g6IE1lc2g7XG5cbiAgZ2V0IG1heERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9idmhNYXhEZXB0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBub2RlcyB8IGxlYXZlc1xuICAgKiBub2RlczogY2hpbGQwIGFuZCBtaW4zKGYzMiksIGNoaWxkMSh1MzIpIGFuZCBtYXgzKGYzMilcbiAgICogbGVhdmVzOiBwcmltaXRpdmVzIGNvdW50KHUzMiksIGluZGV4ZXMzKHUzMiksXG4gICAqIGNoaWxkIGluZm86IDFiaXQgdHlwZSgwIGlzIG5vZGUsIDEgaXMgbGVhZikgYW5kIDMxYml0cyBvZmZzZXQoaW4gdmVjNClcbiAgICovXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J2aEJ1ZmZlcjtcbiAgfVxuXG4gIGdldCBkZWJ1Z01lc2goKSB7XG4gICAgaWYgKCF0aGlzLl9kZWJ1Z01lc2gpIHtcbiAgICAgIHRoaXMuX2J1aWxkRGVidWdNZXNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlYnVnTWVzaDtcbiAgfVxuXG4gIGdldCBub2Rlc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9idmhOb2Rlcy5sZW5ndGg7XG4gIH1cblxuICBnZXQgbGVhdmVzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J2aExlYXZlcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX21heFByaW1pdGl2ZXNQZXJMZWFmOiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIHByb2Nlc3MgPSAod29ybGRQb3NpdGlvbnM6IEZsb2F0MzJBcnJheSwgaW5kZXhlczogVWludDMyQXJyYXkpID0+IHtcbiAgICBjYWxsV2l0aFByb2ZpbGUoJ0JWSCBzZXR1cCBib3VuZHMgaW5mbycsIHRoaXMuX3NldHVwQm91bmRzSW5mbywgW3dvcmxkUG9zaXRpb25zLCBpbmRleGVzXSk7XG4gICAgY2FsbFdpdGhQcm9maWxlKCdCVkggYnVpbGQgdHJlZScsIHRoaXMuX2J1aWxkVHJlZSwgW10pO1xuICAgIGNhbGxXaXRoUHJvZmlsZSgnQlZIIGZsYXR0ZW4nLCB0aGlzLl9mbGF0dGVuLCBbXSk7XG5cbiAgICB0aGlzLl9kZWJ1Z01lc2ggPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXR1cEJvdW5kc0luZm8gPSAod29ybGRQb3NpdGlvbnM6IEZsb2F0MzJBcnJheSwgaW5kZXhlczogVWludDMyQXJyYXkpID0+IHtcbiAgICB0aGlzLl9ib3VuZHNJbmZvcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjb25zdCBpZHhlcyA9IGluZGV4ZXMuc2xpY2UoaSwgaSArIDMpO1xuXG4gICAgICBjb3B5VHlwZWRBcnJheSgzLCB0bXBWMSwgMCwgd29ybGRQb3NpdGlvbnMsIGlkeGVzWzBdICogNCk7XG4gICAgICBjb3B5VHlwZWRBcnJheSgzLCB0bXBWMiwgMCwgd29ybGRQb3NpdGlvbnMsIGlkeGVzWzFdICogNCk7XG4gICAgICBjb3B5VHlwZWRBcnJheSgzLCB0bXBWMywgMCwgd29ybGRQb3NpdGlvbnMsIGlkeGVzWzJdICogNCk7XG5cbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBCb3VuZHMoKS5mcm9tVmVydGV4ZXModG1wVjEsIHRtcFYyLCB0bXBWMyk7XG5cbiAgICAgIHRoaXMuX2JvdW5kc0luZm9zLnB1c2goe2luZGV4ZXM6IGlkeGVzLCBib3VuZHN9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2J1aWxkVHJlZSA9ICgpID0+IHtcbiAgICB0aGlzLl9yb290Tm9kZSA9IHRoaXMuX2J1aWxkUmVjdXJzaXZlKDAsIHRoaXMuX2JvdW5kc0luZm9zLmxlbmd0aCwgMCkgYXMgSUJWSE5vZGU7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2J1aWxkUmVjdXJzaXZlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBkZXB0aDogbnVtYmVyKTogSUJWSE5vZGUgfCBJQlZITGVhZiB7XG4gICAgY29uc3Qge19ib3VuZHNJbmZvc30gPSB0aGlzO1xuXG4gICAgY29uc3QgYm91bmRzID0gbmV3IEJvdW5kcygpLmluaXRFbXB0eSgpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICBib3VuZHMubWVyZ2VCb3VuZHMoX2JvdW5kc0luZm9zW2ldLmJvdW5kcyk7XG4gICAgfVxuXG4gICAgY29uc3QgblByaW1pdGl2ZXMgPSBlbmQgLSBzdGFydDtcblxuICAgIGlmIChuUHJpbWl0aXZlcyA8PSB0aGlzLl9tYXhQcmltaXRpdmVzUGVyTGVhZikge1xuICAgICAgcmV0dXJuIHsgaW5mb1N0YXJ0OiBzdGFydCwgaW5mb0VuZDogZW5kLCBib3VuZHMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2VudHJvaWRCb3VuZHMgPSBuZXcgQm91bmRzKCkuaW5pdEVtcHR5KCk7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBjZW50cm9pZEJvdW5kcy51cGRhdGUoX2JvdW5kc0luZm9zW2ldLmJvdW5kcy5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGltID0gY2VudHJvaWRCb3VuZHMubWF4RXh0ZW5kcztcblxuICAgICAgbGV0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuXG4gICAgICAvLyBtaWRkbGUgc3BsaXQgbWV0aG9kXG4gICAgICAvLyBjb25zdCBkaW1NaWQgPSAoY2VudHJvaWRCb3VuZHMubWF4W2RpbV0gKyBjZW50cm9pZEJvdW5kcy5taW5bZGltXSkgLyAyO1xuICAgICAgLy8gbWlkID0gcGFydGl0aW9uKHByaW1pdGl2ZUluZm8sIHAgPT4gcC5jZW50ZXJbZGltXSA8IGRpbU1pZCwgc3RhcnQsIGVuZCk7XG5cbiAgICAgIC8vIGlmIChtaWQgPT09IHN0YXJ0IHx8IG1pZCA9PT0gZW5kKSB7XG4gICAgICAvLyAgIG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgLy8gICBudGhFbGVtZW50KHByaW1pdGl2ZUluZm8sIChhLCBiKSA9PiBhLmNlbnRlcltkaW1dIDwgYi5jZW50ZXJbZGltXSwgc3RhcnQsIGVuZCwgbWlkKTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gc3VyZmFjZSBhcmVhIGhldXJpc3RpYyBtZXRob2RcbiAgICAgIGlmIChuUHJpbWl0aXZlcyA8PSA0KSB7XG4gICAgICAgIG50aEVsZW1lbnQoX2JvdW5kc0luZm9zLCAoYSwgYikgPT4gYS5ib3VuZHMuY2VudGVyW2RpbV0gPCBiLmJvdW5kcy5jZW50ZXJbZGltXSwgc3RhcnQsIGVuZCwgbWlkKTtcbiAgICAgIH0gZWxzZSBpZiAoY2VudHJvaWRCb3VuZHMubWF4W2RpbV0gPT09IGNlbnRyb2lkQm91bmRzLm1pbltkaW1dKSB7XG4gICAgICAgIC8vIGNhbid0IHNwbGl0IHByaW1pdGl2ZXMgYmFzZWQgb24gY2VudHJvaWQgYm91bmRzLiB0ZXJtaW5hdGUuXG4gICAgICAgIHJldHVybiB7aW5mb1N0YXJ0OiBzdGFydCwgaW5mb0VuZDogZW5kLCBib3VuZHN9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVja2V0czogeyBib3VuZHM6IEJvdW5kcywgY291bnQ6IG51bWJlciB9W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSArPSAxKSB7XG4gICAgICAgICAgYnVja2V0cy5wdXNoKHtib3VuZHM6IG5ldyBCb3VuZHMoKS5pbml0RW1wdHkoKSwgY291bnQ6IDB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgICAgbGV0IGIgPSBNYXRoLmZsb29yKGJ1Y2tldHMubGVuZ3RoICogY2VudHJvaWRCb3VuZHMuZ2V0T2Zmc2V0KGRpbSwgX2JvdW5kc0luZm9zW2ldLmJvdW5kcy5jZW50ZXIpKTtcblxuICAgICAgICAgIGlmIChiID09PSBidWNrZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgYiA9IGJ1Y2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBidWNrZXRzW2JdLmNvdW50ICs9IDE7XG4gICAgICAgICAgYnVja2V0c1tiXS5ib3VuZHMubWVyZ2VCb3VuZHMoX2JvdW5kc0luZm9zW2ldLmJvdW5kcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3N0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBiMCA9IG5ldyBCb3VuZHMoKS5pbml0RW1wdHkoKTtcbiAgICAgICAgICBjb25zdCBiMSA9IG5ldyBCb3VuZHMoKS5pbml0RW1wdHkoKTtcbiAgICAgICAgICBsZXQgY291bnQwID0gMDtcbiAgICAgICAgICBsZXQgY291bnQxID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBpOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGIwLm1lcmdlQm91bmRzKGJ1Y2tldHNbal0uYm91bmRzKTtcbiAgICAgICAgICAgIGNvdW50MCArPSBidWNrZXRzW2pdLmNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBidWNrZXRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBiMS5tZXJnZUJvdW5kcyhidWNrZXRzW2pdLmJvdW5kcyk7XG4gICAgICAgICAgICBjb3VudDEgKz0gYnVja2V0c1tqXS5jb3VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3N0LnB1c2goMC4xICsgKGNvdW50MCAqIGIwLnN1cmZhY2VBcmVhICsgY291bnQxICogYjEuc3VyZmFjZUFyZWEpIC8gYm91bmRzLnN1cmZhY2VBcmVhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtaW5Db3N0ID0gY29zdFswXTtcbiAgICAgICAgbGV0IG1pbkNvc3RTcGxpdEJ1Y2tldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29zdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb3N0W2ldIDwgbWluQ29zdCkge1xuICAgICAgICAgICAgbWluQ29zdCA9IGNvc3RbaV07XG4gICAgICAgICAgICBtaW5Db3N0U3BsaXRCdWNrZXQgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1pZCA9IHBhcnRpdGlvbihfYm91bmRzSW5mb3MsIHAgPT4ge1xuICAgICAgICAgIGxldCBiID0gTWF0aC5mbG9vcihidWNrZXRzLmxlbmd0aCAqIGNlbnRyb2lkQm91bmRzLmdldE9mZnNldChkaW0sIHAuYm91bmRzLmNlbnRlcikpO1xuICAgICAgICAgIGlmIChiID09PSBidWNrZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgYiA9IGJ1Y2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGIgPD0gbWluQ29zdFNwbGl0QnVja2V0O1xuICAgICAgICB9LCBzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGQwID0gdGhpcy5fYnVpbGRSZWN1cnNpdmUoc3RhcnQsIG1pZCwgZGVwdGggKyAxKTtcbiAgICAgIGNvbnN0IGNoaWxkMSA9IHRoaXMuX2J1aWxkUmVjdXJzaXZlKG1pZCwgZW5kLCBkZXB0aCArIDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBheGlzOiBkaW0sXG4gICAgICAgIGJvdW5kczogbmV3IEJvdW5kcygpLmluaXRFbXB0eSgpLm1lcmdlQm91bmRzKGNoaWxkMC5ib3VuZHMpLm1lcmdlQm91bmRzKGNoaWxkMS5ib3VuZHMpLFxuICAgICAgICBjaGlsZDAsXG4gICAgICAgIGNoaWxkMSxcbiAgICAgICAgZGVwdGhcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mbGF0dGVuID0gKCkgPT4ge1xuICAgIHRoaXMuX2J2aExlYXZlcyA9IFtdO1xuICAgIHRoaXMuX2J2aE5vZGVzID0gW107XG4gICAgY29uc3QgZmxhdEluZm8gPSB7bWF4RGVwdGg6IDEsIG5vZGVzOiBbXSwgbGVhdmVzOiBbXX07XG4gICAgdGhpcy5fdHJhdmVyc2VOb2RlKHRoaXMuX3Jvb3ROb2RlLCBmbGF0SW5mbyk7XG5cbiAgICBjb25zdCB7bWF4RGVwdGgsIG5vZGVzLCBsZWF2ZXN9ID0gZmxhdEluZm87XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQgKiAobm9kZXMubGVuZ3RoICsgbGVhdmVzLmxlbmd0aCkpO1xuICAgIGNvbnN0IGYzMlZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgdTMyVmlldyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IG5vZGVzTGVuID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5fYnZoTWF4RGVwdGggPSBtYXhEZXB0aDtcbiAgICBmMzJWaWV3LnNldChub2Rlcyk7XG4gICAgdTMyVmlldy5zZXQobGVhdmVzLCBub2Rlc0xlbik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuOyBpICs9IDgpIHtcbiAgICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCA4OyBjaSArPSA0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKyBjaTtcblxuICAgICAgICBpZiAobm9kZXNbb2Zmc2V0XSAmIDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAvLyBsZWFmXG4gICAgICAgICAgdTMyVmlld1tvZmZzZXRdID0gbm9kZXNbb2Zmc2V0XSArIG5vZGVzTGVuIC8gNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub2RlXG4gICAgICAgICAgdTMyVmlld1tvZmZzZXRdID0gbm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2J2aE1heERlcHRoID0gZmxhdEluZm8ubWF4RGVwdGg7XG4gICAgdGhpcy5fYnZoQnVmZmVyID0gZjMyVmlldztcbiAgfVxuXG4gIHByb3RlY3RlZCBfdHJhdmVyc2VOb2RlID0gKFxuICAgIG5vZGU6IElCVkhOb2RlIHwgSUJWSExlYWYsXG4gICAgLy8gbm9kZXM6IDIgY2hpbGRyZW4gaW5mbyBhbmQgNiBmbG9hdCBCVkhOb2RlIGJvdW5kaW5nIGluZm9cbiAgICAvLyBjaGlsZHJlbjogdXNlIHR3byB1aW50MzIgc3RvcmUgMiBjaGlsZHJlbidzIGluZm86IDFiaXQgdHlwZSgwIGlzIG5vZGUsIDEgaXMgbGVhZikgKyAzMWJpdHMgaW5kZXggb2Zmc2V0XG4gICAgLy8gbGVhdmVzOiBCVkhMZWFmIGluZGV4IGFuZCBsZW5ndGggaW5mb1xuICAgIGluZm86IHttYXhEZXB0aDogbnVtYmVyLCBub2RlczogbnVtYmVyW10sIGxlYXZlczogbnVtYmVyW119LFxuICAgIGRlcHRoOiBudW1iZXIgPSAxLFxuICAgIHBhcmVudE9mZnNldDogbnVtYmVyID0gLTEsXG4gICAgY2hpbGRJbmRleDogbnVtYmVyID0gMFxuICApID0+IHtcbiAgICBpbmZvLm1heERlcHRoID0gTWF0aC5tYXgoZGVwdGgsIGluZm8ubWF4RGVwdGgpO1xuICAgIGNvbnN0IHtub2RlcywgbGVhdmVzfSA9IGluZm87XG4gICAgY29uc3Qge19ib3VuZHNJbmZvcywgX2J2aE5vZGVzLCBfYnZoTGVhdmVzfSA9IHRoaXM7XG5cbiAgICBpZiAoaXNCVkhMZWFmKG5vZGUpKSB7XG4gICAgICBfYnZoTGVhdmVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAocGFyZW50T2Zmc2V0ID49IDApIHtcbiAgICAgICAgbm9kZXNbcGFyZW50T2Zmc2V0ICogOCArIGNoaWxkSW5kZXhdID0gKDEgPDwgMzEpIHwgKGxlYXZlcy5sZW5ndGggLyA0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY291bnQgPSBub2RlLmluZm9FbmQgLSBub2RlLmluZm9TdGFydDtcbiAgICAgIGZvciAobGV0IGkgPSBub2RlLmluZm9TdGFydDsgaSA8IG5vZGUuaW5mb0VuZDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGlkeGVzID0gX2JvdW5kc0luZm9zW2ldLmluZGV4ZXM7XG5cbiAgICAgICAgbGVhdmVzLnB1c2goY291bnQsIGlkeGVzWzBdLCBpZHhlc1sxXSwgaWR4ZXNbMl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfYnZoTm9kZXMucHVzaChub2RlKTtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5vZGUuYm91bmRzO1xuICAgICAgY29uc3Qgbm9kZU9mZnNldCA9IG5vZGVzLmxlbmd0aCAvIDg7XG5cbiAgICAgIGlmIChwYXJlbnRPZmZzZXQgPj0gMCkge1xuICAgICAgICBub2Rlc1twYXJlbnRPZmZzZXQgKiA4ICsgY2hpbGRJbmRleF0gPSBub2RlT2Zmc2V0ICogMjtcbiAgICAgIH1cblxuICAgICAgbm9kZXMucHVzaChcbiAgICAgICAgMCwgYm91bmRzLm1pblswXSwgYm91bmRzLm1pblsxXSwgYm91bmRzLm1pblsyXSxcbiAgICAgICAgMCwgYm91bmRzLm1heFswXSwgYm91bmRzLm1heFsxXSwgYm91bmRzLm1heFsyXVxuICAgICAgKTtcblxuICAgICAgdGhpcy5fdHJhdmVyc2VOb2RlKG5vZGUuY2hpbGQwLCBpbmZvLCBkZXB0aCArIDEsIG5vZGVPZmZzZXQsIDApO1xuICAgICAgdGhpcy5fdHJhdmVyc2VOb2RlKG5vZGUuY2hpbGQxLCBpbmZvLCBkZXB0aCArIDEsIG5vZGVPZmZzZXQsIDQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYnVpbGREZWJ1Z01lc2goKSB7XG4gICAgY29uc3Qge19idmhOb2RlcywgX2J2aE1heERlcHRofSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9ICdsaW5lcycgYXMgJ2xpbmVzJyB8ICd0cmlhbmdsZXMnO1xuXG4gICAgY29uc3Qgbm9kZXNMZW4gPSBfYnZoTm9kZXMubGVuZ3RoO1xuICAgIC8vIHBlciBib3ggaGFzIDggdmVydGV4XG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShub2Rlc0xlbiAqIDggKiAzKTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KG5vZGVzTGVuICogOCAqIDMpO1xuICAgIGxldCBpbmRleGVzOiBVaW50MzJBcnJheTtcbiAgICBpZiAobW9kZSA9PT0gJ2xpbmVzJykge1xuICAgICAgaW5kZXhlcyA9IG5ldyBVaW50MzJBcnJheShub2Rlc0xlbiAqIDI0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhlcyA9IG5ldyBVaW50MzJBcnJheShub2Rlc0xlbiAqIDM2KTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3RlTERlcHRoQ291bnQ6IG51bWJlcltdID0gbmV3IEFycmF5KF9idmhNYXhEZXB0aCkuZmlsbCgwKTtcbiAgICBjb25zdCBkZXB0aENvdW50OiBudW1iZXJbXSA9IG5ldyBBcnJheShfYnZoTWF4RGVwdGgpLmZpbGwoMCk7XG4gICAgX2J2aE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICB0b3RlTERlcHRoQ291bnRbbm9kZS5kZXB0aF0gKz0gMTtcbiAgICB9KTtcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgX2J2aE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBub2RlLmJvdW5kcy5idWlsZEJveChtb2RlKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogODtcbiAgICAgIGNvbnN0IHBPZmZzZXQgPSBpbmRleCAqIDggKiAzO1xuICAgICAgY29uc3QgY09mZnNldCA9IGluZGV4ICogOCAqIDM7XG4gICAgICBjb25zdCBpT2Zmc2V0ID0gaW5kZXggKiBib3guaW5kZXhlcy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IGNvbG9yID0gaHNsVG9SZ2IoXG4gICAgICAgIG5vZGUuZGVwdGggLyBfYnZoTWF4RGVwdGgsXG4gICAgICAgIChkZXB0aENvdW50W25vZGUuZGVwdGhdIC8gdG90ZUxEZXB0aENvdW50W25vZGUuZGVwdGhdKSAqIDAuNyArIDAuMyxcbiAgICAgICAgMC41XG4gICAgICApO1xuICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IDI0OyBjaSArPSAzKSB7XG4gICAgICAgIGNvbG9ycy5zZXQoY29sb3IsIGNPZmZzZXQgKyBjaSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGluZGV4ZXMuc2V0KGJveC5pbmRleGVzLm1hcCh2ID0+IHYgKyBvZmZzZXQpLCBpT2Zmc2V0KTtcbiAgICAgIHBvc2l0aW9ucy5zZXQoYm94LnBvc2l0aW9ucywgcE9mZnNldCk7XG4gICAgICBcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBkZXB0aENvdW50W25vZGUuZGVwdGhdICs9IDE7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kZWJ1Z01lc2ggPSBuZXcgTWVzaChcbiAgICAgIG5ldyBHZW9tZXRyeShbXG4gICAgICAgIHtcbiAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAwLFxuICAgICAgICAgICAgICBmb3JtYXQ6ICdmbG9hdDMyeDMnLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgYXJyYXlTdHJpZGU6IDEyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhOiBwb3NpdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgICAgICAgbmFtZTogJ2NvbG9yXzAnLFxuICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogMSxcbiAgICAgICAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngzJyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGFycmF5U3RyaWRlOiAxMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogY29sb3JzXG4gICAgICAgIH1cbiAgICAgIF0sIGluZGV4ZXMsIGluZGV4ZXMubGVuZ3RoKSxcbiAgICAgIG5ldyBNYXRlcmlhbChcbiAgICAgICAgYnVpbGRpbkVmZmVjdHMuckNvbG9yLFxuICAgICAgICB7dV9jb2xvcjogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgLjRdKX0sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIHByaW1pdGl2ZVR5cGU6IG1vZGUgPT09ICdsaW5lcycgPyAnbGluZS1saXN0JyA6ICd0cmlhbmdsZS1saXN0JyxcbiAgICAgICAgICBjdWxsTW9kZTogJ25vbmUnLFxuICAgICAgICAgIGJsZW5kQ29sb3I6IHtcbiAgICAgICAgICAgIHNyY0ZhY3RvcjogJ3NyYy1hbHBoYScsXG4gICAgICAgICAgICBkc3RGYWN0b3I6ICdvbmUtbWludXMtc3JjLWFscGhhJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxlbmRBbHBoYToge1xuICAgICAgICAgICAgc3JjRmFjdG9yOiAnemVybycsXG4gICAgICAgICAgICBkc3RGYWN0b3I6ICdvbmUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBodWUycmdiKHA6IG51bWJlciwgcTogbnVtYmVyLCB0OiBudW1iZXIpIHtcbiAgaWYodCA8IDApIHQgKz0gMTtcbiAgaWYodCA+IDEpIHQgLT0gMTtcbiAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2IoaDogbnVtYmVyLCBzOiBudW1iZXIsIGw6IG51bWJlcil7XG4gIGxldCByOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyO1xuXG4gIGlmKHMgPT0gMCl7XG4gICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xuICB9IGVsc2Uge1xuICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcbiAgfVxuXG4gIHJldHVybiBbciwgZywgYl07XG59XG4iXX0=

/***/ }),

/***/ "./src/extension/NodeControl.ts":
/*!**************************************!*\
  !*** ./src/extension/NodeControl.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var renderEnv_1 = __webpack_require__(/*! ../core/renderEnv */ "./src/core/renderEnv.ts");
var HObject_1 = __webpack_require__(/*! ../core/HObject */ "./src/core/HObject.ts");
var tmpV0 = new Float32Array(3);
var tmpV1 = new Float32Array(3);
var tmpV2 = new Float32Array(3);
var tmpQ1 = new Float32Array(4);
var tmpMat = new Float32Array(16);
var UP = new Float32Array([0, 1, 0]);
var NodeControl = (function (_super) {
    __extends(NodeControl, _super);
    function NodeControl(_mode) {
        if (_mode === void 0) { _mode = 'free'; }
        var _this = _super.call(this) || this;
        _this._mode = _mode;
        _this.isNodeControl = true;
        _this._start = false;
        _this._handleStart = function (event) {
            _this._x = event.clientX;
            _this._y = event.clientY;
            if (_this._mode === 'arc') {
                _this._arcRadius = gl_matrix_1.vec3.distance(gl_matrix_1.mat4.getTranslation(tmpV0, _this._target.worldMat), gl_matrix_1.mat4.getTranslation(tmpV1, _this._node.worldMat));
            }
            _this._start = true;
        };
        _this._handleEnd = function () {
            _this._start = false;
        };
        _this._handleMove = function (event) {
            var _a = _this, _start = _a._start, _node = _a._node, _x = _a._x, _y = _a._y;
            if (!_start || !_node) {
                return;
            }
            var clientX = event.clientX, clientY = event.clientY;
            var dy = (clientX - _x) / 200;
            var dx = (clientY - _y) / 200;
            if (_this._mode === 'free') {
                gl_matrix_1.quat.rotateX(_node.quat, _node.quat, dx);
                gl_matrix_1.quat.invert(tmpQ1, _node.quat);
                var up = new Float32Array([0, 1, 0]);
                gl_matrix_1.vec3.transformQuat(up, up, tmpQ1);
                gl_matrix_1.quat.setAxisAngle(tmpQ1, up, dy);
                gl_matrix_1.quat.multiply(_node.quat, _node.quat, tmpQ1);
            }
            else {
                gl_matrix_1.mat4.getTranslation(tmpV0, _this._target.worldMat);
                gl_matrix_1.mat4.getTranslation(tmpV1, _this._node.worldMat);
                tmpV1[0] += dy * 2;
                tmpV1[1] += dx * 2;
                var forward = gl_matrix_1.vec3.sub(tmpV2, tmpV0, tmpV1);
                gl_matrix_1.vec3.normalize(forward, forward);
                gl_matrix_1.vec3.scale(forward, forward, -_this._arcRadius);
                gl_matrix_1.vec3.add(tmpV1, tmpV0, forward);
                gl_matrix_1.mat4.lookAt(tmpMat, tmpV1, tmpV0, UP);
                _this._node.pos.set(tmpV1);
                gl_matrix_1.mat4.getRotation(_this._node.quat, tmpMat);
            }
            _this._x = clientX;
            _this._y = clientY;
            _this.onChange && _this.onChange();
        };
        _this._handleZoom = function (event) {
            var _a = _this._node, worldMat = _a.worldMat, pos = _a.pos;
            var delta = event.deltaY / 200;
            var forward = worldMat.slice(8, 12);
            if (_this._mode === 'arc') {
                gl_matrix_1.mat4.getTranslation(tmpV0, _this._target.worldMat);
                gl_matrix_1.mat4.getTranslation(tmpV1, _this._node.worldMat);
                gl_matrix_1.vec3.sub(forward, tmpV0, tmpV1);
                delta = -delta;
            }
            gl_matrix_1.vec3.normalize(forward, forward);
            gl_matrix_1.vec3.scale(forward, forward, delta);
            gl_matrix_1.vec3.add(pos, pos, forward);
            if (_this._mode === 'arc') {
                _this._arcRadius += delta;
            }
            _this.onChange && _this.onChange();
        };
        _this._handleTouchStart = function (event) {
            var touch = event.targetTouches[0];
            _this._touchId = touch.identifier;
            _this._handleStart(touch);
        };
        _this._handleTouchMove = function (event) {
            if (!_this._start) {
                return;
            }
            for (var i = 0; i < event.targetTouches.length; i += 1) {
                var touch = event.targetTouches[i];
                if (touch.identifier === _this._touchId) {
                    return _this._handleMove(touch);
                }
            }
            _this._handleEnd();
        };
        var canvas = renderEnv_1.default.canvas;
        canvas.addEventListener('mousedown', _this._handleStart);
        canvas.addEventListener('mouseup', _this._handleEnd);
        canvas.addEventListener('mouseleave', _this._handleEnd);
        canvas.addEventListener('mouseout', _this._handleEnd);
        canvas.addEventListener('mousemove', _this._handleMove);
        canvas.addEventListener('wheel', _this._handleZoom);
        canvas.addEventListener('touchstart', _this._handleTouchStart);
        canvas.addEventListener('touchend', _this._handleEnd);
        canvas.addEventListener('touchcancel', _this._handleEnd);
        canvas.addEventListener('touchmove', _this._handleTouchMove);
        return _this;
    }
    NodeControl.prototype.control = function (node, target) {
        this._node = node;
        this._target = target;
        if (!target && this._mode === 'arc') {
            throw new Error('Mode arc must be given target!');
        }
    };
    NodeControl.CLASS_NAME = 'NodeControl';
    return NodeControl;
}(HObject_1.default));
exports["default"] = NodeControl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZUNvbnRyb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJOb2RlQ29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFNQSx1Q0FBNkM7QUFDN0MsK0NBQTBDO0FBQzFDLDJDQUFzQztBQUd0QyxJQUFNLEtBQUssR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxJQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwQyxJQUFNLEVBQUUsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUV2QztJQUF5QywrQkFBTztJQWE5QyxxQkFBc0IsS0FBOEI7UUFBOUIsc0JBQUEsRUFBQSxjQUE4QjtRQUFwRCxZQUNFLGlCQUFPLFNBZVI7UUFoQnFCLFdBQUssR0FBTCxLQUFLLENBQXlCO1FBWDdDLG1CQUFhLEdBQVksSUFBSSxDQUFDO1FBRzNCLFlBQU0sR0FBWSxLQUFLLENBQUM7UUFtQ3hCLGtCQUFZLEdBQUcsVUFBQyxLQUF5QztZQUNqRSxLQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDeEIsS0FBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO1lBRXhCLElBQUksS0FBSSxDQUFDLEtBQUssS0FBSyxLQUFLLEVBQUU7Z0JBQ3hCLEtBQUksQ0FBQyxVQUFVLEdBQUcsZ0JBQUksQ0FBQyxRQUFRLENBQzdCLGdCQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxL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LENBQUMsVUFBVSxFQUFFLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNyRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVuRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzlELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7O0lBQzlELENBQUM7SUFFTSw2QkFBTyxHQUFkLFVBQWUsSUFBVSxFQUFFLE1BQWE7UUFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFFdEIsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssRUFBRTtZQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7U0FDbkQ7SUFDSCxDQUFDO0lBckNhLHNCQUFVLEdBQVcsYUFBYSxDQUFDO0lBMkluRCxrQkFBQztDQUFBLEFBNUlELENBQXlDLGlCQUFPLEdBNEkvQztrQkE1SW9CLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5vZGVDb250cm9sLnRzXG4gKiBcbiAqIEBBdXRob3IgIDpkdHlza3koZHR5c2t5QG91dGxvb2suY29tKVxuICogQERhdGUgICAgOiA2LzEzLzIwMjEsIDg6NDc6MjIgUE1cbiovXG5pbXBvcnQgeyBtYXQ0LCBxdWF0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi4vY29yZS9yZW5kZXJFbnYnO1xuaW1wb3J0IEhPYmplY3QgZnJvbSAnLi4vY29yZS9IT2JqZWN0JztcbmltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZSc7XG5cbmNvbnN0IHRtcFYwID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbmNvbnN0IHRtcFYxID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbmNvbnN0IHRtcFYyID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbmNvbnN0IHRtcFExID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbmNvbnN0IHRtcE1hdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuY29uc3QgVVAgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vZGVDb250cm9sIGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ05vZGVDb250cm9sJztcbiAgcHVibGljIGlzTm9kZUNvbnRyb2w6IGJvb2xlYW4gPSB0cnVlO1xuICBwdWJsaWMgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIF9zdGFydDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgX3g6IG51bWJlcjtcbiAgcHJvdGVjdGVkIF95OiBudW1iZXI7XG4gIHByb3RlY3RlZCBfdG91Y2hJZDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX25vZGU6IE5vZGU7XG4gIHByb3RlY3RlZCBfdGFyZ2V0OiBOb2RlO1xuICBwcm90ZWN0ZWQgX2FyY1JhZGl1czogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfbW9kZTogJ2ZyZWUnIHwgJ2FyYycgPSAnZnJlZScpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3Qge2NhbnZhc30gPSByZW5kZXJFbnY7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlU3RhcnQpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlRW5kKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2hhbmRsZUVuZCk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlRW5kKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW92ZSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5faGFuZGxlWm9vbSk7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZUVuZCk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlRW5kKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgfVxuXG4gIHB1YmxpYyBjb250cm9sKG5vZGU6IE5vZGUsIHRhcmdldD86IE5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAoIXRhcmdldCAmJiB0aGlzLl9tb2RlID09PSAnYXJjJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlIGFyYyBtdXN0IGJlIGdpdmVuIHRhcmdldCEnKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVN0YXJ0ID0gKGV2ZW50OiB7Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9KSA9PiB7XG4gICAgdGhpcy5feCA9IGV2ZW50LmNsaWVudFg7XG4gICAgdGhpcy5feSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBpZiAodGhpcy5fbW9kZSA9PT0gJ2FyYycpIHtcbiAgICAgIHRoaXMuX2FyY1JhZGl1cyA9IHZlYzMuZGlzdGFuY2UoXG4gICAgICAgIG1hdDQuZ2V0VHJhbnNsYXRpb24odG1wVjAsIHRoaXMuX3RhcmdldC53b3JsZE1hdCksXG4gICAgICAgIG1hdDQuZ2V0VHJhbnNsYXRpb24odG1wVjEsIHRoaXMuX25vZGUud29ybGRNYXQpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0ID0gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRW5kID0gKCkgPT4ge1xuICAgIHRoaXMuX3N0YXJ0ID0gZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZU1vdmUgPSAoZXZlbnQ6IHtjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn0pID0+IHtcbiAgICBjb25zdCB7X3N0YXJ0LCBfbm9kZSwgX3gsIF95fSA9IHRoaXM7XG5cbiAgICBpZiAoIV9zdGFydCB8fCAhX25vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBldmVudDtcbiAgICBjb25zdCBkeSA9IChjbGllbnRYIC0gX3gpIC8gMjAwO1xuICAgIGNvbnN0IGR4ID0gKGNsaWVudFkgLSBfeSkgLyAyMDA7XG5cbiAgICBpZiAodGhpcy5fbW9kZSA9PT0gJ2ZyZWUnKSB7XG4gICAgICBxdWF0LnJvdGF0ZVgoX25vZGUucXVhdCwgX25vZGUucXVhdCwgZHgpO1xuICAgICAgcXVhdC5pbnZlcnQodG1wUTEsIF9ub2RlLnF1YXQpO1xuICAgICAgY29uc3QgdXAgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSk7XG4gICAgICB2ZWMzLnRyYW5zZm9ybVF1YXQodXAsIHVwLCB0bXBRMSk7XG4gICAgICBxdWF0LnNldEF4aXNBbmdsZSh0bXBRMSwgdXAsIGR5KTtcbiAgICAgIHF1YXQubXVsdGlwbHkoX25vZGUucXVhdCwgX25vZGUucXVhdCwgdG1wUTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXQ0LmdldFRyYW5zbGF0aW9uKHRtcFYwLCB0aGlzLl90YXJnZXQud29ybGRNYXQpO1xuICAgICAgbWF0NC5nZXRUcmFuc2xhdGlvbih0bXBWMSwgdGhpcy5fbm9kZS53b3JsZE1hdCk7XG4gICAgICB0bXBWMVswXSArPSBkeSAqIDI7XG4gICAgICB0bXBWMVsxXSArPSBkeCAqIDI7XG4gICAgICBjb25zdCBmb3J3YXJkID0gdmVjMy5zdWIodG1wVjIsIHRtcFYwLCB0bXBWMSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZShmb3J3YXJkLCBmb3J3YXJkKTtcbiAgICAgIHZlYzMuc2NhbGUoZm9yd2FyZCwgZm9yd2FyZCwgLXRoaXMuX2FyY1JhZGl1cyk7XG4gICAgICB2ZWMzLmFkZCh0bXBWMSwgdG1wVjAsIGZvcndhcmQpO1xuICAgICAgbWF0NC5sb29rQXQodG1wTWF0LCB0bXBWMSwgdG1wVjAsIFVQKTtcbiAgICAgIHRoaXMuX25vZGUucG9zLnNldCh0bXBWMSk7XG4gICAgICBtYXQ0LmdldFJvdGF0aW9uKHRoaXMuX25vZGUucXVhdCwgdG1wTWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLl94ID0gY2xpZW50WDtcbiAgICB0aGlzLl95ID0gY2xpZW50WTtcblxuICAgIHRoaXMub25DaGFuZ2UgJiYgdGhpcy5vbkNoYW5nZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVpvb20gPSAoZXZlbnQ6IFdoZWVsRXZlbnQpID0+IHtcbiAgICBjb25zdCB7d29ybGRNYXQsIHBvc30gPSB0aGlzLl9ub2RlO1xuICAgIGxldCBkZWx0YSA9IGV2ZW50LmRlbHRhWSAvIDIwMDtcbiAgICBsZXQgZm9yd2FyZCA9IHdvcmxkTWF0LnNsaWNlKDgsIDEyKTtcblxuICAgIGlmICh0aGlzLl9tb2RlID09PSAnYXJjJykge1xuICAgICAgbWF0NC5nZXRUcmFuc2xhdGlvbih0bXBWMCwgdGhpcy5fdGFyZ2V0LndvcmxkTWF0KTtcbiAgICAgIG1hdDQuZ2V0VHJhbnNsYXRpb24odG1wVjEsIHRoaXMuX25vZGUud29ybGRNYXQpO1xuICAgICAgdmVjMy5zdWIoZm9yd2FyZCwgdG1wVjAsIHRtcFYxKTtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cblxuICAgIHZlYzMubm9ybWFsaXplKGZvcndhcmQsIGZvcndhcmQpO1xuICAgIHZlYzMuc2NhbGUoZm9yd2FyZCwgZm9yd2FyZCwgZGVsdGEpO1xuICAgIHZlYzMuYWRkKHBvcywgcG9zLCBmb3J3YXJkKTtcblxuICAgIGlmICh0aGlzLl9tb2RlID09PSAnYXJjJykge1xuICAgICAgdGhpcy5fYXJjUmFkaXVzICs9IGRlbHRhO1xuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2UgJiYgdGhpcy5vbkNoYW5nZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQ6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG4gICAgdGhpcy5fdG91Y2hJZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgdGhpcy5faGFuZGxlU3RhcnQodG91Y2gpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVUb3VjaE1vdmUgPSAoZXZlbnQ6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbaV07XG5cbiAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLl90b3VjaElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNb3ZlKHRvdWNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVFbmQoKTtcbiAgfVxufVxuIl19

/***/ }),

/***/ "./src/extension/RayTracingManager.ts":
/*!********************************************!*\
  !*** ./src/extension/RayTracingManager.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPBRMaterialType = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var ComputeUnit_1 = __webpack_require__(/*! ../core/ComputeUnit */ "./src/core/ComputeUnit.ts");
var Geometry_1 = __webpack_require__(/*! ../core/Geometry */ "./src/core/Geometry.ts");
var HObject_1 = __webpack_require__(/*! ../core/HObject */ "./src/core/HObject.ts");
var Material_1 = __webpack_require__(/*! ../core/Material */ "./src/core/Material.ts");
var Mesh_1 = __webpack_require__(/*! ../core/Mesh */ "./src/core/Mesh.ts");
var renderEnv_1 = __webpack_require__(/*! ../core/renderEnv */ "./src/core/renderEnv.ts");
var shared_1 = __webpack_require__(/*! ../core/shared */ "./src/core/shared.ts");
var Texture_1 = __webpack_require__(/*! ../core/Texture */ "./src/core/Texture.ts");
var BVH_1 = __webpack_require__(/*! ./BVH */ "./src/extension/BVH.ts");
;
var EPBRMaterialType;
(function (EPBRMaterialType) {
    EPBRMaterialType[EPBRMaterialType["METAL_ROUGH"] = 0] = "METAL_ROUGH";
    EPBRMaterialType[EPBRMaterialType["SPEC_GLOSS"] = 1] = "SPEC_GLOSS";
    EPBRMaterialType[EPBRMaterialType["GLASS_METAL_ROUGH"] = 2] = "GLASS_METAL_ROUGH";
    EPBRMaterialType[EPBRMaterialType["GLASS_SPEC_GLOSS"] = 3] = "GLASS_SPEC_GLOSS";
})(EPBRMaterialType = exports.EPBRMaterialType || (exports.EPBRMaterialType = {}));
;
var RayTracingManager = (function (_super) {
    __extends(RayTracingManager, _super);
    function RayTracingManager(_maxPrimitivesPerBVHLeaf) {
        if (_maxPrimitivesPerBVHLeaf === void 0) { _maxPrimitivesPerBVHLeaf = 1; }
        var _this = _super.call(this) || this;
        _this._maxPrimitivesPerBVHLeaf = _maxPrimitivesPerBVHLeaf;
        _this.isRayTracingManager = true;
        _this._materials = [];
        _this._buildAttributeBuffers = function (meshes) {
            var _materials = _this._materials;
            var indexCount = 0;
            var vertexCount = 0;
            meshes.forEach(function (mesh) {
                vertexCount += mesh.geometry.vertexCount;
                indexCount += mesh.geometry.count;
            });
            var indexes = (_this._indexInfo = {
                value: new Uint32Array(indexCount)
            }).value;
            var _a = _this._attributesInfo = {
                position: {
                    value: new Float32Array(vertexCount * 4),
                    length: 4,
                    format: 'float32x3'
                },
                texcoord_0: {
                    value: new Float32Array(vertexCount * 2),
                    length: 2,
                    format: 'float32x2'
                },
                normal: {
                    value: new Float32Array(vertexCount * 4),
                    length: 4,
                    format: 'float32x3'
                },
                meshMatIndex: {
                    value: new Uint32Array(vertexCount * 2),
                    length: 2,
                    format: 'uint32x2'
                }
            }, position = _a.position, texcoord_0 = _a.texcoord_0, normal = _a.normal, meshMatIndex = _a.meshMatIndex;
            var attrOffset = 0;
            var indexOffset = 0;
            for (var meshIndex = 0; meshIndex < meshes.length; meshIndex += 1) {
                var mesh = meshes[meshIndex];
                var worldMat = mesh.worldMat;
                var quat = gl_matrix_1.mat4.getRotation(new Float32Array(4), worldMat);
                var geometry = mesh.geometry, material = mesh.material;
                var indexData = geometry.indexData, vertexInfo = geometry.vertexInfo, vertexCount_1 = geometry.vertexCount, count = geometry.count;
                if (material.effect.name !== 'rPBR') {
                    throw new Error('Only support Effect rPBR!');
                }
                var materialIndex = _materials.indexOf(material);
                if (materialIndex < 0) {
                    _materials.push(material);
                    materialIndex = _materials.length - 1;
                }
                indexData.forEach(function (value, index) {
                    indexes[index + indexOffset] = value + attrOffset;
                });
                if (!vertexInfo.normal) {
                    geometry.calculateNormals();
                }
                for (var index = 0; index < vertexCount_1; index += 1) {
                    _this._copyAttribute(vertexInfo.position, position, attrOffset, index, worldMat);
                    _this._copyAttribute(vertexInfo.texcoord_0, texcoord_0, attrOffset, index);
                    _this._copyAttribute(vertexInfo.normal, normal, attrOffset, index, quat, true);
                    meshMatIndex.value.set([meshIndex, materialIndex], (attrOffset + index) * meshMatIndex.length);
                }
                indexOffset += count;
                attrOffset += vertexCount_1;
            }
        };
        _this._buildCommonUniforms = function (materials) {
            var matId2TexturesId = new Int32Array(materials.length * 4).fill(-1);
            var baseColorFactors = new Float32Array(materials.length * 4).fill(1);
            var metallicRoughnessFactorNormalScaleMaterialTypes = new Float32Array(materials.length * 4).fill(1);
            var specularGlossinessFactors = new Float32Array(materials.length * 4).fill(1);
            var baseColorTextures = [];
            var normalTextures = [];
            var metalRoughOrSpecGlossTextures = [];
            materials.forEach(function (mat, index) {
                var useGlass = mat.marcos['USE_GLASS'];
                var useSpecGloss = mat.marcos['USE_SPEC_GLOSS'];
                var baseColorFactor = mat.getUniform('u_baseColorFactor');
                var metallicFactor = mat.getUniform('u_metallicFactor');
                var roughnessFactor = mat.getUniform('u_roughnessFactor');
                var specularFactor = mat.getUniform('u_specularFactor');
                var glossinessFactor = mat.getUniform('u_glossinessFactor');
                var normalScale = mat.getUniform('u_normalTextureScale');
                var baseColorTexture = mat.getUniform('u_baseColorTexture');
                var normalTexture = mat.getUniform('u_normalTexture');
                var metallicRoughnessTexture = mat.getUniform('u_metallicRoughnessTexture');
                var specularGlossinessTexture = mat.getUniform('u_specularGlossinessTexture');
                var mid = index * 4;
                baseColorTexture !== buildin_1.buildinTextures.empty && _this._setTextures(mid, baseColorTextures, baseColorTexture, matId2TexturesId);
                normalTexture !== buildin_1.buildinTextures.empty && _this._setTextures(mid + 1, normalTextures, normalTexture, matId2TexturesId);
                baseColorFactor && baseColorFactors.set(baseColorFactor, index * 4);
                normalScale !== undefined && metallicRoughnessFactorNormalScaleMaterialTypes.set(normalScale.slice(0, 1), index * 4 + 2);
                if (useSpecGloss) {
                    specularFactor !== undefined && specularGlossinessFactors.set(specularFactor.slice(0, 3), index * 4);
                    glossinessFactor !== undefined && specularGlossinessFactors.set(glossinessFactor.slice(0, 1), index * 4 + 3);
                    specularGlossinessTexture !== buildin_1.buildinTextures.empty && _this._setTextures(mid + 2, metalRoughOrSpecGlossTextures, specularGlossinessTexture, matId2TexturesId);
                    metallicRoughnessFactorNormalScaleMaterialTypes.set([useGlass ? EPBRMaterialType.GLASS_SPEC_GLOSS : EPBRMaterialType.SPEC_GLOSS], index * 4 + 3);
                }
                else {
                    metallicFactor !== undefined && metallicRoughnessFactorNormalScaleMaterialTypes.set(metallicFactor.slice(0, 1), index * 4);
                    roughnessFactor !== undefined && metallicRoughnessFactorNormalScaleMaterialTypes.set(roughnessFactor.slice(0, 1), index * 4 + 1);
                    metallicRoughnessTexture !== buildin_1.buildinTextures.empty && _this._setTextures(mid + 2, metalRoughOrSpecGlossTextures, metallicRoughnessTexture, matId2TexturesId);
                    metallicRoughnessFactorNormalScaleMaterialTypes.set([useGlass ? EPBRMaterialType.GLASS_METAL_ROUGH : EPBRMaterialType.METAL_ROUGH], index * 4 + 3);
                }
            });
            _this._commonUniforms = {
                matId2TexturesId: matId2TexturesId,
                baseColorFactors: baseColorFactors,
                metallicRoughnessFactorNormalScaleMaterialTypes: metallicRoughnessFactorNormalScaleMaterialTypes,
                specularGlossinessFactors: specularGlossinessFactors,
                baseColorTextures: _this._generateTextureArray(baseColorTextures),
                normalTextures: _this._generateTextureArray(normalTextures),
                metalRoughOrSpecGlossTextures: _this._generateTextureArray(metalRoughOrSpecGlossTextures)
            };
        };
        _this._buildGBufferMesh = function () {
            var _a = _this, _attributesInfo = _a._attributesInfo, _indexInfo = _a._indexInfo, _commonUniforms = _a._commonUniforms;
            var geometry = new Geometry_1.default(Object.keys(_attributesInfo).map(function (name, index) {
                var _a = _attributesInfo[name], value = _a.value, length = _a.length, format = _a.format;
                return {
                    layout: {
                        arrayStride: length * 4,
                        attributes: [{
                                name: name,
                                offset: 0,
                                format: format,
                                shaderLocation: index
                            }]
                    },
                    data: value,
                    usage: GPUBufferUsage.STORAGE
                };
            }), _indexInfo.value, _indexInfo.value.length);
            var material = new Material_1.default(buildin_1.buildinEffects.rRTGBuffer, {
                u_matId2TexturesId: _commonUniforms.matId2TexturesId,
                u_baseColorFactors: _commonUniforms.baseColorFactors,
                u_metallicRoughnessFactorNormalScaleMaterialTypes: _commonUniforms.metallicRoughnessFactorNormalScaleMaterialTypes,
                u_specularGlossinessFactors: _commonUniforms.specularGlossinessFactors,
                u_baseColorTextures: _commonUniforms.baseColorTextures,
                u_normalTextures: _commonUniforms.normalTextures,
                u_metalRoughOrSpecGlossTextures: _commonUniforms.metalRoughOrSpecGlossTextures
            });
            _this._gBufferMesh = new Mesh_1.default(geometry, material);
        };
        _this._buildRTUnit = function (output) {
            var _a = _this, _gBufferMesh = _a._gBufferMesh, _commonUniforms = _a._commonUniforms, _bvh = _a._bvh;
            var geometry = _gBufferMesh.geometry;
            _this._rtUnit = new ComputeUnit_1.default(buildin_1.buildinEffects.cRTSS, { x: Math.ceil(renderEnv_1.default.width / 16), y: Math.ceil(renderEnv_1.default.height / 16) }, {
                u_output: output,
                u_matId2TexturesId: _commonUniforms.matId2TexturesId,
                u_baseColorFactors: _commonUniforms.baseColorFactors,
                u_metallicRoughnessFactorNormalScaleMaterialTypes: _commonUniforms.metallicRoughnessFactorNormalScaleMaterialTypes,
                u_specularGlossinessFactors: _commonUniforms.specularGlossinessFactors,
                u_baseColorTextures: _commonUniforms.baseColorTextures,
                u_normalTextures: _commonUniforms.normalTextures,
                u_metalRoughOrSpecGlossTextures: _commonUniforms.metalRoughOrSpecGlossTextures,
                u_bvh: _bvh.buffer,
            }, { BVH_DEPTH: _this._bvh.maxDepth });
            var values = geometry.getValues('position');
            _this._rtUnit.setUniform('u_positions', values.cpu, values.gpu);
            values = geometry.getValues('texcoord_0');
            _this._rtUnit.setUniform('u_uvs', values.cpu, values.gpu);
            values = geometry.getValues('normal');
            _this._rtUnit.setUniform('u_normals', values.cpu, values.gpu);
            values = geometry.getValues('meshmatindex');
            _this._rtUnit.setUniform('u_meshMatIndexes', values.cpu, values.gpu);
            console.log(_this._materials);
        };
        _this._bvh = new BVH_1.default(_maxPrimitivesPerBVHLeaf);
        return _this;
    }
    Object.defineProperty(RayTracingManager.prototype, "gBufferMesh", {
        get: function () {
            return this._gBufferMesh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RayTracingManager.prototype, "rtUnit", {
        get: function () {
            return this._rtUnit;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RayTracingManager.prototype, "bvhDebugMesh", {
        get: function () {
            return this._bvh.debugMesh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RayTracingManager.prototype, "bvh", {
        get: function () {
            return this._bvh;
        },
        enumerable: false,
        configurable: true
    });
    RayTracingManager.prototype.process = function (meshes, output) {
        this.meshes = meshes;
        shared_1.callWithProfile('build AttributeBuffers', this._buildAttributeBuffers, [meshes]);
        shared_1.callWithProfile('build CommonUniforms', this._buildCommonUniforms, [this._materials]);
        shared_1.callWithProfile('build GBufferMesh', this._buildGBufferMesh, []);
        this._bvh.process(this._attributesInfo.position.value, this._indexInfo.value);
        shared_1.callWithProfile('build RTUnit', this._buildRTUnit, [output]);
        console.log("Build done(max primitives per leaf is " + this._maxPrimitivesPerBVHLeaf + "): mesh(" + meshes.length + "), material(" + this._materials.length + "), vertexes(" + this._attributesInfo.position.value.length / 3 + "), triangles(" + this._indexInfo.value.length / 3 + "), bvhNodes(" + this._bvh.nodesCount + "), bvhLeaves(" + this._bvh.leavesCount + "), bvhDepth(" + this._bvh.maxDepth + ")");
    };
    RayTracingManager.prototype._copyAttribute = function (src, dst, attrOffset, index, transform, isQuat) {
        var srcOffset = src.offset + index * src.stride;
        var srcData = src.data.slice(srcOffset, srcOffset + src.length);
        transform &&
            (isQuat
                ? gl_matrix_1.vec3.transformQuat(srcData, srcData, transform)
                : gl_matrix_1.vec3.transformMat4(srcData, srcData, transform));
        dst.value.set(srcData, (attrOffset + index) * dst.length);
    };
    RayTracingManager.prototype._setTextures = function (offset, textures, texture, matId2TexturesId) {
        if (texture) {
            var idx = textures.indexOf(texture);
            if (idx < 0) {
                textures.push(texture);
                idx = textures.length - 1;
            }
            matId2TexturesId[offset] = idx;
        }
    };
    RayTracingManager.prototype._generateTextureArray = function (textures) {
        if (!textures.length) {
            return buildin_1.buildinTextures.array1white;
        }
        var width = 0;
        var height = 0;
        textures.forEach(function (tex) {
            width = Math.max(width, tex.width);
            height = Math.max(height, tex.height);
        });
        var images = textures.map(function (tex) {
            if (tex.width === width && tex.height === height) {
                return tex.source;
            }
            if (!(tex.source instanceof ImageBitmap)) {
                throw new Error('Can only resize image bitmap!');
            }
            if (!RayTracingManager.RESIZE_CANVAS) {
                RayTracingManager.RESIZE_CANVAS = document.createElement('canvas');
                RayTracingManager.RESIZE_CANVAS.width = 2048;
                RayTracingManager.RESIZE_CANVAS.height = 2048;
                RayTracingManager.RESIZE_CTX = RayTracingManager.RESIZE_CANVAS.getContext('2d');
            }
            var ctx = RayTracingManager.RESIZE_CTX;
            ctx.drawImage(tex.source, 0, 0, width, height);
            return ctx.getImageData(0, 0, width, height).data.buffer;
        });
        return new Texture_1.default(width, height, images, textures[0].format);
    };
    RayTracingManager.CLASS_NAME = 'RayTracingManager';
    return RayTracingManager;
}(HObject_1.default));
exports["default"] = RayTracingManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmF5VHJhY2luZ01hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJSYXlUcmFjaW5nTWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsdUNBQXVDO0FBQ3ZDLHNDQUE2RDtBQUM3RCxtREFBOEM7QUFDOUMsNkNBQXdDO0FBQ3hDLDJDQUFzQztBQUN0Qyw2Q0FBd0M7QUFDeEMscUNBQWdDO0FBQ2hDLCtDQUEwQztBQUUxQyx5Q0FBOEU7QUFDOUUsMkNBQXNDO0FBQ3RDLDZCQUF3QjtBQU12QixDQUFDO0FBRUYsSUFBWSxnQkFLWDtBQUxELFdBQVksZ0JBQWdCO0lBQzFCLHFFQUFXLENBQUE7SUFDWCxtRUFBVSxDQUFBO0lBQ1YsaUZBQWlCLENBQUE7SUFDakIsK0VBQWdCLENBQUE7QUFDbEIsQ0FBQyxFQUxXLGdCQUFnQixHQUFoQix3QkFBZ0IsS0FBaEIsd0JBQWdCLFFBSzNCO0FBQUEsQ0FBQztBQUVGO0lBQStDLHFDQUFPO0lBOENwRCwyQkFBc0Isd0JBQW9DO1FBQXBDLHlDQUFBLEVBQUEsNEJBQW9DO1FBQTFELFlBQ0UsaUJBQU8sU0FHUjtRQUpxQiw4QkFBd0IsR0FBeEIsd0JBQXdCLENBQVk7UUExQ25ELHlCQUFtQixHQUFZLElBQUksQ0FBQztRQVlqQyxnQkFBVSxHQUFlLEVBQUUsQ0FBQztRQWdENUIsNEJBQXNCLEdBQUcsVUFBQyxNQUFjO1lBQ3hDLElBQUEsVUFBVSxHQUFLLEtBQUksV0FBVCxDQUFVO1lBRTVCLElBQUksVUFBVSxHQUFXLENBQUMsQ0FBQztZQUMzQixJQUFJLFdBQVcsR0FBVyxDQUFDLENBQUM7WUFDNUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUk7Z0JBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztnQkFDekMsVUFBVSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFD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QyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFOUQsT0FBTyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUE7UUFFRixPQUFPLElBQUksaUJBQU8sQ0FDaEIsS0FBSyxFQUFFLE1BQU0sRUFDYixNQUFNLEVBQ04sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FDbkIsQ0FBQztJQUNKLENBQUM7SUE5UWEsNEJBQVUsR0FBVyxtQkFBbUIsQ0FBQztJQWtWekQsd0JBQUM7Q0FBQSxBQW5WRCxDQUErQyxpQkFBTyxHQW1WckQ7a0JBblZvQixpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBGaWxlICAgOiBSYXlUcmFjaW5nTWFuYWdlci50c1xuICogQEF1dGhvciA6IGR0eXNreSAoZHR5c2t5QG91dGxvb2suY29tKVxuICogQExpbmsgICA6IGR0eXNreS5tb2VcbiAqIEBEYXRlICAgOiA2LzE5LzIwMjEsIDEwOjUzOjIxIFBNXG4gKi9cbmltcG9ydCB7IG1hdDQsIHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHsgYnVpbGRpbkVmZmVjdHMsIGJ1aWxkaW5UZXh0dXJlcyB9IGZyb20gJy4uL2J1aWxkaW4nO1xuaW1wb3J0IENvbXB1dGVVbml0IGZyb20gJy4uL2NvcmUvQ29tcHV0ZVVuaXQnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL2NvcmUvR2VvbWV0cnknO1xuaW1wb3J0IEhPYmplY3QgZnJvbSAnLi4vY29yZS9IT2JqZWN0JztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuLi9jb3JlL01hdGVyaWFsJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL2NvcmUvTWVzaCc7XG5pbXBvcnQgcmVuZGVyRW52IGZyb20gJy4uL2NvcmUvcmVuZGVyRW52JztcbmltcG9ydCBSZW5kZXJUZXh0dXJlIGZyb20gJy4uL2NvcmUvUmVuZGVyVGV4dHVyZSc7XG5pbXBvcnQgeyBjYWxsV2l0aFByb2ZpbGUsIFRUZXh0dXJlU291cmNlLCBUVHlwZWRBcnJheSB9IGZyb20gJy4uL2NvcmUvc2hhcmVkJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uL2NvcmUvVGV4dHVyZSc7XG5pbXBvcnQgQlZIIGZyb20gJy4vQlZIJztcblxuZXhwb3J0IGludGVyZmFjZSBJQlZIQXR0cmlidXRlVmFsdWU8VEFycmF5VHlwZSA9IEZsb2F0MzJBcnJheT4ge1xuICB2YWx1ZTogVEFycmF5VHlwZTtcbiAgbGVuZ3RoOiBudW1iZXI7XG4gIGZvcm1hdDogR1BVVmVydGV4Rm9ybWF0O1xufTtcblxuZXhwb3J0IGVudW0gRVBCUk1hdGVyaWFsVHlwZSB7XG4gIE1FVEFMX1JPVUdILFxuICBTUEVDX0dMT1NTLFxuICBHTEFTU19NRVRBTF9ST1VHSCxcbiAgR0xBU1NfU1BFQ19HTE9TU1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmF5VHJhY2luZ01hbmFnZXIgZXh0ZW5kcyBIT2JqZWN0IHtcbiAgcHVibGljIHN0YXRpYyBDTEFTU19OQU1FOiBzdHJpbmcgPSAnUmF5VHJhY2luZ01hbmFnZXInO1xuICBwdWJsaWMgc3RhdGljIFJFU0laRV9DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xuICBwdWJsaWMgc3RhdGljIFJFU0laRV9DVFg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgcHVibGljIGlzUmF5VHJhY2luZ01hbmFnZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHB1YmxpYyBtZXNoZXM6IE1lc2hbXTtcbiAgcHJvdGVjdGVkIF9hdHRyaWJ1dGVzSW5mbzoge1xuICAgIHBvc2l0aW9uOiBJQlZIQXR0cmlidXRlVmFsdWUsXG4gICAgdGV4Y29vcmRfMDogSUJWSEF0dHJpYnV0ZVZhbHVlLFxuICAgIG5vcm1hbDogSUJWSEF0dHJpYnV0ZVZhbHVlLFxuICAgIG1lc2hNYXRJbmRleDogSUJWSEF0dHJpYnV0ZVZhbHVlPFVpbnQzMkFycmF5PlxuICB9O1xuICBwcm90ZWN0ZWQgX2luZGV4SW5mbzoge1xuICAgIHZhbHVlOiBVaW50MzJBcnJheVxuICB9O1xuICBwcm90ZWN0ZWQgX21hdGVyaWFsczogTWF0ZXJpYWxbXSA9IFtdO1xuICBwcm90ZWN0ZWQgX2NvbW1vblVuaWZvcm1zOiB7XG4gICAgbWF0SWQyVGV4dHVyZXNJZDogSW50MzJBcnJheTtcbiAgICBiYXNlQ29sb3JGYWN0b3JzOiBGbG9hdDMyQXJyYXk7XG4gICAgbWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXM6IEZsb2F0MzJBcnJheTtcbiAgICBzcGVjdWxhckdsb3NzaW5lc3NGYWN0b3JzOiBGbG9hdDMyQXJyYXk7XG4gICAgYmFzZUNvbG9yVGV4dHVyZXM6IFRleHR1cmU7XG4gICAgbm9ybWFsVGV4dHVyZXM6IFRleHR1cmU7XG4gICAgbWV0YWxSb3VnaE9yU3BlY0dsb3NzVGV4dHVyZXM6IFRleHR1cmU7XG4gIH07XG4gIHByb3RlY3RlZCBfYnZoOiBCVkg7XG4gIHByb3RlY3RlZCBfZ0J1ZmZlck1lc2g6IE1lc2g7XG4gIHByb3RlY3RlZCBfcnRVbml0OiBDb21wdXRlVW5pdDtcblxuICBnZXQgZ0J1ZmZlck1lc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dCdWZmZXJNZXNoO1xuICB9XG5cbiAgZ2V0IHJ0VW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnRVbml0O1xuICB9XG5cbiAgZ2V0IGJ2aERlYnVnTWVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnZoLmRlYnVnTWVzaDtcbiAgfVxuXG4gIGdldCBidmgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J2aDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfbWF4UHJpbWl0aXZlc1BlckJWSExlYWY6IG51bWJlciA9IDEpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYnZoID0gbmV3IEJWSChfbWF4UHJpbWl0aXZlc1BlckJWSExlYWYpO1xuICB9XG5cbiAgLy8gYmF0Y2ggYWxsIG1lc2hlcyBhbmQgYnVpbGQgYnZoXG4gIHB1YmxpYyBwcm9jZXNzKG1lc2hlczogTWVzaFtdLCBvdXRwdXQ6IFJlbmRlclRleHR1cmUpIHtcbiAgICB0aGlzLm1lc2hlcyA9IG1lc2hlcztcbiAgICBjYWxsV2l0aFByb2ZpbGUoJ2J1aWxkIEF0dHJpYnV0ZUJ1ZmZlcnMnLCB0aGlzLl9idWlsZEF0dHJpYnV0ZUJ1ZmZlcnMsIFttZXNoZXNdKTtcbiAgICBjYWxsV2l0aFByb2ZpbGUoJ2J1aWxkIENvbW1vblVuaWZvcm1zJywgdGhpcy5fYnVpbGRDb21tb25Vbmlmb3JtcywgW3RoaXMuX21hdGVyaWFsc10pO1xuICAgIGNhbGxXaXRoUHJvZmlsZSgnYnVpbGQgR0J1ZmZlck1lc2gnLCB0aGlzLl9idWlsZEdCdWZmZXJNZXNoLCBbXSk7XG4gICAgdGhpcy5fYnZoLnByb2Nlc3ModGhpcy5fYXR0cmlidXRlc0luZm8ucG9zaXRpb24udmFsdWUgYXMgRmxvYXQzMkFycmF5LCB0aGlzLl9pbmRleEluZm8udmFsdWUpO1xuICAgIGNhbGxXaXRoUHJvZmlsZSgnYnVpbGQgUlRVbml0JywgdGhpcy5fYnVpbGRSVFVuaXQsIFtvdXRwdXRdKTtcblxuICAgIGNvbnNvbGUubG9nKGBCdWlsZCBkb25lKG1heCBwcmltaXRpdmVzIHBlciBsZWFmIGlzICR7dGhpcy5fbWF4UHJpbWl0aXZlc1BlckJWSExlYWZ9KTogbWVzaCgke21lc2hlcy5sZW5ndGh9KSwgbWF0ZXJpYWwoJHt0aGlzLl9tYXRlcmlhbHMubGVuZ3RofSksIHZlcnRleGVzKCR7dGhpcy5fYXR0cmlidXRlc0luZm8ucG9zaXRpb24udmFsdWUubGVuZ3RoIC8gM30pLCB0cmlhbmdsZXMoJHt0aGlzLl9pbmRleEluZm8udmFsdWUubGVuZ3RoIC8gM30pLCBidmhOb2Rlcygke3RoaXMuX2J2aC5ub2Rlc0NvdW50fSksIGJ2aExlYXZlcygke3RoaXMuX2J2aC5sZWF2ZXNDb3VudH0pLCBidmhEZXB0aCgke3RoaXMuX2J2aC5tYXhEZXB0aH0pYCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2J1aWxkQXR0cmlidXRlQnVmZmVycyA9IChtZXNoZXM6IE1lc2hbXSkgPT4ge1xuICAgIGNvbnN0IHsgX21hdGVyaWFscyB9ID0gdGhpcztcblxuICAgIGxldCBpbmRleENvdW50OiBudW1iZXIgPSAwO1xuICAgIGxldCB2ZXJ0ZXhDb3VudDogbnVtYmVyID0gMDtcbiAgICBtZXNoZXMuZm9yRWFjaChtZXNoID0+IHtcbiAgICAgIHZlcnRleENvdW50ICs9IG1lc2guZ2VvbWV0cnkudmVydGV4Q291bnQ7XG4gICAgICBpbmRleENvdW50ICs9IG1lc2guZ2VvbWV0cnkuY291bnQ7XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHZhbHVlOiBpbmRleGVzIH0gPSB0aGlzLl9pbmRleEluZm8gPSB7XG4gICAgICB2YWx1ZTogbmV3IFVpbnQzMkFycmF5KGluZGV4Q291bnQpXG4gICAgfTtcblxuICAgIGNvbnN0IHsgcG9zaXRpb24sIHRleGNvb3JkXzAsIG5vcm1hbCwgbWVzaE1hdEluZGV4IH0gPSB0aGlzLl9hdHRyaWJ1dGVzSW5mbyA9IHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIC8vIGFsaWdubWVudCBvZiB2ZWMzIGlzIDE2Ynl0ZXMhXG4gICAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogNCksXG4gICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngzJ1xuICAgICAgfSxcbiAgICAgIHRleGNvb3JkXzA6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4Q291bnQgKiAyKSxcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICBmb3JtYXQ6ICdmbG9hdDMyeDInXG4gICAgICB9LFxuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIC8vIGFsaWdubWVudCBvZiB2ZWMzIGlzIDE2Ynl0ZXMhXG4gICAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogNCksXG4gICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngzJ1xuICAgICAgfSxcbiAgICAgIG1lc2hNYXRJbmRleDoge1xuICAgICAgICB2YWx1ZTogbmV3IFVpbnQzMkFycmF5KHZlcnRleENvdW50ICogMiksXG4gICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgZm9ybWF0OiAndWludDMyeDInXG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBhdHRyT2Zmc2V0OiBudW1iZXIgPSAwO1xuICAgIGxldCBpbmRleE9mZnNldDogbnVtYmVyID0gMDtcblxuICAgIGZvciAobGV0IG1lc2hJbmRleCA9IDA7IG1lc2hJbmRleCA8IG1lc2hlcy5sZW5ndGg7IG1lc2hJbmRleCArPSAxKSB7XG4gICAgICBjb25zdCBtZXNoID0gbWVzaGVzW21lc2hJbmRleF07XG4gICAgICBjb25zdCB7d29ybGRNYXR9ID0gbWVzaDtcbiAgICAgIGNvbnN0IHF1YXQgPSBtYXQ0LmdldFJvdGF0aW9uKG5ldyBGbG9hdDMyQXJyYXkoNCksIHdvcmxkTWF0KSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCB7IGdlb21ldHJ5LCBtYXRlcmlhbCB9ID0gbWVzaDtcbiAgICAgIGNvbnN0IHsgaW5kZXhEYXRhLCB2ZXJ0ZXhJbmZvLCB2ZXJ0ZXhDb3VudCwgY291bnQgfSA9IGdlb21ldHJ5O1xuXG4gICAgICBpZiAobWF0ZXJpYWwuZWZmZWN0Lm5hbWUgIT09ICdyUEJSJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3VwcG9ydCBFZmZlY3QgclBCUiEnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGVyaWFsSW5kZXggPSBfbWF0ZXJpYWxzLmluZGV4T2YobWF0ZXJpYWwpO1xuICAgICAgaWYgKG1hdGVyaWFsSW5kZXggPCAwKSB7XG4gICAgICAgIF9tYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XG4gICAgICAgIG1hdGVyaWFsSW5kZXggPSBfbWF0ZXJpYWxzLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGluZGV4RGF0YS5mb3JFYWNoKCh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGluZGV4ZXNbaW5kZXggKyBpbmRleE9mZnNldF0gPSB2YWx1ZSArIGF0dHJPZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF2ZXJ0ZXhJbmZvLm5vcm1hbCkge1xuICAgICAgICBnZW9tZXRyeS5jYWxjdWxhdGVOb3JtYWxzKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2ZXJ0ZXhDb3VudDsgaW5kZXggKz0gMSkge1xuICAgICAgICB0aGlzLl9jb3B5QXR0cmlidXRlKHZlcnRleEluZm8ucG9zaXRpb24sIHBvc2l0aW9uLCBhdHRyT2Zmc2V0LCBpbmRleCwgd29ybGRNYXQpO1xuICAgICAgICB0aGlzLl9jb3B5QXR0cmlidXRlKHZlcnRleEluZm8udGV4Y29vcmRfMCwgdGV4Y29vcmRfMCwgYXR0ck9mZnNldCwgaW5kZXgpO1xuICAgICAgICB0aGlzLl9jb3B5QXR0cmlidXRlKHZlcnRleEluZm8ubm9ybWFsLCBub3JtYWwsIGF0dHJPZmZzZXQsIGluZGV4LCBxdWF0LCB0cnVlKTtcblxuICAgICAgICBtZXNoTWF0SW5kZXgudmFsdWUuc2V0KFttZXNoSW5kZXgsIG1hdGVyaWFsSW5kZXhdLCAoYXR0ck9mZnNldCArIGluZGV4KSAqIG1lc2hNYXRJbmRleC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpbmRleE9mZnNldCArPSBjb3VudDtcbiAgICAgIGF0dHJPZmZzZXQgKz0gdmVydGV4Q291bnQ7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb3B5QXR0cmlidXRlKFxuICAgIHNyYzogeyBvZmZzZXQ6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIGRhdGE6IFRUeXBlZEFycmF5LCBsZW5ndGg6IG51bWJlciB9LFxuICAgIGRzdDogSUJWSEF0dHJpYnV0ZVZhbHVlLCBhdHRyT2Zmc2V0OiBudW1iZXIsIGluZGV4OiBudW1iZXIsXG4gICAgdHJhbnNmb3JtPzogRmxvYXQzMkFycmF5LCBpc1F1YXQ/OiBib29sZWFuXG4gICkge1xuICAgIGNvbnN0IHNyY09mZnNldCA9IHNyYy5vZmZzZXQgKyBpbmRleCAqIHNyYy5zdHJpZGU7XG4gICAgbGV0IHNyY0RhdGEgPSBzcmMuZGF0YS5zbGljZShzcmNPZmZzZXQsIHNyY09mZnNldCArIHNyYy5sZW5ndGgpIGFzIEZsb2F0MzJBcnJheTtcblxuICAgIHRyYW5zZm9ybSAmJlxuICAgICAgKGlzUXVhdFxuICAgICAgICA/IHZlYzMudHJhbnNmb3JtUXVhdChzcmNEYXRhLCBzcmNEYXRhLCB0cmFuc2Zvcm0pXG4gICAgICAgIDogdmVjMy50cmFuc2Zvcm1NYXQ0KHNyY0RhdGEsIHNyY0RhdGEsIHRyYW5zZm9ybSlcbiAgICAgICk7XG5cbiAgICBkc3QudmFsdWUuc2V0KFxuICAgICAgc3JjRGF0YSxcbiAgICAgIChhdHRyT2Zmc2V0ICsgaW5kZXgpICogZHN0Lmxlbmd0aFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2J1aWxkQ29tbW9uVW5pZm9ybXMgPSAobWF0ZXJpYWxzOiBNYXRlcmlhbFtdKSA9PiB7XG4gICAgY29uc3QgbWF0SWQyVGV4dHVyZXNJZCA9IG5ldyBJbnQzMkFycmF5KG1hdGVyaWFscy5sZW5ndGggKiA0KS5maWxsKC0xKTtcbiAgICBjb25zdCBiYXNlQ29sb3JGYWN0b3JzID0gbmV3IEZsb2F0MzJBcnJheShtYXRlcmlhbHMubGVuZ3RoICogNCkuZmlsbCgxKTtcbiAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzc0ZhY3Rvck5vcm1hbFNjYWxlTWF0ZXJpYWxUeXBlcyA9IG5ldyBGbG9hdDMyQXJyYXkobWF0ZXJpYWxzLmxlbmd0aCAqIDQpLmZpbGwoMSk7XG4gICAgY29uc3Qgc3BlY3VsYXJHbG9zc2luZXNzRmFjdG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkobWF0ZXJpYWxzLmxlbmd0aCAqIDQpLmZpbGwoMSk7XG4gICAgY29uc3QgYmFzZUNvbG9yVGV4dHVyZXM6IFRleHR1cmVbXSA9IFtdO1xuICAgIGNvbnN0IG5vcm1hbFRleHR1cmVzOiBUZXh0dXJlW10gPSBbXTtcbiAgICBjb25zdCBtZXRhbFJvdWdoT3JTcGVjR2xvc3NUZXh0dXJlczogVGV4dHVyZVtdID0gW107XG5cbiAgICBtYXRlcmlhbHMuZm9yRWFjaCgobWF0LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdXNlR2xhc3MgPSBtYXQubWFyY29zWydVU0VfR0xBU1MnXTtcbiAgICAgIGNvbnN0IHVzZVNwZWNHbG9zcyA9IG1hdC5tYXJjb3NbJ1VTRV9TUEVDX0dMT1NTJ107XG4gICAgICBjb25zdCBiYXNlQ29sb3JGYWN0b3IgPSBtYXQuZ2V0VW5pZm9ybSgndV9iYXNlQ29sb3JGYWN0b3InKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBtZXRhbGxpY0ZhY3RvciA9IG1hdC5nZXRVbmlmb3JtKCd1X21ldGFsbGljRmFjdG9yJykgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgY29uc3Qgcm91Z2huZXNzRmFjdG9yID0gbWF0LmdldFVuaWZvcm0oJ3Vfcm91Z2huZXNzRmFjdG9yJykgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgY29uc3Qgc3BlY3VsYXJGYWN0b3IgPSBtYXQuZ2V0VW5pZm9ybSgndV9zcGVjdWxhckZhY3RvcicpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIGNvbnN0IGdsb3NzaW5lc3NGYWN0b3IgPSBtYXQuZ2V0VW5pZm9ybSgndV9nbG9zc2luZXNzRmFjdG9yJykgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgY29uc3Qgbm9ybWFsU2NhbGUgPSBtYXQuZ2V0VW5pZm9ybSgndV9ub3JtYWxUZXh0dXJlU2NhbGUnKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBiYXNlQ29sb3JUZXh0dXJlID0gbWF0LmdldFVuaWZvcm0oJ3VfYmFzZUNvbG9yVGV4dHVyZScpIGFzIFRleHR1cmU7XG4gICAgICBjb25zdCBub3JtYWxUZXh0dXJlID0gbWF0LmdldFVuaWZvcm0oJ3Vfbm9ybWFsVGV4dHVyZScpIGFzIFRleHR1cmU7XG4gICAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgPSBtYXQuZ2V0VW5pZm9ybSgndV9tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUnKSBhcyBUZXh0dXJlO1xuICAgICAgY29uc3Qgc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSA9IG1hdC5nZXRVbmlmb3JtKCd1X3NwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUnKSBhcyBUZXh0dXJlO1xuXG4gICAgICBjb25zdCBtaWQgPSBpbmRleCAqIDQ7XG4gICAgICBiYXNlQ29sb3JUZXh0dXJlICE9PSBidWlsZGluVGV4dHVyZXMuZW1wdHkgJiYgdGhpcy5fc2V0VGV4dHVyZXMobWlkLCBiYXNlQ29sb3JUZXh0dXJlcywgYmFzZUNvbG9yVGV4dHVyZSwgbWF0SWQyVGV4dHVyZXNJZCk7XG4gICAgICBub3JtYWxUZXh0dXJlICE9PSBidWlsZGluVGV4dHVyZXMuZW1wdHkgJiYgdGhpcy5fc2V0VGV4dHVyZXMobWlkICsgMSwgbm9ybWFsVGV4dHVyZXMsIG5vcm1hbFRleHR1cmUsIG1hdElkMlRleHR1cmVzSWQpO1xuICAgICAgYmFzZUNvbG9yRmFjdG9yICYmIGJhc2VDb2xvckZhY3RvcnMuc2V0KGJhc2VDb2xvckZhY3RvciwgaW5kZXggKiA0KTtcbiAgICAgIG5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgJiYgbWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXMuc2V0KG5vcm1hbFNjYWxlLnNsaWNlKDAsIDEpLCBpbmRleCAqIDQgKyAyKTtcblxuICAgICAgaWYgKHVzZVNwZWNHbG9zcykge1xuICAgICAgICBzcGVjdWxhckZhY3RvciAhPT0gdW5kZWZpbmVkICYmIHNwZWN1bGFyR2xvc3NpbmVzc0ZhY3RvcnMuc2V0KHNwZWN1bGFyRmFjdG9yLnNsaWNlKDAsIDMpLCBpbmRleCAqIDQpO1xuICAgICAgICBnbG9zc2luZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgc3BlY3VsYXJHbG9zc2luZXNzRmFjdG9ycy5zZXQoZ2xvc3NpbmVzc0ZhY3Rvci5zbGljZSgwLCAxKSwgaW5kZXggKiA0ICsgMyk7XG4gICAgICAgIHNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUgIT09IGJ1aWxkaW5UZXh0dXJlcy5lbXB0eSAmJiB0aGlzLl9zZXRUZXh0dXJlcyhtaWQgKyAyLCBtZXRhbFJvdWdoT3JTcGVjR2xvc3NUZXh0dXJlcywgc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSwgbWF0SWQyVGV4dHVyZXNJZCk7XG4gICAgICAgIG1ldGFsbGljUm91Z2huZXNzRmFjdG9yTm9ybWFsU2NhbGVNYXRlcmlhbFR5cGVzLnNldChbdXNlR2xhc3MgPyBFUEJSTWF0ZXJpYWxUeXBlLkdMQVNTX1NQRUNfR0xPU1MgOiBFUEJSTWF0ZXJpYWxUeXBlLlNQRUNfR0xPU1NdLCBpbmRleCAqIDQgKyAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFsbGljRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgbWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXMuc2V0KG1ldGFsbGljRmFjdG9yLnNsaWNlKDAsIDEpLCBpbmRleCAqIDQpO1xuICAgICAgICByb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCAmJiBtZXRhbGxpY1JvdWdobmVzc0ZhY3Rvck5vcm1hbFNjYWxlTWF0ZXJpYWxUeXBlcy5zZXQocm91Z2huZXNzRmFjdG9yLnNsaWNlKDAsIDEpLCBpbmRleCAqIDQgKyAxKTtcbiAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSBidWlsZGluVGV4dHVyZXMuZW1wdHkgJiYgdGhpcy5fc2V0VGV4dHVyZXMobWlkICsgMiwgbWV0YWxSb3VnaE9yU3BlY0dsb3NzVGV4dHVyZXMsIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSwgbWF0SWQyVGV4dHVyZXNJZCk7XG4gICAgICAgIG1ldGFsbGljUm91Z2huZXNzRmFjdG9yTm9ybWFsU2NhbGVNYXRlcmlhbFR5cGVzLnNldChbdXNlR2xhc3MgPyBFUEJSTWF0ZXJpYWxUeXBlLkdMQVNTX01FVEFMX1JPVUdIIDogRVBCUk1hdGVyaWFsVHlwZS5NRVRBTF9ST1VHSF0sIGluZGV4ICogNCArIDMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fY29tbW9uVW5pZm9ybXMgPSB7XG4gICAgICBtYXRJZDJUZXh0dXJlc0lkLFxuICAgICAgYmFzZUNvbG9yRmFjdG9ycyxcbiAgICAgIG1ldGFsbGljUm91Z2huZXNzRmFjdG9yTm9ybWFsU2NhbGVNYXRlcmlhbFR5cGVzLFxuICAgICAgc3BlY3VsYXJHbG9zc2luZXNzRmFjdG9ycyxcbiAgICAgIGJhc2VDb2xvclRleHR1cmVzOiB0aGlzLl9nZW5lcmF0ZVRleHR1cmVBcnJheShiYXNlQ29sb3JUZXh0dXJlcyksXG4gICAgICBub3JtYWxUZXh0dXJlczogdGhpcy5fZ2VuZXJhdGVUZXh0dXJlQXJyYXkobm9ybWFsVGV4dHVyZXMpLFxuICAgICAgbWV0YWxSb3VnaE9yU3BlY0dsb3NzVGV4dHVyZXM6IHRoaXMuX2dlbmVyYXRlVGV4dHVyZUFycmF5KG1ldGFsUm91Z2hPclNwZWNHbG9zc1RleHR1cmVzKVxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFRleHR1cmVzKFxuICAgIG9mZnNldDogbnVtYmVyLCB0ZXh0dXJlczogVGV4dHVyZVtdLCB0ZXh0dXJlOiBUZXh0dXJlLFxuICAgIG1hdElkMlRleHR1cmVzSWQ6IEludDMyQXJyYXlcbiAgKSB7XG4gICAgaWYgKHRleHR1cmUpIHtcbiAgICAgIGxldCBpZHggPSB0ZXh0dXJlcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgaWR4ID0gdGV4dHVyZXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIG1hdElkMlRleHR1cmVzSWRbb2Zmc2V0XSA9IGlkeDtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dlbmVyYXRlVGV4dHVyZUFycmF5KHRleHR1cmVzOiBUZXh0dXJlW10pOiBUZXh0dXJlIHtcbiAgICBpZiAoIXRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJ1aWxkaW5UZXh0dXJlcy5hcnJheTF3aGl0ZTtcbiAgICB9XG5cbiAgICBsZXQgd2lkdGg6IG51bWJlciA9IDA7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyID0gMDtcblxuICAgIHRleHR1cmVzLmZvckVhY2godGV4ID0+IHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRleC53aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRleC5oZWlnaHQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gdGV4dHVyZXMubWFwKHRleCA9PiB7XG4gICAgICBpZiAodGV4LndpZHRoID09PSB3aWR0aCAmJiB0ZXguaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRleC5zb3VyY2UgYXMgVFRleHR1cmVTb3VyY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRleC5zb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSByZXNpemUgaW1hZ2UgYml0bWFwIScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVJheVRyYWNpbmdNYW5hZ2VyLlJFU0laRV9DQU5WQVMpIHtcbiAgICAgICAgUmF5VHJhY2luZ01hbmFnZXIuUkVTSVpFX0NBTlZBUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBSYXlUcmFjaW5nTWFuYWdlci5SRVNJWkVfQ0FOVkFTLndpZHRoID0gMjA0ODtcbiAgICAgICAgUmF5VHJhY2luZ01hbmFnZXIuUkVTSVpFX0NBTlZBUy5oZWlnaHQgPSAyMDQ4O1xuICAgICAgICBSYXlUcmFjaW5nTWFuYWdlci5SRVNJWkVfQ1RYID0gUmF5VHJhY2luZ01hbmFnZXIuUkVTSVpFX0NBTlZBUy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdHggPSBSYXlUcmFjaW5nTWFuYWdlci5SRVNJWkVfQ1RYO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0ZXguc291cmNlIGFzIEltYWdlQml0bWFwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YS5idWZmZXI7XG4gICAgfSlcblxuICAgIHJldHVybiBuZXcgVGV4dHVyZShcbiAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICBpbWFnZXMsXG4gICAgICB0ZXh0dXJlc1swXS5mb3JtYXRcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9idWlsZEdCdWZmZXJNZXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgX2F0dHJpYnV0ZXNJbmZvLCBfaW5kZXhJbmZvLCBfY29tbW9uVW5pZm9ybXMgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeShcbiAgICAgIE9iamVjdC5rZXlzKF9hdHRyaWJ1dGVzSW5mbykubWFwKChuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBsZW5ndGgsIGZvcm1hdCB9ID0gKF9hdHRyaWJ1dGVzSW5mb1tuYW1lXSBhcyBhbnkpIGFzIElCVkhBdHRyaWJ1dGVWYWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgYXJyYXlTdHJpZGU6IGxlbmd0aCAqIDQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgICBuYW1lLCBvZmZzZXQ6IDAsIGZvcm1hdCwgc2hhZGVyTG9jYXRpb246IGluZGV4XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0VcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfaW5kZXhJbmZvLnZhbHVlLFxuICAgICAgX2luZGV4SW5mby52YWx1ZS5sZW5ndGhcbiAgICApO1xuXG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoYnVpbGRpbkVmZmVjdHMuclJUR0J1ZmZlciwge1xuICAgICAgdV9tYXRJZDJUZXh0dXJlc0lkOiBfY29tbW9uVW5pZm9ybXMubWF0SWQyVGV4dHVyZXNJZCxcbiAgICAgIHVfYmFzZUNvbG9yRmFjdG9yczogX2NvbW1vblVuaWZvcm1zLmJhc2VDb2xvckZhY3RvcnMsXG4gICAgICB1X21ldGFsbGljUm91Z2huZXNzRmFjdG9yTm9ybWFsU2NhbGVNYXRlcmlhbFR5cGVzOiBfY29tbW9uVW5pZm9ybXMubWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXMsXG4gICAgICB1X3NwZWN1bGFyR2xvc3NpbmVzc0ZhY3RvcnM6IF9jb21tb25Vbmlmb3Jtcy5zcGVjdWxhckdsb3NzaW5lc3NGYWN0b3JzLFxuICAgICAgdV9iYXNlQ29sb3JUZXh0dXJlczogX2NvbW1vblVuaWZvcm1zLmJhc2VDb2xvclRleHR1cmVzLFxuICAgICAgdV9ub3JtYWxUZXh0dXJlczogX2NvbW1vblVuaWZvcm1zLm5vcm1hbFRleHR1cmVzLFxuICAgICAgdV9tZXRhbFJvdWdoT3JTcGVjR2xvc3NUZXh0dXJlczogX2NvbW1vblVuaWZvcm1zLm1ldGFsUm91Z2hPclNwZWNHbG9zc1RleHR1cmVzXG4gICAgfSk7XG5cbiAgICB0aGlzLl9nQnVmZmVyTWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2J1aWxkUlRVbml0ID0gKG91dHB1dDogUmVuZGVyVGV4dHVyZSkgPT4ge1xuICAgIGNvbnN0IHsgX2dCdWZmZXJNZXNoLCBfY29tbW9uVW5pZm9ybXMsIF9idmggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gX2dCdWZmZXJNZXNoO1xuXG4gICAgdGhpcy5fcnRVbml0ID0gbmV3IENvbXB1dGVVbml0KFxuICAgICAgYnVpbGRpbkVmZmVjdHMuY1JUU1MsXG4gICAgICB7IHg6IE1hdGguY2VpbChyZW5kZXJFbnYud2lkdGggLyAxNiksIHk6IE1hdGguY2VpbChyZW5kZXJFbnYuaGVpZ2h0IC8gMTYpIH0sXG4gICAgICB7XG4gICAgICAgIHVfb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgIHVfbWF0SWQyVGV4dHVyZXNJZDogX2NvbW1vblVuaWZvcm1zLm1hdElkMlRleHR1cmVzSWQsXG4gICAgICAgIHVfYmFzZUNvbG9yRmFjdG9yczogX2NvbW1vblVuaWZvcm1zLmJhc2VDb2xvckZhY3RvcnMsXG4gICAgICAgIHVfbWV0YWxsaWNSb3VnaG5lc3NGYWN0b3JOb3JtYWxTY2FsZU1hdGVyaWFsVHlwZXM6IF9jb21tb25Vbmlmb3Jtcy5tZXRhbGxpY1JvdWdobmVzc0ZhY3Rvck5vcm1hbFNjYWxlTWF0ZXJpYWxUeXBlcyxcbiAgICAgICAgdV9zcGVjdWxhckdsb3NzaW5lc3NGYWN0b3JzOiBfY29tbW9uVW5pZm9ybXMuc3BlY3VsYXJHbG9zc2luZXNzRmFjdG9ycyxcbiAgICAgICAgdV9iYXNlQ29sb3JUZXh0dXJlczogX2NvbW1vblVuaWZvcm1zLmJhc2VDb2xvclRleHR1cmVzLFxuICAgICAgICB1X25vcm1hbFRleHR1cmVzOiBfY29tbW9uVW5pZm9ybXMubm9ybWFsVGV4dHVyZXMsXG4gICAgICAgIHVfbWV0YWxSb3VnaE9yU3BlY0dsb3NzVGV4dHVyZXM6IF9jb21tb25Vbmlmb3Jtcy5tZXRhbFJvdWdoT3JTcGVjR2xvc3NUZXh0dXJlcyxcbiAgICAgICAgdV9idmg6IF9idmguYnVmZmVyLFxuICAgICAgfSxcbiAgICAgIHtCVkhfREVQVEg6IHRoaXMuX2J2aC5tYXhEZXB0aH1cbiAgICApO1xuXG4gICAgbGV0IHZhbHVlcyA9IGdlb21ldHJ5LmdldFZhbHVlcygncG9zaXRpb24nKTtcbiAgICB0aGlzLl9ydFVuaXQuc2V0VW5pZm9ybSgndV9wb3NpdGlvbnMnLCB2YWx1ZXMuY3B1IGFzIEZsb2F0MzJBcnJheSwgdmFsdWVzLmdwdSk7XG4gICAgdmFsdWVzID0gZ2VvbWV0cnkuZ2V0VmFsdWVzKCd0ZXhjb29yZF8wJyk7XG4gICAgdGhpcy5fcnRVbml0LnNldFVuaWZvcm0oJ3VfdXZzJywgdmFsdWVzLmNwdSBhcyBGbG9hdDMyQXJyYXksIHZhbHVlcy5ncHUpO1xuICAgIHZhbHVlcyA9IGdlb21ldHJ5LmdldFZhbHVlcygnbm9ybWFsJyk7XG4gICAgdGhpcy5fcnRVbml0LnNldFVuaWZvcm0oJ3Vfbm9ybWFscycsIHZhbHVlcy5jcHUgYXMgRmxvYXQzMkFycmF5LCB2YWx1ZXMuZ3B1KTtcbiAgICB2YWx1ZXMgPSBnZW9tZXRyeS5nZXRWYWx1ZXMoJ21lc2htYXRpbmRleCcpO1xuICAgIHRoaXMuX3J0VW5pdC5zZXRVbmlmb3JtKCd1X21lc2hNYXRJbmRleGVzJywgdmFsdWVzLmNwdSBhcyBVaW50MzJBcnJheSwgdmFsdWVzLmdwdSk7XG4gICAgY29uc29sZS5sb2codGhpcy5fbWF0ZXJpYWxzKVxuICB9XG59XG4iXX0=

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.math = exports.init = void 0;
var renderEnv_1 = __webpack_require__(/*! ./core/renderEnv */ "./src/core/renderEnv.ts");
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/_gl-matrix@3.3.0@gl-matrix/esm/index.js");
var Scene_1 = __webpack_require__(/*! ./core/Scene */ "./src/core/Scene.ts");
Object.defineProperty(exports, "Scene", ({ enumerable: true, get: function () { return Scene_1.default; } }));
var Node_1 = __webpack_require__(/*! ./core/Node */ "./src/core/Node.ts");
Object.defineProperty(exports, "Node", ({ enumerable: true, get: function () { return Node_1.default; } }));
var Camera_1 = __webpack_require__(/*! ./core/Camera */ "./src/core/Camera.ts");
Object.defineProperty(exports, "Camera", ({ enumerable: true, get: function () { return Camera_1.default; } }));
var Light_1 = __webpack_require__(/*! ./core/Light */ "./src/core/Light.ts");
Object.defineProperty(exports, "Light", ({ enumerable: true, get: function () { return Light_1.default; } }));
Object.defineProperty(exports, "EAreaLightMode", ({ enumerable: true, get: function () { return Light_1.EAreaLightMode; } }));
Object.defineProperty(exports, "ELightType", ({ enumerable: true, get: function () { return Light_1.ELightType; } }));
var Geometry_1 = __webpack_require__(/*! ./core/Geometry */ "./src/core/Geometry.ts");
Object.defineProperty(exports, "Geometry", ({ enumerable: true, get: function () { return Geometry_1.default; } }));
var UBTemplate_1 = __webpack_require__(/*! ./core/UBTemplate */ "./src/core/UBTemplate.ts");
Object.defineProperty(exports, "UBTemplate", ({ enumerable: true, get: function () { return UBTemplate_1.default; } }));
var Effect_1 = __webpack_require__(/*! ./core/Effect */ "./src/core/Effect.ts");
Object.defineProperty(exports, "Effect", ({ enumerable: true, get: function () { return Effect_1.default; } }));
var Material_1 = __webpack_require__(/*! ./core/Material */ "./src/core/Material.ts");
Object.defineProperty(exports, "Material", ({ enumerable: true, get: function () { return Material_1.default; } }));
var Mesh_1 = __webpack_require__(/*! ./core/Mesh */ "./src/core/Mesh.ts");
Object.defineProperty(exports, "Mesh", ({ enumerable: true, get: function () { return Mesh_1.default; } }));
var ImageMesh_1 = __webpack_require__(/*! ./core/ImageMesh */ "./src/core/ImageMesh.ts");
Object.defineProperty(exports, "ImageMesh", ({ enumerable: true, get: function () { return ImageMesh_1.default; } }));
var ComputeUnit_1 = __webpack_require__(/*! ./core/ComputeUnit */ "./src/core/ComputeUnit.ts");
Object.defineProperty(exports, "ComputeUnit", ({ enumerable: true, get: function () { return ComputeUnit_1.default; } }));
var RenderTexture_1 = __webpack_require__(/*! ./core/RenderTexture */ "./src/core/RenderTexture.ts");
Object.defineProperty(exports, "RenderTexture", ({ enumerable: true, get: function () { return RenderTexture_1.default; } }));
var Texture_1 = __webpack_require__(/*! ./core/Texture */ "./src/core/Texture.ts");
Object.defineProperty(exports, "Texture", ({ enumerable: true, get: function () { return Texture_1.default; } }));
var CubeTexture_1 = __webpack_require__(/*! ./core/CubeTexture */ "./src/core/CubeTexture.ts");
Object.defineProperty(exports, "CubeTexture", ({ enumerable: true, get: function () { return CubeTexture_1.default; } }));
var renderEnv_2 = __webpack_require__(/*! ./core/renderEnv */ "./src/core/renderEnv.ts");
Object.defineProperty(exports, "renderEnv", ({ enumerable: true, get: function () { return renderEnv_2.default; } }));
var RayTracingManager_1 = __webpack_require__(/*! ./extension/RayTracingManager */ "./src/extension/RayTracingManager.ts");
Object.defineProperty(exports, "RayTracingManager", ({ enumerable: true, get: function () { return RayTracingManager_1.default; } }));
var BVH_1 = __webpack_require__(/*! ./extension/BVH */ "./src/extension/BVH.ts");
Object.defineProperty(exports, "BVH", ({ enumerable: true, get: function () { return BVH_1.default; } }));
var NodeControl_1 = __webpack_require__(/*! ./extension/NodeControl */ "./src/extension/NodeControl.ts");
Object.defineProperty(exports, "NodeControl", ({ enumerable: true, get: function () { return NodeControl_1.default; } }));
var resource_1 = __webpack_require__(/*! ./resource */ "./src/resource/index.ts");
Object.defineProperty(exports, "resource", ({ enumerable: true, get: function () { return resource_1.default; } }));
Object.defineProperty(exports, "Resource", ({ enumerable: true, get: function () { return resource_1.Resource; } }));
var TextureLoader_1 = __webpack_require__(/*! ./resource/TextureLoader */ "./src/resource/TextureLoader.ts");
Object.defineProperty(exports, "TextureLoader", ({ enumerable: true, get: function () { return TextureLoader_1.default; } }));
var GlTFLoader_1 = __webpack_require__(/*! ./resource/GlTFLoader */ "./src/resource/GlTFLoader.ts");
Object.defineProperty(exports, "GlTFLoader", ({ enumerable: true, get: function () { return GlTFLoader_1.default; } }));
var buildin_1 = __webpack_require__(/*! ./buildin */ "./src/buildin/index.ts");
__exportStar(__webpack_require__(/*! ./buildin */ "./src/buildin/index.ts"), exports);
var shared_1 = __webpack_require__(/*! ./core/shared */ "./src/core/shared.ts");
Object.defineProperty(exports, "createGPUBuffer", ({ enumerable: true, get: function () { return shared_1.createGPUBuffer; } }));
Object.defineProperty(exports, "createGPUBufferBySize", ({ enumerable: true, get: function () { return shared_1.createGPUBufferBySize; } }));
function init(canvas) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, renderEnv_1.default.init(canvas)];
                case 1:
                    _a.sent();
                    return [4, buildin_1.init()];
                case 2:
                    _a.sent();
                    return [4, renderEnv_1.default.createGlobal(buildin_1.buildinUBTemplates.global)];
                case 3:
                    _a.sent();
                    return [2];
            }
        });
    });
}
exports.init = init;
exports.math = {
    vec2: gl_matrix_1.vec2, vec3: gl_matrix_1.vec3, vec4: gl_matrix_1.vec4,
    quat: gl_matrix_1.quat, quat2: gl_matrix_1.quat2,
    mat2: gl_matrix_1.mat2, mat3: gl_matrix_1.mat3, mat4: gl_matrix_1.mat4
};
window['H'] = this;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsOENBQXlDO0FBQ3pDLHVDQUEwRTtBQUcxRSxzQ0FBOEM7QUFBdEMsOEZBQUEsT0FBTyxPQUFTO0FBQ3hCLG9DQUE0QztBQUFwQyw0RkFBQSxPQUFPLE9BQVE7QUFDdkIsd0NBQWdEO0FBQXhDLGdHQUFBLE9BQU8sT0FBVTtBQUN6QixzQ0FBdUg7QUFBL0csOEZBQUEsT0FBTyxPQUFTO0FBQStDLHVHQUFBLGNBQWMsT0FBQTtBQUFFLG1HQUFBLFVBQVUsT0FBQTtBQUNqRyw0Q0FBb0Q7QUFBNUMsb0dBQUEsT0FBTyxPQUFZO0FBQzNCLGdEQUEyRztBQUFuRyx3R0FBQSxPQUFPLE9BQWM7QUFDN0Isd0NBQWdFO0FBQXhELGdHQUFBLE9BQU8sT0FBVTtBQUN6Qiw0Q0FBb0Q7QUFBNUMsb0dBQUEsT0FBTyxPQUFZO0FBQzNCLG9DQUE0QztBQUFwQyw0RkFBQSxPQUFPLE9BQVE7QUFDdkIsOENBQXNEO0FBQTlDLHNHQUFBLE9BQU8sT0FBYTtBQUM1QixrREFBMEQ7QUFBbEQsMEdBQUEsT0FBTyxPQUFlO0FBQzlCLHNEQUE4RDtBQUF0RCw4R0FBQSxPQUFPLE9BQWlCO0FBQ2hDLDBDQUFrRDtBQUExQyxrR0FBQSxPQUFPLE9BQVc7QUFDMUIsa0RBQTBEO0FBQWxELDBHQUFBLE9BQU8sT0FBZTtBQUM5Qiw4Q0FBc0Q7QUFBOUMsc0dBQUEsT0FBTyxPQUFhO0FBQzVCLG1FQUEyRTtBQUFuRSxzSEFBQSxPQUFPLE9BQXFCO0FBQ3BDLHVDQUErQztBQUF2QywwRkFBQSxPQUFPLE9BQU87QUFDdEIsdURBQStEO0FBQXZELDBHQUFBLE9BQU8sT0FBZTtBQUU5Qix1Q0FBeUQ7QUFBakQsb0dBQUEsT0FBTyxPQUFZO0FBQUUsb0dBQUEsUUFBUSxPQUFBO0FBQ3JDLDBEQUF5RjtBQUFqRiw4R0FBQSxPQUFPLE9BQWlCO0FBQ2hDLG9EQUErRjtBQUF2Rix3R0FBQSxPQUFPLE9BQWM7QUFFN0IscUNBQWtFO0FBQ2xFLDRDQUEwQjtBQUUxQix3Q0FBcUU7QUFBN0QseUdBQUEsZUFBZSxPQUFBO0FBQUUsK0dBQUEscUJBQXFCLE9BQUE7QUFFOUMsU0FBc0IsSUFBSSxDQUFDLE1BQXlCOzs7O3dCQUNsRCxXQUFNLG1CQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFBOztvQkFBNUIsU0FBNEIsQ0FBQztvQkFDN0IsV0FBTSxjQUFXLEVBQUUsRUFBQTs7b0JBQW5CLFNBQW1CLENBQUM7b0JBQ3BCLFdBQU0sbUJBQVMsQ0FBQyxZQUFZLENBQUMsNEJBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUE7O29CQUF2RCxTQUF1RCxDQUFDOzs7OztDQUN6RDtBQUpELG9CQUlDO0FBRVksUUFBQSxJQUFJLEdBQUc7SUFDbEIsSUFBSSxrQkFBQSxFQUFFLElBQUksa0JBQUEsRUFBRSxJQUFJLGtCQUFBO0lBQ2hCLElBQUksa0JBQUEsRUFBRSxLQUFLLG1CQUFBO0lBQ1gsSUFBSSxrQkFBQSxFQUFFLElBQUksa0JBQUEsRUFBRSxJQUFJLGtCQUFBO0NBQ2pCLENBQUE7QUFHRCxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBARmlsZSAgIDogaW5kZXgudHNcbiAqIEBBdXRob3IgOiBkdHlza3kgKGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBMaW5rICAgOiBkdHlza3kubW9lXG4gKiBARGF0ZSAgIDogMjAyMS82LzXkuIvljYgyOjQ0OjA2XG4gKi9cbmltcG9ydCByZW5kZXJFbnYgZnJvbSAnLi9jb3JlL3JlbmRlckVudic7XG5pbXBvcnQge3ZlYzIsIHZlYzMsIHZlYzQsIHF1YXQsIHF1YXQyLCBtYXQyLCBtYXQzLCBtYXQ0fSBmcm9tICdnbC1tYXRyaXgnO1xuXG5leHBvcnQge1RUeXBlZEFycmF5fSBmcm9tICcuL2NvcmUvc2hhcmVkJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTY2VuZX0gZnJvbSAnLi9jb3JlL1NjZW5lJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBOb2RlfSBmcm9tICcuL2NvcmUvTm9kZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQ2FtZXJhfSBmcm9tICcuL2NvcmUvQ2FtZXJhJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBMaWdodCwgSUFyZWFMaWdodE9wdGlvbnMsIElEaXJlY3Rpb25hbExpZ2h0T3B0aW9ucywgRUFyZWFMaWdodE1vZGUsIEVMaWdodFR5cGV9IGZyb20gJy4vY29yZS9MaWdodCc7XG5leHBvcnQge2RlZmF1bHQgYXMgR2VvbWV0cnl9IGZyb20gJy4vY29yZS9HZW9tZXRyeSc7XG5leHBvcnQge2RlZmF1bHQgYXMgVUJUZW1wbGF0ZSwgSVVuaWZvcm1CbG9jaywgSVVuaWZvcm1zRGVzY3JpcHRvciwgVFVuaWZvcm1WYWx1ZX0gZnJvbSAnLi9jb3JlL1VCVGVtcGxhdGUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVmZmVjdCwgVEVmZmVjdE9wdGlvbnN9IGZyb20gJy4vY29yZS9FZmZlY3QnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1hdGVyaWFsfSBmcm9tICcuL2NvcmUvTWF0ZXJpYWwnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1lc2h9IGZyb20gJy4vY29yZS9NZXNoJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbWFnZU1lc2h9IGZyb20gJy4vY29yZS9JbWFnZU1lc2gnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIENvbXB1dGVVbml0fSBmcm9tICcuL2NvcmUvQ29tcHV0ZVVuaXQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFJlbmRlclRleHR1cmV9IGZyb20gJy4vY29yZS9SZW5kZXJUZXh0dXJlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUZXh0dXJlfSBmcm9tICcuL2NvcmUvVGV4dHVyZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQ3ViZVRleHR1cmV9IGZyb20gJy4vY29yZS9DdWJlVGV4dHVyZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgcmVuZGVyRW52fSBmcm9tICcuL2NvcmUvcmVuZGVyRW52JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSYXlUcmFjaW5nTWFuYWdlcn0gZnJvbSAnLi9leHRlbnNpb24vUmF5VHJhY2luZ01hbmFnZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJWSH0gZnJvbSAnLi9leHRlbnNpb24vQlZIJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBOb2RlQ29udHJvbH0gZnJvbSAnLi9leHRlbnNpb24vTm9kZUNvbnRyb2wnO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgcmVzb3VyY2UsIFJlc291cmNlfSBmcm9tICcuL3Jlc291cmNlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUZXh0dXJlTG9hZGVyLCBJVGV4dHVyZUxvYWRlck9wdGlvbnN9IGZyb20gJy4vcmVzb3VyY2UvVGV4dHVyZUxvYWRlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgR2xURkxvYWRlciwgSUdsVEZSZXNvdXJjZSwgSUdsVEZMb2FkZXJPcHRpb25zfSBmcm9tICcuL3Jlc291cmNlL0dsVEZMb2FkZXInO1xuXG5pbXBvcnQge2J1aWxkaW5VQlRlbXBsYXRlcywgaW5pdCBhcyBpbml0QnVpbGRpbn0gZnJvbSAnLi9idWlsZGluJztcbmV4cG9ydCAqIGZyb20gJy4vYnVpbGRpbic7XG5cbmV4cG9ydCB7Y3JlYXRlR1BVQnVmZmVyLCBjcmVhdGVHUFVCdWZmZXJCeVNpemV9IGZyb20gJy4vY29yZS9zaGFyZWQnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gIGF3YWl0IHJlbmRlckVudi5pbml0KGNhbnZhcyk7XG4gIGF3YWl0IGluaXRCdWlsZGluKCk7XG4gIGF3YWl0IHJlbmRlckVudi5jcmVhdGVHbG9iYWwoYnVpbGRpblVCVGVtcGxhdGVzLmdsb2JhbCk7XG59XG5cbmV4cG9ydCBjb25zdCBtYXRoID0ge1xuICB2ZWMyLCB2ZWMzLCB2ZWM0LFxuICBxdWF0LCBxdWF0MixcbiAgbWF0MiwgbWF0MywgbWF0NFxufVxuXG4vL0B0cy1pZ25vcmVcbndpbmRvd1snSCddID0gdGhpcztcbiJdfQ==

/***/ }),

/***/ "./src/resource/GlTFLoader.ts":
/*!************************************!*\
  !*** ./src/resource/GlTFLoader.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var buildin_1 = __webpack_require__(/*! ../buildin */ "./src/buildin/index.ts");
var Node_1 = __webpack_require__(/*! ../core/Node */ "./src/core/Node.ts");
var Camera_1 = __webpack_require__(/*! ../core/Camera */ "./src/core/Camera.ts");
var Geometry_1 = __webpack_require__(/*! ../core/Geometry */ "./src/core/Geometry.ts");
var Material_1 = __webpack_require__(/*! ../core/Material */ "./src/core/Material.ts");
var Mesh_1 = __webpack_require__(/*! ../core/Mesh */ "./src/core/Mesh.ts");
var Texture_1 = __webpack_require__(/*! ../core/Texture */ "./src/core/Texture.ts");
var Loader_1 = __webpack_require__(/*! ./Loader */ "./src/resource/Loader.ts");
var Light_1 = __webpack_require__(/*! ../core/Light */ "./src/core/Light.ts");
var CubeTexture_1 = __webpack_require__(/*! ../core/CubeTexture */ "./src/core/CubeTexture.ts");
var GlTFLoader = (function (_super) {
    __extends(GlTFLoader, _super);
    function GlTFLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isGlTFLoader = true;
        _this._buffers = [];
        return _this;
    }
    GlTFLoader.prototype.load = function (src, options) {
        return __awaiter(this, void 0, void 0, function () {
            var tmp, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tmp = src.split('/');
                        tmp.pop();
                        this._baseUri = tmp.join('/');
                        _a = this;
                        return [4, this.request(src, 'json')];
                    case 1:
                        _a._json = _b.sent();
                        return [4, this._loadBuffers()];
                    case 2:
                        _b.sent();
                        this._res = {
                            rootNode: new Node_1.default(),
                            nodes: [],
                            meshes: [],
                            images: [],
                            textures: [],
                            cubeTextures: [],
                            materials: [],
                            cameras: [],
                            lights: []
                        };
                        return [4, this._loadImages()];
                    case 3:
                        _b.sent();
                        return [4, this._loadTextures()];
                    case 4:
                        _b.sent();
                        return [4, this._loadCubeTextures()];
                    case 5:
                        _b.sent();
                        return [4, this._loadMaterials()];
                    case 6:
                        _b.sent();
                        return [4, this._loadMeshes()];
                    case 7:
                        _b.sent();
                        return [4, this._loadCameras()];
                    case 8:
                        _b.sent();
                        return [4, this._loadLights()];
                    case 9:
                        _b.sent();
                        return [4, this._loadNodes()];
                    case 10:
                        _b.sent();
                        return [2, this._res];
                }
            });
        });
    };
    GlTFLoader.prototype._loadBuffers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var buffers, _i, buffers_1, uri, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        buffers = this._json.buffers;
                        _i = 0, buffers_1 = buffers;
                        _c.label = 1;
                    case 1:
                        if (!(_i < buffers_1.length)) return [3, 4];
                        uri = buffers_1[_i].uri;
                        _b = (_a = this._buffers).push;
                        return [4, this.request(this._baseUri + '/' + uri, 'buffer')];
                    case 2:
                        _b.apply(_a, [_c.sent()]);
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    GlTFLoader.prototype._loadImages = function () {
        return __awaiter(this, void 0, void 0, function () {
            var imagesSrc, images, _i, imagesSrc_1, uri, image, bitmap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        imagesSrc = this._json.images;
                        images = this._res.images;
                        if (!imagesSrc) {
                            return [2];
                        }
                        _i = 0, imagesSrc_1 = imagesSrc;
                        _a.label = 1;
                    case 1:
                        if (!(_i < imagesSrc_1.length)) return [3, 5];
                        uri = imagesSrc_1[_i].uri;
                        return [4, this._loadImage(this._baseUri + '/' + uri)];
                    case 2:
                        image = _a.sent();
                        return [4, createImageBitmap(image)];
                    case 3:
                        bitmap = _a.sent();
                        images.push(bitmap);
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3, 1];
                    case 5: return [2];
                }
            });
        });
    };
    GlTFLoader.prototype._loadTextures = function () {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var _d, texturesSrc, imagesSrc, _e, images, textures, _i, texturesSrc_1, source, image, texture, isRGBD, isNormal;
            return __generator(this, function (_f) {
                _d = this._json, texturesSrc = _d.textures, imagesSrc = _d.images;
                _e = this._res, images = _e.images, textures = _e.textures;
                if (!texturesSrc) {
                    return [2];
                }
                for (_i = 0, texturesSrc_1 = texturesSrc; _i < texturesSrc_1.length; _i++) {
                    source = texturesSrc_1[_i].source;
                    image = images[source];
                    texture = new Texture_1.default(image.width, image.height, image);
                    isRGBD = ((_a = imagesSrc.extras) === null || _a === void 0 ? void 0 : _a.type) === 'HDR' && ((_b = imagesSrc.extras) === null || _b === void 0 ? void 0 : _b.format) === 'RGBD';
                    isNormal = !!((_c = imagesSrc.extras) === null || _c === void 0 ? void 0 : _c.isNormalMap);
                    textures.push(texture);
                }
                return [2];
            });
        });
    };
    GlTFLoader.prototype._loadCubeTextures = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var cubeTexturesSrc, _c, images, cubeTextures, _i, cubeTexturesSrc_1, imageIds, tasks, bms, cubeTexture;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        cubeTexturesSrc = (_b = (_a = this._json.extensions) === null || _a === void 0 ? void 0 : _a.Sein_cubeTexture) === null || _b === void 0 ? void 0 : _b.textures;
                        _c = this._res, images = _c.images, cubeTextures = _c.cubeTextures;
                        if (!cubeTexturesSrc) {
                            return [2];
                        }
                        _i = 0, cubeTexturesSrc_1 = cubeTexturesSrc;
                        _d.label = 1;
                    case 1:
                        if (!(_i < cubeTexturesSrc_1.length)) return [3, 4];
                        imageIds = cubeTexturesSrc_1[_i].images;
                        tasks = Promise.all(imageIds.map(function (imageId) {
                            return createImageBitmap(images[imageId]);
                        }));
                        return [4, tasks];
                    case 2:
                        bms = _d.sent();
                        cubeTexture = new CubeTexture_1.default(bms[0].width, bms[1].width, bms);
                        bms.forEach(function (bm) { return bm.close(); });
                        cubeTextures.push(cubeTexture);
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    GlTFLoader.prototype._loadMaterials = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _buffers, materialsSrc, _a, materials, textures, _i, materialsSrc_1, _b, name_1, pbrMetallicRoughness, normalTexture, alphaMode, extensions, effect, uniforms, marcos, baseColorTexture, metallicFactor, baseColorFactor, roughnessFactor, metallicRoughnessTexture, _c, diffuseFactor, diffuseTexture, specularFactor, glossinessFactor, specularGlossinessTexture, material;
            return __generator(this, function (_d) {
                _buffers = this._buffers;
                materialsSrc = this._json.materials;
                _a = this._res, materials = _a.materials, textures = _a.textures;
                for (_i = 0, materialsSrc_1 = materialsSrc; _i < materialsSrc_1.length; _i++) {
                    _b = materialsSrc_1[_i], name_1 = _b.name, pbrMetallicRoughness = _b.pbrMetallicRoughness, normalTexture = _b.normalTexture, alphaMode = _b.alphaMode, extensions = _b.extensions;
                    effect = buildin_1.buildinEffects.rPBR;
                    uniforms = {};
                    marcos = {};
                    if (normalTexture) {
                        uniforms['u_normalTexture'] = textures[normalTexture.index];
                        uniforms['u_normalTextureScale'] = normalTexture.scale;
                    }
                    if (pbrMetallicRoughness) {
                        baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, baseColorFactor = pbrMetallicRoughness.baseColorFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
                        if (baseColorTexture) {
                            uniforms['u_baseColorTexture'] = textures[baseColorTexture.index];
                        }
                        if (metallicRoughnessTexture) {
                            uniforms['u_metallicRoughnessTexture'] = textures[metallicRoughnessTexture.index];
                        }
                        uniforms['u_baseColorFactor'] = baseColorFactor;
                        uniforms['u_metallicFactor'] = metallicFactor;
                        uniforms['u_roughnessFactor'] = roughnessFactor;
                    }
                    if (extensions === null || extensions === void 0 ? void 0 : extensions.KHR_materials_pbrSpecularGlossiness) {
                        _c = extensions === null || extensions === void 0 ? void 0 : extensions.KHR_materials_pbrSpecularGlossiness, diffuseFactor = _c.diffuseFactor, diffuseTexture = _c.diffuseTexture, specularFactor = _c.specularFactor, glossinessFactor = _c.glossinessFactor, specularGlossinessTexture = _c.specularGlossinessTexture;
                        marcos['USE_SPEC_GLOSS'] = true;
                        if (diffuseTexture) {
                            uniforms['u_baseColorTexture'] = textures[diffuseTexture.index];
                        }
                        if (specularGlossinessTexture) {
                            uniforms['u_specularGlossinessTexture'] = textures[specularGlossinessTexture.index];
                        }
                        uniforms['u_baseColorFactor'] = diffuseFactor;
                        uniforms['u_specularFactor'] = specularFactor;
                        uniforms['u_glossinessFactor'] = glossinessFactor;
                    }
                    if (alphaMode === 'BLEND') {
                        marcos['USE_GLASS'] = true;
                    }
                    material = new Material_1.default(effect, uniforms, marcos);
                    material.name = name_1;
                    materials.push(material);
                }
                return [2];
            });
        });
    };
    GlTFLoader.prototype._loadMeshes = function () {
        return __awaiter(this, void 0, void 0, function () {
            var meshesSrc, meshes, _i, meshesSrc_1, _a, primitives, name_2, mesh, node, _b, primitives_1, prim, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        meshesSrc = this._json.meshes;
                        meshes = this._res.meshes;
                        _i = 0, meshesSrc_1 = meshesSrc;
                        _e.label = 1;
                    case 1:
                        if (!(_i < meshesSrc_1.length)) return [3, 9];
                        _a = meshesSrc_1[_i], primitives = _a.primitives, name_2 = _a.name;
                        if (!(primitives.length === 1)) return [3, 3];
                        return [4, this._createMesh(primitives[0])];
                    case 2:
                        mesh = _e.sent();
                        mesh.name = name_2;
                        meshes.push(mesh);
                        return [3, 8];
                    case 3:
                        node = new Node_1.default();
                        node.name = name_2;
                        _b = 0, primitives_1 = primitives;
                        _e.label = 4;
                    case 4:
                        if (!(_b < primitives_1.length)) return [3, 7];
                        prim = primitives_1[_b];
                        _d = (_c = node).addChild;
                        return [4, this._createMesh(prim)];
                    case 5:
                        _d.apply(_c, [_e.sent()]);
                        _e.label = 6;
                    case 6:
                        _b++;
                        return [3, 4];
                    case 7:
                        meshes.push(node);
                        _e.label = 8;
                    case 8:
                        _i++;
                        return [3, 1];
                    case 9: return [2];
                }
            });
        });
    };
    GlTFLoader.prototype._loadCameras = function () {
        return __awaiter(this, void 0, void 0, function () {
            var camerasSrc, _a, cameras, cubeTextures, _i, camerasSrc_1, _b, perspective, orthographic, type, name_3, extensions, camera, skybox, skyboxMat;
            return __generator(this, function (_c) {
                camerasSrc = this._json.cameras;
                _a = this._res, cameras = _a.cameras, cubeTextures = _a.cubeTextures;
                if (!camerasSrc) {
                    return [2];
                }
                for (_i = 0, camerasSrc_1 = camerasSrc; _i < camerasSrc_1.length; _i++) {
                    _b = camerasSrc_1[_i], perspective = _b.perspective, orthographic = _b.orthographic, type = _b.type, name_3 = _b.name, extensions = _b.extensions;
                    camera = void 0;
                    if (type === 'perspective') {
                        camera = new Camera_1.default({}, {
                            near: perspective.znear,
                            far: perspective.zfar,
                            fov: 1 / perspective.yfov
                        });
                    }
                    else {
                        camera = new Camera_1.default({}, {
                            isOrth: true,
                            near: orthographic.znear,
                            far: orthographic.zfar,
                            sizeX: orthographic.xmag,
                            sizeY: orthographic.ymag
                        });
                    }
                    camera.name = name_3;
                    skybox = extensions && extensions.Sein_skybox;
                    if (skybox) {
                        if (skybox.type !== 'Cube') {
                            console.warn('Only support cube texture skybox now!');
                        }
                        else {
                            skyboxMat = new Material_1.default(buildin_1.buildinEffects.rSkybox, {
                                u_factor: new Float32Array([skybox.factor]),
                                u_color: new Float32Array(skybox.color),
                                u_cubeTexture: cubeTextures[skybox.texture.index],
                                u_rotation: new Float32Array([skybox.rotation]),
                                u_exposure: new Float32Array([skybox.exposure])
                            });
                            camera.skyboxMat = skyboxMat;
                        }
                    }
                    cameras.push(camera);
                }
                return [2];
            });
        });
    };
    GlTFLoader.prototype._loadLights = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var lightsSrc, lights, _loop_1, _i, lightsSrc_1, _c, name_4, type, intensity, color, mode, size;
            return __generator(this, function (_d) {
                if (!this._json.extensions) {
                    return [2];
                }
                lightsSrc = (_b = (_a = this._json.extensions) === null || _a === void 0 ? void 0 : _a.KHR_lights_punctual) === null || _b === void 0 ? void 0 : _b.lights;
                lights = this._res.lights;
                if (lightsSrc) {
                    _loop_1 = function (name_4, type, intensity, color, mode, size) {
                        if (type !== 'directional' && type !== 'area') {
                            throw new Error('Only support directional and area light now!');
                        }
                        var light = new Light_1.default(type === 'directional' ? Light_1.ELightType.Directional : Light_1.ELightType.Area, color.map(function (c) { return c * intensity; }), type === 'directional' ? {} : { mode: mode === 'rect' ? Light_1.EAreaLightMode.Rect : Light_1.EAreaLightMode.Disc, size: size });
                        light.name = name_4;
                        lights.push(light);
                    };
                    for (_i = 0, lightsSrc_1 = lightsSrc; _i < lightsSrc_1.length; _i++) {
                        _c = lightsSrc_1[_i], name_4 = _c.name, type = _c.type, intensity = _c.intensity, color = _c.color, mode = _c.mode, size = _c.size;
                        _loop_1(name_4, type, intensity, color, mode, size);
                    }
                }
                return [2];
            });
        });
    };
    GlTFLoader.prototype._loadNodes = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, nodesSrc, scenes, _b, rootNode, nodes, meshes, cameras, lights, _i, nodesSrc_1, _c, matrix, name_5, extensions, meshId, cameraId, node, index, _d, nodes_1, node, children, _e, children_1, childId, _f, _g, nodeId;
            return __generator(this, function (_h) {
                _a = this._json, nodesSrc = _a.nodes, scenes = _a.scenes;
                _b = this._res, rootNode = _b.rootNode, nodes = _b.nodes, meshes = _b.meshes, cameras = _b.cameras, lights = _b.lights;
                for (_i = 0, nodesSrc_1 = nodesSrc; _i < nodesSrc_1.length; _i++) {
                    _c = nodesSrc_1[_i], matrix = _c.matrix, name_5 = _c.name, extensions = _c.extensions, meshId = _c.mesh, cameraId = _c.camera;
                    node = void 0;
                    if (meshId !== undefined) {
                        node = meshes[meshId].clone();
                    }
                    else if (cameraId !== undefined) {
                        node = cameras[cameraId];
                    }
                    else if (extensions === null || extensions === void 0 ? void 0 : extensions.KHR_lights_punctual) {
                        node = lights[extensions.KHR_lights_punctual.light];
                    }
                    else {
                        node = new Node_1.default();
                    }
                    node.name = name_5;
                    if (matrix) {
                        node.setLocalMat(matrix);
                    }
                    nodes.push(node);
                }
                index = 0;
                for (_d = 0, nodes_1 = nodes; _d < nodes_1.length; _d++) {
                    node = nodes_1[_d];
                    children = nodesSrc[index].children;
                    if (children) {
                        for (_e = 0, children_1 = children; _e < children_1.length; _e++) {
                            childId = children_1[_e];
                            node.addChild(nodes[childId]);
                        }
                    }
                    index += 1;
                }
                for (_f = 0, _g = scenes[0].nodes; _f < _g.length; _f++) {
                    nodeId = _g[_f];
                    rootNode.addChild(nodes[nodeId]);
                }
                return [2];
            });
        });
    };
    GlTFLoader.prototype._createMesh = function (prim) {
        return __awaiter(this, void 0, void 0, function () {
            var _buffers, _a, accessors, bufferViews, materials, attributes, arrayStride, id, vertexData, boundingBox, attrName, _b, bufferView, byteOffset, componentType, type, max, min, view, _c, format, byteLength, idxInfo, idxView, indexBuffer, geometry, material;
            return __generator(this, function (_d) {
                _buffers = this._buffers;
                _a = this._json, accessors = _a.accessors, bufferViews = _a.bufferViews;
                materials = this._res.materials;
                attributes = [];
                arrayStride = 0;
                id = 0;
                for (attrName in prim.attributes) {
                    _b = accessors[prim.attributes[attrName]], bufferView = _b.bufferView, byteOffset = _b.byteOffset, componentType = _b.componentType, type = _b.type, max = _b.max, min = _b.min;
                    view = bufferViews[bufferView];
                    _c = this._convertVertexFormat(type, componentType), format = _c[0], byteLength = _c[1];
                    arrayStride += byteLength;
                    vertexData = vertexData || new Float32Array(_buffers[view.buffer], view.byteOffset || 0, view.byteLength / 4);
                    if (attrName === 'POSITION' && (max === null || max === void 0 ? void 0 : max.length) === 3 && (min === null || min === void 0 ? void 0 : min.length) === 3) {
                        boundingBox = this._getBoundingBox(max, min);
                    }
                    attributes.push({
                        name: attrName.toLowerCase(),
                        format: format,
                        offset: byteOffset || 0,
                        shaderLocation: id
                    });
                    id += 1;
                }
                idxInfo = accessors[prim.indices];
                idxView = bufferViews[idxInfo.bufferView];
                indexBuffer = new Uint16Array(_buffers[idxView.buffer], idxView.byteOffset, idxView.byteLength / 2);
                geometry = new Geometry_1.default([{
                        layout: { arrayStride: arrayStride, attributes: attributes },
                        data: vertexData
                    }], indexBuffer, idxInfo.count, boundingBox);
                material = materials[prim.material];
                return [2, new Mesh_1.default(geometry, material)];
            });
        });
    };
    GlTFLoader.prototype._convertVertexFormat = function (type, componentType) {
        if (componentType !== 5126) {
            throw new Error('Only support componentType float!');
        }
        switch (type) {
            case 'SCALE':
                return ['float32', 4];
            case 'VEC2':
                return ['float32x2', 8];
            case 'VEC3':
                return ['float32x3', 12];
            case 'VEC4':
                return ['float32x4', 16];
        }
        throw new Error("Not support type " + type + "!");
    };
    GlTFLoader.prototype._getBoundingBox = function (max, min) {
        return {
            start: min,
            center: max.map(function (mx, index) { return (mx + min[index]) / 2; }),
            size: max.map(function (mx, index) { return (mx - min[index]); })
        };
    };
    GlTFLoader.prototype._loadImage = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        img = document.createElement('img');
                        img.src = uri;
                        return [4, img.decode()];
                    case 1:
                        _a.sent();
                        return [2, img];
                }
            });
        });
    };
    GlTFLoader.CLASS_NAME = 'GlTFLoader';
    return GlTFLoader;
}(Loader_1.default));
exports["default"] = GlTFLoader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2xURkxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkdsVEZMb2FkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsc0NBQTBDO0FBQzFDLHFDQUFnQztBQUNoQyx5Q0FBb0M7QUFDcEMsNkNBQXdEO0FBQ3hELDZDQUF3QztBQUN4QyxxQ0FBZ0M7QUFDaEMsMkNBQXNDO0FBQ3RDLG1DQUE4QjtBQUU5Qix1Q0FBa0U7QUFDbEUsbURBQThDO0FBbUI5QztJQUF3Qyw4QkFBeUM7SUFBakY7UUFBQSxxRUF1WUM7UUFyWVEsa0JBQVksR0FBWSxJQUFJLENBQUM7UUFJNUIsY0FBUSxHQUFrQixFQUFFLENBQUM7O0lBaVl2QyxDQUFDO0lBOVhjLHlCQUFJLEdBQWpCLFVBQWtCLEdBQVcsRUFBRSxPQUEyQjs7Ozs7O3dCQUNsRCxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDM0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO3dCQUNWLElBQUksQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDOUIsS0FBQSxJQUFJLENBQUE7d0JBQVMsV0FBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsRUFBQTs7d0JBQTVDLEdBQUssS0FBSyxHQUFHLFNBQStCLENBQUM7d0JBQzdDLFdBQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFBOzt3QkFBekIsU0FBeUIsQ0FBQzt3QkFFMUIsSUFBSSxDQUFDLElBQUksR0FBRzs0QkFDVixRQUFRLEVBQUUsSUFBSSxjQUFJLEVBQUU7NEJBQ3BCLEtBQUssRUFBRSxFQUFFOzRCQUNULE1BQU0sRUFBRSxFQUFFOzRCQUNWLE1BQU0sRUFBRSxFQUFFOzRCQUNWLFFBQVEsRUFBRSxFQUFFOzRCQUNaLFlBQVks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QUMsR0FBRyxHQUFHLEdBQUcsQ0FBQzt3QkFDZCxXQUFNLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBQTs7d0JBQWxCLFNBQWtCLENBQUM7d0JBRW5CLFdBQU8sR0FBRyxFQUFDOzs7O0tBQ1o7SUFyWWEscUJBQVUsR0FBVyxZQUFZLENBQUM7SUFzWWxELGlCQUFDO0NBQUEsQUF2WUQsQ0FBd0MsZ0JBQU0sR0F1WTdDO2tCQXZZb0IsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2xURkxvYWRlci50c1xuICogXG4gKiBAQXV0aG9yICA6ZHR5c2t5KGR0eXNreUBvdXRsb29rLmNvbSlcbiAqIEBEYXRlICAgIDogNi85LzIwMjEsIDY6MjQ6MTUgUE1cbiovXG5pbXBvcnQge2J1aWxkaW5FZmZlY3RzfSBmcm9tIFwiLi4vYnVpbGRpblwiO1xuaW1wb3J0IE5vZGUgZnJvbSBcIi4uL2NvcmUvTm9kZVwiO1xuaW1wb3J0IENhbWVyYSBmcm9tIFwiLi4vY29yZS9DYW1lcmFcIjtcbmltcG9ydCBHZW9tZXRyeSwge0lCb3VuZGluZ0JveH0gZnJvbSBcIi4uL2NvcmUvR2VvbWV0cnlcIjtcbmltcG9ydCBNYXRlcmlhbCBmcm9tIFwiLi4vY29yZS9NYXRlcmlhbFwiO1xuaW1wb3J0IE1lc2ggZnJvbSBcIi4uL2NvcmUvTWVzaFwiO1xuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL2NvcmUvVGV4dHVyZVwiO1xuaW1wb3J0IExvYWRlciBmcm9tIFwiLi9Mb2FkZXJcIjtcbmltcG9ydCB7VFVuaWZvcm1WYWx1ZX0gZnJvbSBcIi4uL2NvcmUvVUJUZW1wbGF0ZVwiO1xuaW1wb3J0IExpZ2h0LCB7IEVBcmVhTGlnaHRNb2RlLCBFTGlnaHRUeXBlIH0gZnJvbSBcIi4uL2NvcmUvTGlnaHRcIjtcbmltcG9ydCBDdWJlVGV4dHVyZSBmcm9tIFwiLi4vY29yZS9DdWJlVGV4dHVyZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElHbFRGTG9hZGVyT3B0aW9ucyB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJR2xURlJlc291cmNlIHtcbiAgcm9vdE5vZGU6IE5vZGU7XG4gIG5vZGVzOiBOb2RlW107XG4gIG1lc2hlczogKE1lc2ggfCBOb2RlKVtdO1xuICBpbWFnZXM6IEltYWdlQml0bWFwW107XG4gIHRleHR1cmVzOiBUZXh0dXJlW107XG4gIGN1YmVUZXh0dXJlczogQ3ViZVRleHR1cmVbXTtcbiAgbWF0ZXJpYWxzOiBNYXRlcmlhbFtdO1xuICAvLyBzYW1wbGVyczogR1BVU2FtcGxlckRlc2NyaXB0b3JbXTtcbiAgY2FtZXJhczogQ2FtZXJhW107XG4gIGxpZ2h0czogTGlnaHRbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xURkxvYWRlciBleHRlbmRzIExvYWRlcjxJR2xURkxvYWRlck9wdGlvbnMsIElHbFRGUmVzb3VyY2U+IHtcbiAgcHVibGljIHN0YXRpYyBDTEFTU19OQU1FOiBzdHJpbmcgPSAnR2xURkxvYWRlcic7XG4gIHB1YmxpYyBpc0dsVEZMb2FkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgX2Jhc2VVcmk6IHN0cmluZztcbiAgcHJpdmF0ZSBfanNvbjogYW55O1xuICBwcml2YXRlIF9idWZmZXJzOiBBcnJheUJ1ZmZlcltdID0gW107XG4gIHByaXZhdGUgX3JlczogSUdsVEZSZXNvdXJjZTtcbiAgXG4gIHB1YmxpYyBhc3luYyBsb2FkKHNyYzogc3RyaW5nLCBvcHRpb25zOiBJR2xURkxvYWRlck9wdGlvbnMpOiBQcm9taXNlPElHbFRGUmVzb3VyY2U+IHtcbiAgICBjb25zdCB0bXAgPSBzcmMuc3BsaXQoJy8nKTtcbiAgICB0bXAucG9wKCk7XG4gICAgdGhpcy5fYmFzZVVyaSA9IHRtcC5qb2luKCcvJyk7XG4gICAgdGhpcy5fanNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdChzcmMsICdqc29uJyk7XG4gICAgYXdhaXQgdGhpcy5fbG9hZEJ1ZmZlcnMoKTtcblxuICAgIHRoaXMuX3JlcyA9IHtcbiAgICAgIHJvb3ROb2RlOiBuZXcgTm9kZSgpLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgbWVzaGVzOiBbXSxcbiAgICAgIGltYWdlczogW10sXG4gICAgICB0ZXh0dXJlczogW10sXG4gICAgICBjdWJlVGV4dHVyZXM6IFtdLFxuICAgICAgbWF0ZXJpYWxzOiBbXSxcbiAgICAgIC8vIHNhbXBsZXJzOiBbXSxcbiAgICAgIGNhbWVyYXM6IFtdLFxuICAgICAgbGlnaHRzOiBbXVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuX2xvYWRJbWFnZXMoKTtcbiAgICBhd2FpdCB0aGlzLl9sb2FkVGV4dHVyZXMoKTtcbiAgICBhd2FpdCB0aGlzLl9sb2FkQ3ViZVRleHR1cmVzKCk7XG4gICAgYXdhaXQgdGhpcy5fbG9hZE1hdGVyaWFscygpO1xuICAgIGF3YWl0IHRoaXMuX2xvYWRNZXNoZXMoKTtcbiAgICBhd2FpdCB0aGlzLl9sb2FkQ2FtZXJhcygpO1xuICAgIGF3YWl0IHRoaXMuX2xvYWRMaWdodHMoKTtcbiAgICBhd2FpdCB0aGlzLl9sb2FkTm9kZXMoKTtcblxuICAgIHJldHVybiB0aGlzLl9yZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9sb2FkQnVmZmVycygpIHtcbiAgICBjb25zdCB7YnVmZmVyc30gPSB0aGlzLl9qc29uO1xuXG4gICAgZm9yIChjb25zdCB7dXJpfSBvZiBidWZmZXJzKSB7XG4gICAgICB0aGlzLl9idWZmZXJzLnB1c2goYXdhaXQgdGhpcy5yZXF1ZXN0KHRoaXMuX2Jhc2VVcmkgKyAnLycgKyB1cmksICdidWZmZXInKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbG9hZEltYWdlcygpIHtcbiAgICBjb25zdCB7aW1hZ2VzOiBpbWFnZXNTcmN9ID0gdGhpcy5fanNvbjtcbiAgICBjb25zdCB7aW1hZ2VzfSA9IHRoaXMuX3JlcztcblxuICAgIGlmICghaW1hZ2VzU3JjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7dXJpfSBvZiBpbWFnZXNTcmMpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgdGhpcy5fbG9hZEltYWdlKHRoaXMuX2Jhc2VVcmkgKyAnLycgKyB1cmkpO1xuICAgICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgaW1hZ2VzLnB1c2goYml0bWFwKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9sb2FkVGV4dHVyZXMoKSB7XG4gICAgY29uc3Qge3RleHR1cmVzOiB0ZXh0dXJlc1NyYywgaW1hZ2VzOiBpbWFnZXNTcmN9ID0gdGhpcy5fanNvbjtcbiAgICBjb25zdCB7aW1hZ2VzLCB0ZXh0dXJlc30gPSB0aGlzLl9yZXM7XG5cbiAgICBpZiAoIXRleHR1cmVzU3JjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7c291cmNlfSBvZiB0ZXh0dXJlc1NyYykge1xuICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbc291cmNlXTtcblxuICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlKTtcbiAgICAgIFxuICAgICAgY29uc3QgaXNSR0JEOiBib29sZWFuID0gaW1hZ2VzU3JjLmV4dHJhcz8udHlwZSA9PT0gJ0hEUicgJiYgaW1hZ2VzU3JjLmV4dHJhcz8uZm9ybWF0ID09PSAnUkdCRCc7XG4gICAgICBjb25zdCBpc05vcm1hbDogYm9vbGVhbiA9ICEhaW1hZ2VzU3JjLmV4dHJhcz8uaXNOb3JtYWxNYXA7XG4gICAgICBcbiAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbG9hZEN1YmVUZXh0dXJlcygpIHtcbiAgICBjb25zdCBjdWJlVGV4dHVyZXNTcmMgPSB0aGlzLl9qc29uLmV4dGVuc2lvbnM/LlNlaW5fY3ViZVRleHR1cmU/LnRleHR1cmVzO1xuICAgIGNvbnN0IHtpbWFnZXMsIGN1YmVUZXh0dXJlc30gPSB0aGlzLl9yZXM7XG5cbiAgICBpZiAoIWN1YmVUZXh0dXJlc1NyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qge2ltYWdlczogaW1hZ2VJZHN9IG9mIGN1YmVUZXh0dXJlc1NyYykge1xuICAgICAgY29uc3QgdGFza3MgPSBQcm9taXNlLmFsbDxJbWFnZUJpdG1hcD4oaW1hZ2VJZHMubWFwKChpbWFnZUlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGltYWdlc1tpbWFnZUlkXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IGJtcyA9IGF3YWl0IHRhc2tzO1xuICAgICAgY29uc3QgY3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoYm1zWzBdLndpZHRoLCBibXNbMV0ud2lkdGgsIGJtcyk7XG4gICAgICBibXMuZm9yRWFjaChibSA9PiBibS5jbG9zZSgpKTtcblxuICAgICAgY3ViZVRleHR1cmVzLnB1c2goY3ViZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2xvYWRNYXRlcmlhbHMoKSB7XG4gICAgY29uc3Qge19idWZmZXJzfSA9IHRoaXM7XG4gICAgY29uc3Qge21hdGVyaWFsczogbWF0ZXJpYWxzU3JjfSA9IHRoaXMuX2pzb247XG4gICAgY29uc3Qge21hdGVyaWFscywgdGV4dHVyZXN9ID0gdGhpcy5fcmVzO1xuXG4gICAgZm9yIChjb25zdCB7bmFtZSwgcGJyTWV0YWxsaWNSb3VnaG5lc3MsIG5vcm1hbFRleHR1cmUsIGFscGhhTW9kZSwgZXh0ZW5zaW9uc30gb2YgbWF0ZXJpYWxzU3JjKSB7XG4gICAgICBjb25zdCBlZmZlY3QgPSBidWlsZGluRWZmZWN0cy5yUEJSO1xuICAgICAgY29uc3QgdW5pZm9ybXM6IHtba2V5OiBzdHJpbmddOiBUVW5pZm9ybVZhbHVlfSA9IHt9O1xuICAgICAgY29uc3QgbWFyY29zOiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcblxuICAgICAgaWYgKG5vcm1hbFRleHR1cmUpIHtcbiAgICAgICAgdW5pZm9ybXNbJ3Vfbm9ybWFsVGV4dHVyZSddID0gdGV4dHVyZXNbbm9ybWFsVGV4dHVyZS5pbmRleF1cbiAgICAgICAgdW5pZm9ybXNbJ3Vfbm9ybWFsVGV4dHVyZVNjYWxlJ10gPSBub3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGJyTWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJhc2VDb2xvclRleHR1cmUsIG1ldGFsbGljRmFjdG9yLCBiYXNlQ29sb3JGYWN0b3IsIHJvdWdobmVzc0ZhY3RvciwgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXG4gICAgICAgIH0gPSBwYnJNZXRhbGxpY1JvdWdobmVzcztcblxuICAgICAgICBpZiAoYmFzZUNvbG9yVGV4dHVyZSkge1xuICAgICAgICAgIHVuaWZvcm1zWyd1X2Jhc2VDb2xvclRleHR1cmUnXSA9IHRleHR1cmVzW2Jhc2VDb2xvclRleHR1cmUuaW5kZXhdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuICAgICAgICAgIHVuaWZvcm1zWyd1X21ldGFsbGljUm91Z2huZXNzVGV4dHVyZSddID0gdGV4dHVyZXNbbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLmluZGV4XVxuICAgICAgICB9XG5cbiAgICAgICAgdW5pZm9ybXNbJ3VfYmFzZUNvbG9yRmFjdG9yJ10gPSBiYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIHVuaWZvcm1zWyd1X21ldGFsbGljRmFjdG9yJ10gPSBtZXRhbGxpY0ZhY3RvcjtcbiAgICAgICAgdW5pZm9ybXNbJ3Vfcm91Z2huZXNzRmFjdG9yJ10gPSByb3VnaG5lc3NGYWN0b3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHRlbnNpb25zPy5LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlmZnVzZUZhY3RvciwgZGlmZnVzZVRleHR1cmUsIHNwZWN1bGFyRmFjdG9yLCBnbG9zc2luZXNzRmFjdG9yLCBzcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlXG4gICAgICAgIH0gPSBleHRlbnNpb25zPy5LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcztcbiAgICAgICAgbWFyY29zWydVU0VfU1BFQ19HTE9TUyddID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZGlmZnVzZVRleHR1cmUpIHtcbiAgICAgICAgICB1bmlmb3Jtc1sndV9iYXNlQ29sb3JUZXh0dXJlJ10gPSB0ZXh0dXJlc1tkaWZmdXNlVGV4dHVyZS5pbmRleF1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSkge1xuICAgICAgICAgIHVuaWZvcm1zWyd1X3NwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUnXSA9IHRleHR1cmVzW3NwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUuaW5kZXhdXG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtc1sndV9iYXNlQ29sb3JGYWN0b3InXSA9IGRpZmZ1c2VGYWN0b3I7XG4gICAgICAgIHVuaWZvcm1zWyd1X3NwZWN1bGFyRmFjdG9yJ10gPSBzcGVjdWxhckZhY3RvcjtcbiAgICAgICAgdW5pZm9ybXNbJ3VfZ2xvc3NpbmVzc0ZhY3RvciddID0gZ2xvc3NpbmVzc0ZhY3RvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFscGhhTW9kZSA9PT0gJ0JMRU5EJykge1xuICAgICAgICBtYXJjb3NbJ1VTRV9HTEFTUyddID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoZWZmZWN0LCB1bmlmb3JtcywgbWFyY29zKTtcbiAgICAgIG1hdGVyaWFsLm5hbWUgPSBuYW1lO1xuICAgICAgbWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2xvYWRNZXNoZXMoKSB7XG4gICAgY29uc3Qge21lc2hlczogbWVzaGVzU3JjfSA9IHRoaXMuX2pzb247XG4gICAgY29uc3Qge21lc2hlc30gPSB0aGlzLl9yZXM7XG5cbiAgICBmb3IgKGNvbnN0IHtwcmltaXRpdmVzLCBuYW1lfSBvZiBtZXNoZXNTcmMpIHtcbiAgICAgIGlmIChwcmltaXRpdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBtZXNoID0gYXdhaXQgdGhpcy5fY3JlYXRlTWVzaChwcmltaXRpdmVzWzBdKTtcbiAgICAgICAgbWVzaC5uYW1lID0gbmFtZTtcbiAgICAgICAgbWVzaGVzLnB1c2gobWVzaCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgICBmb3IgKGxldCBwcmltIG9mIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLl9jcmVhdGVNZXNoKHByaW0pKTtcbiAgICAgIH1cblxuICAgICAgbWVzaGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbG9hZENhbWVyYXMoKSB7XG4gICAgY29uc3Qge2NhbWVyYXM6IGNhbWVyYXNTcmN9ID0gdGhpcy5fanNvbjtcbiAgICBjb25zdCB7Y2FtZXJhcywgY3ViZVRleHR1cmVzfSA9IHRoaXMuX3JlcztcblxuICAgIGlmICghY2FtZXJhc1NyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qge3BlcnNwZWN0aXZlLCBvcnRob2dyYXBoaWMsIHR5cGUsIG5hbWUsIGV4dGVuc2lvbnN9IG9mIGNhbWVyYXNTcmMpIHtcbiAgICAgIGxldCBjYW1lcmE6IENhbWVyYTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdwZXJzcGVjdGl2ZScpIHtcbiAgICAgICAgY2FtZXJhID0gbmV3IENhbWVyYSh7fSwge1xuICAgICAgICAgIG5lYXI6IHBlcnNwZWN0aXZlLnpuZWFyLFxuICAgICAgICAgIGZhcjogcGVyc3BlY3RpdmUuemZhcixcbiAgICAgICAgICBmb3Y6IDEgLyBwZXJzcGVjdGl2ZS55Zm92XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtZXJhID0gbmV3IENhbWVyYSh7fSwge1xuICAgICAgICAgIGlzT3J0aDogdHJ1ZSxcbiAgICAgICAgICBuZWFyOiBvcnRob2dyYXBoaWMuem5lYXIsXG4gICAgICAgICAgZmFyOiBvcnRob2dyYXBoaWMuemZhcixcbiAgICAgICAgICBzaXplWDogb3J0aG9ncmFwaGljLnhtYWcsXG4gICAgICAgICAgc2l6ZVk6IG9ydGhvZ3JhcGhpYy55bWFnXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNhbWVyYS5uYW1lID0gbmFtZTtcblxuICAgICAgY29uc3Qgc2t5Ym94ID0gZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLlNlaW5fc2t5Ym94O1xuXG4gICAgICBpZiAoc2t5Ym94KSB7XG4gICAgICAgIGlmIChza3lib3gudHlwZSAhPT0gJ0N1YmUnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IHN1cHBvcnQgY3ViZSB0ZXh0dXJlIHNreWJveCBub3chJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2t5Ym94TWF0ID0gbmV3IE1hdGVyaWFsKGJ1aWxkaW5FZmZlY3RzLnJTa3lib3gsIHtcbiAgICAgICAgICAgIHVfZmFjdG9yOiBuZXcgRmxvYXQzMkFycmF5KFtza3lib3guZmFjdG9yXSksXG4gICAgICAgICAgICB1X2NvbG9yOiBuZXcgRmxvYXQzMkFycmF5KHNreWJveC5jb2xvciksXG4gICAgICAgICAgICB1X2N1YmVUZXh0dXJlOiBjdWJlVGV4dHVyZXNbc2t5Ym94LnRleHR1cmUuaW5kZXhdLFxuICAgICAgICAgICAgdV9yb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShbc2t5Ym94LnJvdGF0aW9uXSksXG4gICAgICAgICAgICB1X2V4cG9zdXJlOiBuZXcgRmxvYXQzMkFycmF5KFtza3lib3guZXhwb3N1cmVdKVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBjYW1lcmEuc2t5Ym94TWF0ID0gc2t5Ym94TWF0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbWVyYXMucHVzaChjYW1lcmEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2xvYWRMaWdodHMoKSB7XG4gICAgaWYgKCF0aGlzLl9qc29uLmV4dGVuc2lvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsaWdodHNTcmMgPSB0aGlzLl9qc29uLmV4dGVuc2lvbnM/LktIUl9saWdodHNfcHVuY3R1YWw/LmxpZ2h0cztcbiAgICBjb25zdCB7bGlnaHRzfSA9IHRoaXMuX3JlcztcblxuICAgIGlmIChsaWdodHNTcmMpIHtcbiAgICAgIGZvciAoY29uc3Qge25hbWUsIHR5cGUsIGludGVuc2l0eSwgY29sb3IsIG1vZGUsIHNpemV9IG9mIGxpZ2h0c1NyYykge1xuICAgICAgICBpZiAodHlwZSAhPT0gJ2RpcmVjdGlvbmFsJyAmJiB0eXBlICE9PSAnYXJlYScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3VwcG9ydCBkaXJlY3Rpb25hbCBhbmQgYXJlYSBsaWdodCBub3chJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGNvbnN0IGxpZ2h0ID0gbmV3IExpZ2h0KFxuICAgICAgICAgIHR5cGUgPT09ICdkaXJlY3Rpb25hbCcgPyBFTGlnaHRUeXBlLkRpcmVjdGlvbmFsIDogRUxpZ2h0VHlwZS5BcmVhLFxuICAgICAgICAgIGNvbG9yLm1hcChjID0+IGMgKiBpbnRlbnNpdHkpLFxuICAgICAgICAgIHR5cGUgPT09ICdkaXJlY3Rpb25hbCcgPyB7fSA6IHttb2RlOiBtb2RlID09PSAncmVjdCcgPyBFQXJlYUxpZ2h0TW9kZS5SZWN0IDogRUFyZWFMaWdodE1vZGUuRGlzYywgc2l6ZX1cbiAgICAgICAgKTtcbiAgICAgICAgbGlnaHQubmFtZSA9IG5hbWU7XG4gIFxuICAgICAgICBsaWdodHMucHVzaChsaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbG9hZE5vZGVzKCkge1xuICAgIGNvbnN0IHtub2Rlczogbm9kZXNTcmMsIHNjZW5lc30gPSB0aGlzLl9qc29uO1xuICAgIGNvbnN0IHtyb290Tm9kZSwgbm9kZXMsIG1lc2hlcywgY2FtZXJhcywgbGlnaHRzfSA9IHRoaXMuX3JlcztcblxuICAgIGZvciAoY29uc3Qge21hdHJpeCwgbmFtZSwgZXh0ZW5zaW9ucywgbWVzaDogbWVzaElkLCBjYW1lcmE6IGNhbWVyYUlkfSBvZiBub2Rlc1NyYykge1xuICAgICAgbGV0IG5vZGU6IE5vZGU7XG5cbiAgICAgIGlmIChtZXNoSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlID0gKG1lc2hlc1ttZXNoSWRdIGFzIE1lc2gpLmNsb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWVyYUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZSA9IGNhbWVyYXNbY2FtZXJhSWRdO1xuICAgICAgfSBlbHNlIGlmIChleHRlbnNpb25zPy5LSFJfbGlnaHRzX3B1bmN0dWFsKSB7XG4gICAgICAgIG5vZGUgPSBsaWdodHNbZXh0ZW5zaW9ucy5LSFJfbGlnaHRzX3B1bmN0dWFsLmxpZ2h0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgfVxuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcblxuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBub2RlLnNldExvY2FsTWF0KG1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IHtjaGlsZHJlbn0gPSBub2Rlc1NyY1tpbmRleF07XG5cbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSWQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBub2RlLmFkZENoaWxkKG5vZGVzW2NoaWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBub2RlSWQgb2Ygc2NlbmVzWzBdLm5vZGVzKSB7XG4gICAgICByb290Tm9kZS5hZGRDaGlsZChub2Rlc1tub2RlSWRdKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9jcmVhdGVNZXNoKHByaW06IHthdHRyaWJ1dGVzOiBhbnksIGluZGljZXM6IG51bWJlciwgbWF0ZXJpYWw6IG51bWJlcn0pOiBQcm9taXNlPE1lc2g+IHtcbiAgICBjb25zdCB7X2J1ZmZlcnN9ID0gdGhpcztcbiAgICBjb25zdCB7YWNjZXNzb3JzLCBidWZmZXJWaWV3c30gPSB0aGlzLl9qc29uO1xuICAgIGNvbnN0IHttYXRlcmlhbHN9ID0gdGhpcy5fcmVzO1xuXG4gICAgY29uc3QgYXR0cmlidXRlczogKEdQVVZlcnRleEF0dHJpYnV0ZSAmIHtuYW1lOiBzdHJpbmd9KVtdID0gW107XG4gICAgbGV0IGFycmF5U3RyaWRlOiBudW1iZXIgPSAwO1xuICAgIGxldCBpZDogbnVtYmVyID0gMDtcbiAgICBsZXQgdmVydGV4RGF0YTogRmxvYXQzMkFycmF5O1xuXG4gICAgbGV0IGJvdW5kaW5nQm94OiBJQm91bmRpbmdCb3g7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIHByaW0uYXR0cmlidXRlcykge1xuICAgICAgY29uc3Qge2J1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGNvbXBvbmVudFR5cGUsIHR5cGUsIG1heCwgbWlufSA9IGFjY2Vzc29yc1twcmltLmF0dHJpYnV0ZXNbYXR0ck5hbWVdXTtcbiAgICAgIGNvbnN0IHZpZXcgPSBidWZmZXJWaWV3c1tidWZmZXJWaWV3XTtcbiAgICAgIGNvbnN0IFtmb3JtYXQsIGJ5dGVMZW5ndGhdID0gdGhpcy5fY29udmVydFZlcnRleEZvcm1hdCh0eXBlLCBjb21wb25lbnRUeXBlKTtcbiAgICAgIGFycmF5U3RyaWRlICs9IGJ5dGVMZW5ndGg7XG4gICAgICB2ZXJ0ZXhEYXRhID0gdmVydGV4RGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KF9idWZmZXJzW3ZpZXcuYnVmZmVyXSwgdmlldy5ieXRlT2Zmc2V0IHx8IDAsIHZpZXcuYnl0ZUxlbmd0aCAvIDQpO1xuXG4gICAgICBpZiAoYXR0ck5hbWUgPT09ICdQT1NJVElPTicgJiYgbWF4Py5sZW5ndGggPT09IDMgJiYgbWluPy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYm91bmRpbmdCb3ggPSB0aGlzLl9nZXRCb3VuZGluZ0JveChtYXgsIG1pbik7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGF0dHJOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgb2Zmc2V0OiBieXRlT2Zmc2V0IHx8IDAsXG4gICAgICAgIHNoYWRlckxvY2F0aW9uOiBpZFxuICAgICAgfSk7XG5cbiAgICAgIGlkICs9IDE7XG4gICAgfVxuXG4gICAgY29uc3QgaWR4SW5mbyA9IGFjY2Vzc29yc1twcmltLmluZGljZXNdO1xuICAgIGNvbnN0IGlkeFZpZXcgPSBidWZmZXJWaWV3c1tpZHhJbmZvLmJ1ZmZlclZpZXddO1xuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KF9idWZmZXJzW2lkeFZpZXcuYnVmZmVyXSwgaWR4Vmlldy5ieXRlT2Zmc2V0LCBpZHhWaWV3LmJ5dGVMZW5ndGggLyAyKTtcblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KFxuICAgICAgW3tcbiAgICAgICAgbGF5b3V0OiB7YXJyYXlTdHJpZGUsIGF0dHJpYnV0ZXN9LCBkYXRhOiB2ZXJ0ZXhEYXRhXG4gICAgICB9XSxcbiAgICAgIGluZGV4QnVmZmVyLCBpZHhJbmZvLmNvdW50LCBib3VuZGluZ0JveFxuICAgICk7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbcHJpbS5tYXRlcmlhbF07XG5cbiAgICByZXR1cm4gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbnZlcnRWZXJ0ZXhGb3JtYXQodHlwZTogJ1NDQUxFJyB8ICdWRUMyJyB8ICdWRUMzJyB8ICdWRUM0JywgY29tcG9uZW50VHlwZTogR0xlbnVtKTogW0dQVVZlcnRleEZvcm1hdCwgbnVtYmVyXSB7XG4gICAgaWYgKGNvbXBvbmVudFR5cGUgIT09IDUxMjYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBzdXBwb3J0IGNvbXBvbmVudFR5cGUgZmxvYXQhJyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdTQ0FMRSc6XG4gICAgICAgIHJldHVybiBbJ2Zsb2F0MzInLCA0XTtcbiAgICAgIGNhc2UgJ1ZFQzInOlxuICAgICAgICByZXR1cm4gWydmbG9hdDMyeDInLCA4XTtcbiAgICAgIGNhc2UgJ1ZFQzMnOlxuICAgICAgICByZXR1cm4gWydmbG9hdDMyeDMnLCAxMl07XG4gICAgICBjYXNlICdWRUM0JzpcbiAgICAgICAgcmV0dXJuIFsnZmxvYXQzMng0JywgMTZdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnQgdHlwZSAke3R5cGV9IWApXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldEJvdW5kaW5nQm94KFxuICAgIG1heDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIG1pbjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbWluLFxuICAgICAgY2VudGVyOiBtYXgubWFwKChteCwgaW5kZXgpID0+IChteCArIG1pbltpbmRleF0pIC8gMikgYXMgIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgIHNpemU6IG1heC5tYXAoKG14LCBpbmRleCkgPT4gKG14IC0gbWluW2luZGV4XSkpIGFzICBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9sb2FkSW1hZ2UodXJpOiBzdHJpbmcpOiBQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+IHtcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWcuc3JjID0gdXJpO1xuICAgIGF3YWl0IGltZy5kZWNvZGUoKTtcblxuICAgIHJldHVybiBpbWc7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./src/resource/Loader.ts":
/*!********************************!*\
  !*** ./src/resource/Loader.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var HObject_1 = __webpack_require__(/*! ../core/HObject */ "./src/core/HObject.ts");
var Loader = (function (_super) {
    __extends(Loader, _super);
    function Loader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLoader = true;
        return _this;
    }
    Loader.prototype.request = function (src, type) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, new Promise(function (resolve, reject) {
                        var xhr = new XMLHttpRequest();
                        xhr.onload = function () {
                            if (xhr.status < 200 || xhr.status >= 300) {
                                reject(new TypeError("Network request failed for " + xhr.status));
                                return;
                            }
                            var result = 'response' in xhr ? xhr.response : xhr.responseText;
                            if (type === 'json') {
                                try {
                                    result = JSON.parse(result);
                                }
                                catch (err) {
                                    reject(new TypeError('JSON.parse error' + err));
                                    return;
                                }
                            }
                            resolve(result);
                        };
                        xhr.onerror = function () {
                            reject(new TypeError('Network request failed'));
                        };
                        xhr.ontimeout = function () {
                            reject(new TypeError('Network request timed out'));
                        };
                        xhr.open('GET', src, true);
                        if (type === 'buffer') {
                            xhr.responseType = 'arraybuffer';
                        }
                        xhr.send();
                    })];
            });
        });
    };
    Loader.CLASS_NAME = 'Loader';
    return Loader;
}(HObject_1.default));
exports["default"] = Loader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiTG9hZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9BLDJDQUFzQztBQUV0QztJQUFrRSwwQkFBTztJQUF6RTtRQUFBLHFFQWdEQztRQTlDUSxjQUFRLEdBQVksSUFBSSxDQUFDOztJQThDbEMsQ0FBQztJQXpDYyx3QkFBTyxHQUFwQixVQUFxQixHQUFXLEVBQUUsSUFBd0I7OztnQkFDeEQsV0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNO3dCQUNqQyxJQUFNLEdBQUcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO3dCQUVqQyxHQUFHLENBQUMsTUFBTSxHQUFHOzRCQUNYLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7Z0NBQ3pDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxnQ0FBOEIsR0FBRyxDQUFDLE1BQVEsQ0FBQyxDQUFDLENBQUM7Z0NBQ2xFLE9BQU87NkJBQ1I7NEJBR0QsSUFBSSxNQUFNLEdBQUcsVUFBVSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQzs0QkFFakUsSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFO2dDQUNuQixJQUFJO29DQUNGLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lDQUM3QjtnQ0FBQyxPQUFPLEdBQUcsRUFBRTtvQ0FDWixNQUFNLENBQUMsSUFBSSxTQUFTLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztvQ0FDaEQsT0FBTztpQ0FDUjs2QkFDRjs0QkFDRCxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ2xCLENBQUMsQ0FBQzt3QkFFRixHQUFHLENBQUMsT0FBTyxHQUFHOzRCQUNaLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7d0JBQ2xELENBQUMsQ0FBQzt3QkFFRixHQUFHLENBQUMsU0FBUyxHQUFHOzRCQUNkLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUM7d0JBQ3JELENBQUMsQ0FBQzt3QkFFRixHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7d0JBRTNCLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRTs0QkFDckIsR0FBRyxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUM7eUJBQ2xDO3dCQUVELEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDYixDQUFDLENBQUMsRUFBQzs7O0tBQ0o7SUE5Q2EsaUJBQVUsR0FBVyxRQUFRLENBQUM7SUErQzlDLGFBQUM7Q0FBQSxBQWhERCxDQUFrRSxpQkFBTyxHQWdEeEU7a0JBaEQ2QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2FkZXIudHNcbiAqIFxuICogQEF1dGhvciAgOmR0eXNreShkdHlza3lAb3V0bG9vay5jb20pXG4gKiBARGF0ZSAgICA6IDYvOS8yMDIxLCA2OjI1OjUxIFBNXG4qL1xuXG5pbXBvcnQgSE9iamVjdCBmcm9tIFwiLi4vY29yZS9IT2JqZWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIExvYWRlcjxJT3B0aW9ucywgSVJlc291cmNlPiBleHRlbmRzIEhPYmplY3Qge1xuICBwdWJsaWMgc3RhdGljIENMQVNTX05BTUU6IHN0cmluZyA9ICdMb2FkZXInO1xuICBwdWJsaWMgaXNMb2FkZXI6IGJvb2xlYW4gPSB0cnVlO1xuICBwdWJsaWMgdHlwZTogeyBvcHRpb25zOiBJT3B0aW9ucywgcmVzb3VyY2U6IElSZXNvdXJjZSB9O1xuXG4gIHB1YmxpYyBhYnN0cmFjdCBsb2FkKHNyYzogc3RyaW5nLCBvcHRpb25zOiBJT3B0aW9ucyk6IFByb21pc2U8SVJlc291cmNlPjtcblxuICBwdWJsaWMgYXN5bmMgcmVxdWVzdChzcmM6IHN0cmluZywgdHlwZT86ICdqc29uJyB8ICdidWZmZXInKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoYE5ldHdvcmsgcmVxdWVzdCBmYWlsZWQgZm9yICR7eGhyLnN0YXR1c31gKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGxldCByZXN1bHQgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignSlNPTi5wYXJzZSBlcnJvcicgKyBlcnIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdidWZmZXInKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xuICB9XG59Il19

/***/ }),

/***/ "./src/resource/TextureLoader.ts":
/*!***************************************!*\
  !*** ./src/resource/TextureLoader.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Texture_1 = __webpack_require__(/*! ../core/Texture */ "./src/core/Texture.ts");
var Loader_1 = __webpack_require__(/*! ./Loader */ "./src/resource/Loader.ts");
var TextureLoader = (function (_super) {
    __extends(TextureLoader, _super);
    function TextureLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isTextureLoader = true;
        return _this;
    }
    TextureLoader.prototype.load = function (src, options) {
        return __awaiter(this, void 0, void 0, function () {
            var img, bitmap, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        img = document.createElement('img');
                        img.src = src;
                        return [4, img.decode()];
                    case 1:
                        _a.sent();
                        return [4, createImageBitmap(img)];
                    case 2:
                        bitmap = _a.sent();
                        res = new Texture_1.default(img.naturalHeight, img.naturalHeight, bitmap);
                        return [2, res];
                }
            });
        });
    };
    TextureLoader.CLASS_NAME = 'TextureLoader';
    return TextureLoader;
}(Loader_1.default));
exports["default"] = TextureLoader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dHVyZUxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlRleHR1cmVMb2FkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUEsMkNBQXNDO0FBQ3RDLG1DQUE4QjtBQU05QjtJQUEyQyxpQ0FBc0M7SUFBakY7UUFBQSxxRUFlQztRQWJRLHFCQUFlLEdBQVksSUFBSSxDQUFDOztJQWF6QyxDQUFDO0lBWGMsNEJBQUksR0FBakIsVUFBa0IsR0FBVyxFQUFFLE9BQThCOzs7Ozs7d0JBQ3JELEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUMxQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQzt3QkFFZCxXQUFNLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBQTs7d0JBQWxCLFNBQWtCLENBQUM7d0JBRUosV0FBTSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsRUFBQTs7d0JBQXJDLE1BQU0sR0FBRyxTQUE0Qjt3QkFDckMsR0FBRyxHQUFHLElBQUksaUJBQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBRXRFLFdBQU8sR0FBRyxFQUFDOzs7O0tBQ1o7SUFiYSx3QkFBVSxHQUFXLGVBQWUsQ0FBQztJQWNyRCxvQkFBQztDQUFBLEFBZkQsQ0FBMkMsZ0JBQU0sR0FlaEQ7a0JBZm9CLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRleHR1cmVMb2FkZXIudHNcbiAqIFxuICogQEF1dGhvciAgOmR0eXNreShkdHlza3lAb3V0bG9vay5jb20pXG4gKiBARGF0ZSAgICA6IDYvOS8yMDIxLCA2OjI0OjAyIFBNXG4gKi9cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi9jb3JlL1RleHR1cmVcIjtcbmltcG9ydCBMb2FkZXIgZnJvbSBcIi4vTG9hZGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRleHR1cmVMb2FkZXJPcHRpb25zIHtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyPElUZXh0dXJlTG9hZGVyT3B0aW9ucywgVGV4dHVyZT4ge1xuICBwdWJsaWMgc3RhdGljIENMQVNTX05BTUU6IHN0cmluZyA9ICdUZXh0dXJlTG9hZGVyJztcbiAgcHVibGljIGlzVGV4dHVyZUxvYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHVibGljIGFzeW5jIGxvYWQoc3JjOiBzdHJpbmcsIG9wdGlvbnM6IElUZXh0dXJlTG9hZGVyT3B0aW9ucyk6IFByb21pc2U8VGV4dHVyZT4ge1xuICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5zcmMgPSBzcmM7XG5cbiAgICBhd2FpdCBpbWcuZGVjb2RlKCk7XG5cbiAgICBjb25zdCBiaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWcpO1xuICAgIGNvbnN0IHJlcyA9IG5ldyBUZXh0dXJlKGltZy5uYXR1cmFsSGVpZ2h0LCBpbWcubmF0dXJhbEhlaWdodCwgYml0bWFwKTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbiJdfQ==

/***/ }),

/***/ "./src/resource/index.ts":
/*!*******************************!*\
  !*** ./src/resource/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resource = void 0;
var HObject_1 = __webpack_require__(/*! ../core/HObject */ "./src/core/HObject.ts");
var TextureLoader_1 = __webpack_require__(/*! ./TextureLoader */ "./src/resource/TextureLoader.ts");
var GlTFLoader_1 = __webpack_require__(/*! ./GlTFLoader */ "./src/resource/GlTFLoader.ts");
var Resource = (function (_super) {
    __extends(Resource, _super);
    function Resource() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isResource = true;
        _this._loaders = {};
        _this._resources = {};
        return _this;
    }
    Resource.prototype.register = function (type, loader) {
        this._loaders[type] = loader;
    };
    Resource.prototype.load = function (info, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this._resources[info.name]) {
                    return [2, this._resources[info.name]];
                }
                return [2, this._loaders[info.type].load(info.src, options || {})
                        .then(function (res) {
                        _this._resources[info.name] = res;
                        return res;
                    })];
            });
        });
    };
    Resource.prototype.get = function (name) {
        return this._resources[name];
    };
    Resource.CLASS_NAME = 'Resource';
    return Resource;
}(HObject_1.default));
exports.Resource = Resource;
var resource = new Resource();
resource.register('texture', new TextureLoader_1.default());
resource.register('gltf', new GlTFLoader_1.default());
exports["default"] = resource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0EsMkNBQXNDO0FBRXRDLGlEQUE0QztBQUM1QywyQ0FBc0M7QUFPdEM7SUFBOEIsNEJBQU87SUFBckM7UUFBQSxxRUFpQ0M7UUEvQlEsZ0JBQVUsR0FBWSxJQUFJLENBQUM7UUFFMUIsY0FBUSxHQUF1QyxFQUFFLENBQUM7UUFDbEQsZ0JBQVUsR0FBMEIsRUFBRSxDQUFDOztJQTRCakQsQ0FBQztJQTFCUSwyQkFBUSxHQUFmLFVBQ0UsSUFBVyxFQUFFLE1BQThCO1FBRTNDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQy9CLENBQUM7SUFFWSx1QkFBSSxHQUFqQixVQUNFLElBQThDLEVBQzlDLE9BQW1EOzs7O2dCQUVuRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUM5QixXQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDO2lCQUNuQztnQkFFRCxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sSUFBSSxFQUFFLENBQUM7eUJBQzFELElBQUksQ0FBQyxVQUFBLEdBQUc7d0JBQ1AsS0FBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO3dCQUNqQyxPQUFPLEdBQUcsQ0FBQztvQkFDYixDQUFDLENBQUMsRUFBQzs7O0tBQ047SUFFTSxzQkFBRyxHQUFWLFVBQ0UsSUFBWTtRQUVaLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBL0JhLG1CQUFVLEdBQVcsVUFBVSxDQUFDO0lBZ0NoRCxlQUFDO0NBQUEsQUFqQ0QsQ0FBOEIsaUJBQU8sR0FpQ3BDO0FBakNZLDRCQUFRO0FBbUNyQixJQUFNLFFBQVEsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO0FBQ2hDLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLElBQUksdUJBQWEsRUFBRSxDQUFDLENBQUM7QUFDbEQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxvQkFBVSxFQUFFLENBQUMsQ0FBQztBQUU1QyxrQkFBZSxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogaW5kZXgudHNcbiAqIFxuICogQEF1dGhvciAgOmR0eXNreShkdHlza3lAb3V0bG9vay5jb20pXG4gKiBARGF0ZSAgICA6IDYvOS8yMDIxLCA2OjIzOjMzIFBNXG4gKi9cbmltcG9ydCBIT2JqZWN0IGZyb20gXCIuLi9jb3JlL0hPYmplY3RcIjtcbmltcG9ydCBMb2FkZXIgZnJvbSBcIi4vTG9hZGVyXCI7XG5pbXBvcnQgVGV4dHVyZUxvYWRlciBmcm9tIFwiLi9UZXh0dXJlTG9hZGVyXCI7XG5pbXBvcnQgR2xURkxvYWRlciBmcm9tIFwiLi9HbFRGTG9hZGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVJlc291cmNlTG9hZGVyIHtcbiAgdGV4dHVyZTogVGV4dHVyZUxvYWRlcjtcbiAgZ2x0ZjogR2xURkxvYWRlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlc291cmNlIGV4dGVuZHMgSE9iamVjdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ0xBU1NfTkFNRTogc3RyaW5nID0gJ1Jlc291cmNlJztcbiAgcHVibGljIGlzUmVzb3VyY2U6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgX2xvYWRlcnM6IHtbdHlwZTogc3RyaW5nXTogTG9hZGVyPGFueSwgYW55Pn0gPSB7fTtcbiAgcHJpdmF0ZSBfcmVzb3VyY2VzOiB7W25hbWU6IHN0cmluZ106IGFueX0gPSB7fTtcblxuICBwdWJsaWMgcmVnaXN0ZXI8VFR5cGUgZXh0ZW5kcyBrZXlvZiBJUmVzb3VyY2VMb2FkZXI+KFxuICAgIHR5cGU6IFRUeXBlLCBsb2FkZXI6IElSZXNvdXJjZUxvYWRlcltUVHlwZV1cbiAgKSB7XG4gICAgdGhpcy5fbG9hZGVyc1t0eXBlXSA9IGxvYWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkPFRUeXBlIGV4dGVuZHMga2V5b2YgSVJlc291cmNlTG9hZGVyPihcbiAgICBpbmZvOiB7dHlwZTogVFR5cGUsIG5hbWU6IHN0cmluZywgc3JjOiBzdHJpbmd9LFxuICAgIG9wdGlvbnM/OiBJUmVzb3VyY2VMb2FkZXJbVFR5cGVdWyd0eXBlJ11bJ29wdGlvbnMnXVxuICApOiBQcm9taXNlPElSZXNvdXJjZUxvYWRlcltUVHlwZV1bJ3R5cGUnXVsncmVzb3VyY2UnXT4ge1xuICAgIGlmICh0aGlzLl9yZXNvdXJjZXNbaW5mby5uYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlc1tpbmZvLm5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9sb2FkZXJzW2luZm8udHlwZV0ubG9hZChpbmZvLnNyYywgb3B0aW9ucyB8fCB7fSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlc1tpbmZvLm5hbWVdID0gcmVzO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0PFRUeXBlIGV4dGVuZHMga2V5b2YgSVJlc291cmNlTG9hZGVyPihcbiAgICBuYW1lOiBzdHJpbmdcbiAgKTogSVJlc291cmNlTG9hZGVyW1RUeXBlXVsndHlwZSddWydyZXNvdXJjZSddIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlc1tuYW1lXTtcbiAgfVxufVxuXG5jb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSgpO1xucmVzb3VyY2UucmVnaXN0ZXIoJ3RleHR1cmUnLCBuZXcgVGV4dHVyZUxvYWRlcigpKTtcbnJlc291cmNlLnJlZ2lzdGVyKCdnbHRmJywgbmV3IEdsVEZMb2FkZXIoKSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlc291cmNlO1xuIl19

/***/ }),

/***/ "./node_modules/_url@0.11.0@url/url.js":
/*!*********************************************!*\
  !*** ./node_modules/_url@0.11.0@url/url.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/_punycode@1.3.2@punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/_url@0.11.0@url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/_querystring@0.2.0@querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/_url@0.11.0@url/util.js":
/*!**********************************************!*\
  !*** ./node_modules/_url@0.11.0@url/util.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports = /*#__PURE__*/function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ "./node_modules/_sockjs-client@1.5.2@sockjs-client/dist/sockjs.js");

var BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js");

module.exports = /*#__PURE__*/function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  var _super = _createSuper(SockJSClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _super.call(this);
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(/*! ./SockJSClient */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js");
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),

/***/ "/mnt/h/ComplexMind/ray-tracing-webgpu/node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?/":
/*!**************************************************************************************************************************!*\
  !*** /mnt/h/ComplexMind/ray-tracing-webgpu/node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?/ ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __resourceQuery = "?/";

/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/_strip-ansi@3.0.1@strip-ansi/index.js");

var socket = __webpack_require__(/*! ./socket */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js");

var overlay = __webpack_require__(/*! ./overlay */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js");

var _require = __webpack_require__(/*! ./utils/log */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js"),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(/*! ./utils/sendMessage */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js");

var reloadApp = __webpack_require__(/*! ./utils/reloadApp */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js");

var createSocketUrl = __webpack_require__(/*! ./utils/createSocketUrl */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js");

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__("./node_modules/webpack/hot sync ^\\.\\/log$");

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(/*! ansi-html */ "./node_modules/_ansi-html@0.0.7@ansi-html/index.js");

var _require = __webpack_require__(/*! html-entities */ "./node_modules/_html-entities@1.4.0@html-entities/lib/index.js"),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(/*! ./clients/SockJSClient */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js");
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global self */

var url = __webpack_require__(/*! url */ "./node_modules/_url@0.11.0@url/url.js");

var getCurrentScriptSource = __webpack_require__(/*! ./getCurrentScriptSource */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js");

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \***********************************************************************************************************/
/***/ ((module) => {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(/*! loglevel */ "./node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js").getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(/*! ./log */ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js"),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ "./node_modules/_webpack@5.52.0@webpack/hot/emitter.js");

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),

/***/ "./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),

/***/ "./node_modules/_webpack@5.52.0@webpack/hot/dev-server.js":
/*!****************************************************************!*\
  !*** ./node_modules/_webpack@5.52.0@webpack/hot/dev-server.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/* globals __webpack_hash__ */
if (true) {
	var lastHash;
	var upToDate = function upToDate() {
		return lastHash.indexOf(__webpack_require__.h()) >= 0;
	};
	var log = __webpack_require__(/*! ./log */ "./node_modules/_webpack@5.52.0@webpack/hot/log.js");
	var check = function check() {
		module.hot
			.check(true)
			.then(function (updatedModules) {
				if (!updatedModules) {
					log("warning", "[HMR] Cannot find update. Need to do a full reload!");
					log(
						"warning",
						"[HMR] (Probably because of restarting the webpack-dev-server)"
					);
					window.location.reload();
					return;
				}

				if (!upToDate()) {
					check();
				}

				__webpack_require__(/*! ./log-apply-result */ "./node_modules/_webpack@5.52.0@webpack/hot/log-apply-result.js")(updatedModules, updatedModules);

				if (upToDate()) {
					log("info", "[HMR] App is up to date.");
				}
			})
			.catch(function (err) {
				var status = module.hot.status();
				if (["abort", "fail"].indexOf(status) >= 0) {
					log(
						"warning",
						"[HMR] Cannot apply update. Need to do a full reload!"
					);
					log("warning", "[HMR] " + log.formatError(err));
					window.location.reload();
				} else {
					log("warning", "[HMR] Update failed: " + log.formatError(err));
				}
			});
	};
	var hotEmitter = __webpack_require__(/*! ./emitter */ "./node_modules/_webpack@5.52.0@webpack/hot/emitter.js");
	hotEmitter.on("webpackHotUpdate", function (currentHash) {
		lastHash = currentHash;
		if (!upToDate() && module.hot.status() === "idle") {
			log("info", "[HMR] Checking for updates on the server...");
			check();
		}
	});
	log("info", "[HMR] Waiting for update signal from WDS...");
} else {}


/***/ }),

/***/ "./node_modules/_webpack@5.52.0@webpack/hot/emitter.js":
/*!*************************************************************!*\
  !*** ./node_modules/_webpack@5.52.0@webpack/hot/emitter.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/_events@3.3.0@events/events.js");
module.exports = new EventEmitter();


/***/ }),

/***/ "./node_modules/_webpack@5.52.0@webpack/hot/log-apply-result.js":
/*!**********************************************************************!*\
  !*** ./node_modules/_webpack@5.52.0@webpack/hot/log-apply-result.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function (updatedModules, renewedModules) {
	var unacceptedModules = updatedModules.filter(function (moduleId) {
		return renewedModules && renewedModules.indexOf(moduleId) < 0;
	});
	var log = __webpack_require__(/*! ./log */ "./node_modules/_webpack@5.52.0@webpack/hot/log.js");

	if (unacceptedModules.length > 0) {
		log(
			"warning",
			"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)"
		);
		unacceptedModules.forEach(function (moduleId) {
			log("warning", "[HMR]  - " + moduleId);
		});
	}

	if (!renewedModules || renewedModules.length === 0) {
		log("info", "[HMR] Nothing hot updated.");
	} else {
		log("info", "[HMR] Updated modules:");
		renewedModules.forEach(function (moduleId) {
			if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
				var parts = moduleId.split("!");
				log.groupCollapsed("info", "[HMR]  - " + parts.pop());
				log("info", "[HMR]  - " + moduleId);
				log.groupEnd("info");
			} else {
				log("info", "[HMR]  - " + moduleId);
			}
		});
		var numberIds = renewedModules.every(function (moduleId) {
			return typeof moduleId === "number";
		});
		if (numberIds)
			log(
				"info",
				'[HMR] Consider using the optimization.moduleIds: "named" for module names.'
			);
	}
};


/***/ }),

/***/ "./node_modules/_webpack@5.52.0@webpack/hot/log.js":
/*!*********************************************************!*\
  !*** ./node_modules/_webpack@5.52.0@webpack/hot/log.js ***!
  \*********************************************************/
/***/ ((module) => {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function (level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function (level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function (level) {
	logLevel = level;
};

module.exports.formatError = function (err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!***************************************************************!*\
  !*** ./node_modules/webpack/hot/ sync nonrecursive ^\.\/log$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./log": "./node_modules/_webpack@5.52.0@webpack/hot/log.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/hot sync ^\\.\\/log$";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("d234485df29ec2caba19")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "ray-tracing-webgpu:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises;
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 					blockingPromises.push(promise);
/******/ 					waitForBlockingPromises(function () {
/******/ 						return setStatus("ready");
/******/ 					});
/******/ 					return promise;
/******/ 				case "prepare":
/******/ 					blockingPromises.push(promise);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises.length === 0) return fn();
/******/ 			var blocker = blockingPromises;
/******/ 			blockingPromises = [];
/******/ 			return Promise.all(blocker).then(function () {
/******/ 				return waitForBlockingPromises(fn);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						blockingPromises = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error("apply() is only allowed in ready status");
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId) {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateray_tracing_webgpu"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						!__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						__webpack_require__.o(installedChunks, chunkId) &&
/******/ 						installedChunks[chunkId] !== undefined
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("/mnt/h/ComplexMind/ray-tracing-webgpu/node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?/");
/******/ 	__webpack_require__("./node_modules/_webpack@5.52.0@webpack/hot/dev-server.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map